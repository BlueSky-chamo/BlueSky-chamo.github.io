<?xml version="1.0" encoding="utf-8"?>
<search>
  
    
    <entry>
      <title></title>
      <url>%2F2017%2F06%2F21%2F%E5%B5%8C%E5%85%A5%E5%BC%8Fc%E7%BC%96%E7%A8%8B%E9%A3%8E%E6%A0%BC%2F</url>
      <content type="text"><![CDATA[title: 嵌入式编程风格date: 2017-03-30categories: 单片机 tags: [编程风格] 前言编程的总则: 编程首要是要考虑程序的可行性，然后是可读性、可移植性、健壮性以及可测试性。 原文为C语言进阶之道中的编程风格章节 排版（1）代码缩进空格数为4个。若是可能，尽量用空格来代替Tab键，因为有些编译器不支持Tab键 BOOL BufClr(UINT8 * dest,UINT32 size) { if(NULL ==dest || NULL==size) { return FALSE; } } （2）较长的语句要分2行来书写，并用‘\’符号隔开。 if((UINT8) uncrc != Packet.down_ser.mCrc[0] \ ||(UINT8)(uncrc&gt;&gt;8)!= Packet.down_ser.mCrc[1]) { BELL(ON); } （3）函数代码的参数过长，分多行来书写。 void UARTSendAndRecv(UINT8 *ucSendBuf, UINT8 ucSendLength, UINT8 *ucRecvBuf, UINT8 ucRecvLength) { … } （4）if、do、while、switch、for、case、default等关键字，必须加上大括号{}。 if(bSendEnd) { BELL(ON); } else { BELL(OFF); } switch(ucintStatus) { case USB_INT_EP2_OUT: { USBCiEP2Send(USBMainBuf,ucrecvLen); USBCiEP1Send(USBMainBuf,ucrecvLen); } break; case USB_INT_EP2_IN: { USBCiWriteSingleCmd (CMD_UNLOCK_USB); } break; … } 注释（1）边写代码边注释，修改代码同时修改相应的注释，以保证注释与代码的一致性。不再有用的注释要删除。 注释应当准确、易懂，防止注释有二义性。错误的注释不但无益反而有害。 尽量避免在注释中使用缩写，特别是不常用缩写。注释的位置应与被描述的代码相邻，可以放在代码的上方或右方，不可放在下方。 （2）说明性文件必选在文件头着重说明，例如.c、.h文件 （3）函数头应该进行注释，例如函数名称、输入参数、返回值、功能说明。 ******将所有参数写入AT24C64,共4字节********************* *说明:将表号和用户电量共四字节数据写入AT24C64中 *入口参数: * 1.数据间接寻址地址-buf * 2.写入到AT24C64的地址字-addh,addrl * 3.写入字节数-count *出口参数:1表示写成功,0表示写失败 ***************************************************************/ bit write_byte( unsigned charchar * buf, unsigned char addrh, unsigned char addrl, unsigned char count) { …… } （4）全局变量要注释其功能，若为关键的局部变量同样需要注释其功能。 volatile UINT8 __ucSysMsg=SYS_IDLE; void SYSSetMsgPriority(void) { SYSMSG Msgt;//临时存储消息 UINT8 i; } （5）复杂的宏定义同样要加上注释。 /* SYS_MSG_MAP 建立一个消息映射 宏参数NAME：消息映射表的名字 宏参数NUM_OF_MSG:消息映射的个数 */ #define SYS_MSG_MAP(NAME,NUM_OF_MSG) do/ { / DEFINE_MSG_NAME((NAME));/ UINT8 i;/ for(i=0;i&lt; NUM_OF_MSG;i++)/ {/ ININ_CUR_MSG(i)/ }/ }while(0) （6）复杂的结构体同样要加上注释。 奇偶校验结构体*/ typedef struct _ PKT_PARITY { UINT8 m_ucHead1; //首部1 UINT8 m_ucHead2; //首部2 UINT8 m_ucOptCode; //操作码 UINT8 m_ucDataLength; //数据长度 UINT8 m_szDataBuf[16];//数据 UINT8 m_ucParity; //奇偶校验值 }PKT_PARITY; （7）相对独立的语句组注释。对这一组语句做特别说明，写在语句组上侧，和此语句组之间不留空行，与当前语句组的缩进一致。注意，说明语句组的注释一定要写在语句组上面，不能写在语句组下面。 标识符（1）变量命名局部变量以小写字母命名；全局变量以首字母大写方式命名（骆驼式）；定义类型和宏定义常数以大写字母命名；变量的作用域越大，它的名字所带有的信息就应该越多。局部变量： int student_age;全局变量： int StudentAge;宏定义常数：#define STUDENT_NUM 10类型定义： typedef INT16S int; （2） 变量命名要注意缩写而且让人简单易懂，若是特别缩写要详细说明。经常用到的缩写如：Count 可缩写为CntMessage 可缩写为MsgPacket 可缩写为PktTemp 可缩写为Tmp平时不经常用到的缩写，要注释：SerialCommunication 可缩写为SrlComm //串口通信变量SerialCommunicationStatus 可缩写为SrlCommStat //串口通信状态变量 （3）全局变量和全局函数的命名一定要详细，不惜多用几个单词，例如函数UARTPrintfStringForLCD因为它们在整个项目的许多源文件中都会用到，必须让使用者明确这个变量或函数是干什么用的。局部变量和只在一个源文件中调用的内部函数的命名可以。简略一些，但不能太短，不要使用单个字母做变量名，只有一个例外：用i、j 、k 做循环变量是可以的。 （4）用于编译开关的文件头，必须加上当前文件名称，防止编译时产生冲突。例如在UARTInterface.h 头文件中，必须加上以下内容 #ifndef __UARTINTERFACE_H__ #define __UARTINTERFACE_H__ extern void UARTPrintfString(CONST INT8* str); extern void UARTSendNBytes(UINT8 *ucSendBytes,UINT8 ucLen); …… //其他外部声明的代码 #endif （5）禁止用汉语拼音作为标识符名称，可读性极差 （6）建议名称间的区别要显而易见。使用标识符名称要注意的一个相关问题是发生在名称之间只有一个字符或少数字符不同的情况，特别是名称比较长时，当名称间的区别很容易被误读时问题就比较显著，比如1（数字1）和l（L 的小写）、0 和O、2 和Z、5 和S，或者n 和h。 表达式（1）不要编写太复杂的复合表达式； i = a &gt;= b &amp;&amp; c &lt; d &amp;&amp; c + f &lt;= g + h; //复合表达式过于复杂 （2）不要有多用途的复合表达式 d = (a = b + c) + r ; //应拆分为两个语句： a = b + c; d = a + r; （3）如果代码行中的运算符比较多，用括号确定表达式的操作顺序，避免使用默认的优先级。 if(a | b &amp;&amp; a &amp; c) //不良的风格 if((a | b) &amp;&amp; (a &amp; c)) //良好的风格 基本语句if语句（1）布尔变量与零值比较不可将布尔变量直接与TRUE、FALSE 或者1、0 进行比较。根据布尔类型的语义，零值为“假”（记为FALSE），任何非零值都是“真”（记为TRUE）。TRUE的值究竟是什么并没有统一的标准。例如Visual C++ 将TRUE 定义为1，而Visual Basic 则将TRUE 定义为-1。例：假设布尔变量名字为flag，它与零值比较的标准if 语句如下： if (flag) // 表示flag为真时满足条件 if (!flag) // 表示flag为假时满足条件 其它的用法都属于不良风格，例如： if (flag == TRUE) if (flag == 1 ) if (flag == FALSE) if (flag == 0) （2）整型变量与零值比较应当将整型变量用“==”或“！=”直接与0比较。例：假设整型变量为value，它与零值比较的标准if 语句如下： if (value == 0) if (value != 0) 不可模仿布尔变量的风格而写成 if (value) // 会让人误解 value 是布尔变量 if (!value) （3）浮点变量与零值比较不可将浮点变量用“==”或“！=”与任何数字比较。千万要留意，无论float 还是double 类型变量，都有精度限制。所以一定要避免将浮点变量用“==”或“！=”与数字比较，应该设法转化成“&gt;=”或“&lt;=”形式。假设浮点变量的名字为x，应当将 if (x == 0.0) // 隐含错误的比较 转化为 if ((x&gt;=-EPSINON) &amp;&amp; (x&lt;=EPSINON)) //EPSINON 是精度 其他（1）一些常量(如圆周率PI)或者常需要在调试时修改的参数最好用#define定义，但要注意宏定义只是简单的替换，因此有些括号不可少。 （2）不要轻易调用某些库函数，因为有些库函数代码很长(我是反对使用printf之类的库函数的，但是是一家之言，并不勉强各位)。 （3）对各运算符的优先级有所了解，记不得没关系，加括号就是，千万不要自作聪明说自己记得很牢。 （4）不管有没有无效分支，switch函数一定要defaut这个分支。一来让阅读者知道程序员并没有遗忘default,并且防止程序运行过程中出现的意外(健壮性)。 （5）函数的参数和返回值没有的话最好使用void。 （6）一些常数和表格之类的应该放到code中去以节省RAM。 （7）程序编完编译看有多少code多少data，注意不要使堆栈为难。 （8）减少函数本身或函数间的递归调用 （9）编写可重入函数时，若使用全局变量，则应通过关中断、信号量（即P、V操作）等手段对其加以保护。 （10）在多重循环中，应将最忙的循环放在最内层 （11）避免循环体内含判断语句，应将循环语句置于判断语句的代码块之中。 （12）系统运行之初，要初始化有关变量及运行环境，防止未经初始化的变量被引用。 （13）编写代码时要注意随时保存，并定期备份，防止由于断电、硬盘损坏等原因造成代码丢失。]]></content>
    </entry>

    
    <entry>
      <title></title>
      <url>%2F2017%2F06%2F21%2F%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E4%B9%8B%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8F%2F</url>
      <content type="text"><![CDATA[title: 排序算法之选择排序date: 2017-04-30categories: C语言 tags: [C排序] 选择排序选择排序（从小到大）的基本思想是先选出最小的数，放在第一个位置；然后，选出第二小的数，放在第二个位置；以此类推，直到所有的数从小到大排序。 算法描述选择排序对大小为N的无序数组R[N]进行排序，进行N-1轮选择过程。第i轮选取第i小的数，并将其放在第i个位置上。当第N-1次完成时，第N小（也就是最大）的数自然在最后的位置上。 下面对 3 2 4 1 进行选择排序说明排序过程，使用min_index 记录当前最小的数所在的位置。 第1轮 排序过程 （寻找第1小的数所在的位置） 3 2 4 1（min_index=1） 3 2 4 1（3 &gt; 2， min_index=2） 3 2 4 1（2 &lt; 4， min_index=2） 3 2 4 1（2 &gt; 1， min_index=4） 1 2 4 3 （第1轮结果，将3和1交换，也就是位置1和位置4交换） 第2轮 排序过程 （寻找第2小的数所在的位置） 1 2 4 3（第1轮结果， min_index=2，只需要从位置2开始寻找） 1 2 4 3（4 &gt; 2， min_index=2） 1 2 4 3（3 &gt; 2， min_index=2） 1 2 4 3（第2轮结果，因为min_index位置刚好在第2个位置，无需交换） 第3轮 排序过程 （寻找第3小的数所在的位置） 1 2 4 3（第2轮结果， min_index=3，只需要从位置2开始寻找） 1 2 4 3（4 &gt; 3， min_index=4） 1 2 3 4（第3轮结果，将3和4交换，也就是位置4和位置3交换） 至此，排序完毕。 #代码实现# #include&lt;stdio.h&gt; #include&lt;stdlib.h&gt; #define N 8 void select_sort(int a[],int n); //选择排序实现,n为数组a的元素个数 void select_sort(int a[],int n) { int i=0; int j=0; //进行N-1轮选择 for(i=0; i&lt;n-1; i++) { int min_index = i; //找出第i小的数所在的位置 for(j=i+1; j&lt;n; j++) { if(a[j] &lt; a[min_index]) { min_index = j; } } //将第i小的数，放在第i个位置；如果刚好，就不用交换 if( i != min_index) { int temp = a[i]; a[i] = a[min_index]; a[min_index] = temp; } } } int main() { int i=0; int num[N] = {89, 38, 11, 78, 96, 44, 19, 25}; select_sort(num, N); for(i=0; i&lt;N; i++) printf(&quot;%d &quot;, num[i]); printf(&quot;\n&quot;); system(&quot;pause&quot;); return 0; } #性能分析#在比较次数上为n(n-1)/2时间复杂度为o(nn)在最好的情况下，数字初始有序则只需要比较即可，不存在交换操作。在最差情况下，数字初始逆序。同样时间复杂度为o(n*n)。]]></content>
    </entry>

    
    <entry>
      <title></title>
      <url>%2F2017%2F06%2F21%2F%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E4%B9%8B%E5%B8%8C%E5%B0%94%E6%8E%92%E5%BA%8F%2F</url>
      <content type="text"><![CDATA[title: 排序算法之希尔排序date: 2017-03-30categories: C语言tags: [C排序] 希尔排序希尔(Shell)排序又称为缩小增量排序，是直接插入排序的加强版。希尔排序的基本思想：把记录按步长 gap 分组，对每组记录采用直接插入排序方法进行排序。随着步长逐渐减小，所分成的组包含的记录越来越多，当步长的值减小到 1 时，整个数据合成为一组，构成一组有序记录。初始时，有一个大小为 10 的无序序列。 在第一趟排序中，设 gap1 = N / 2 = 5，即相隔距离为 5 的元素组成一组，可以分为 5 组。按照直接插入排序的方法对每个组进行排序。 在第二趟排序中，gap2 = gap1 / 2 = 2 (取整数)。这样每相隔距离为 2 的元素组成一组，可以分为 2 组。按照直接插入排序的方法对每个组进行排序。 在第三趟排序中，gap3 = gap2 / 2 = 1。 这样相隔距离为 1 的元素组成一组，即只有一组。按照直接插入排序的方法对每个组进行排序。此时，排序已经结束。 图中有两个相等数值的元素 5 和 5 ，在排序过程中，两个元素位置交换了。表明希尔排序是不稳定的算法。 代码实现#include &lt;stdio.h&gt; #include &lt;stdlib.h&gt; void shellSort(int a[],int len) { int step; int i,j; int temp; for(step=len/2; step&gt;0;step/=2) //step用来控制步长,最后递减到1 { // i从第step开始排列，应为插入排序的第一个元素 // 可以先不动，从第二个开始排序 for(i=step;i&lt;len;i++) { temp = a[i]; for(j=i-step;(j&gt;=0 &amp;&amp; temp &lt; a[j]);j-=step) { a[j+step] = a[j]; } a[j+step] = temp; //将第一个位置填上 } } } void main() { int i; int j; int a[] = {5, 18, 151, 138, 160, 63, 174, 169, 79, 200}; int len = sizeof(a)/sizeof(int); printf(&quot;Begin sorting...\n&quot;); for (i=0;i&lt;len;i++) { printf(&quot;%d\t&quot;,a[i]); } shellSort(a,len); printf(&quot;After sorting...\n&quot;); for (j=0;j&lt;len;j++) { printf(&quot;%d\t&quot;,a[j]); } } 性能分析 实验验证环境：VC6.0]]></content>
    </entry>

    
    <entry>
      <title></title>
      <url>%2F2017%2F06%2F21%2F%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E4%B9%8B%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F%2F</url>
      <content type="text"><![CDATA[title: 排序算法之冒泡排序date: 2017-03-30categories: C语言tags: [C排序] 冒泡排序冒泡排序：依次比较相邻的数据，将小数据放在前，大数据放在后；即第一趟先比较第1个和第2个数，大数在后，小数在前，再比较第2个数与第3个数，大数在后，小数在前，以此类推则将最大的数”滚动”到最后一个位置；第二趟则将次大的数滚动到倒数第二个位置……第n-1(n为无序数据的个数)趟即能完成排序。如下图中的第一趟比较过程，元素40被移动到最后位置，依次类推，第二趟比较过程将元素14移动到倒数第二位位置，需要N-1趟即可排序完成，实现元素从小到大排序。 算法描述设数组长度为N。 1．比较相邻的前后二个数据，如果前面数据大于后面的数据，就将二个数据交换。if (pDataArray[j] &gt; pDataArray[j + 1]) 2．这样对数组的第0个数据到N-1个数据进行一次遍历后，最大的一个数据就“沉”到数组第N-1个位置。 3．重复前面二步，直到N-1趟排序完成。for (j = 0; j &lt; iDataNum - i - 1; j++) 代码实现#include&lt;stdio.h&gt; #define MAX 8 //交换data1和data2所指向的整形 void DataSwap(int* data1, int* data2) { int temp = *data1; *data1 = *data2; *data2 = temp; } /******************************************************** *函数名称：BubbleSort *参数说明：pDataArray 无序数组； * iDataNum为无序数据个数 *说明： 冒泡排序 *********************************************************/ void BubbleSort(int* pDataArray, int iDataNum) { int i; int j; for (i = 0; i &lt; iDataNum - 1; i++) //走iDataNum-1趟 for (j = 0; j &lt; iDataNum - i - 1; j++) if (pDataArray[j] &gt; pDataArray[j + 1]) DataSwap(&amp;pDataArray[j], &amp;pDataArray[j + 1]);////前面的数大于后面的数则交换，即大数向后移动一位 } int main(void) { int a[MAX]={8,7,5,6,4,3,2,1}; int i=0; BubbleSort(a,MAX); printf(&quot;after:\n&quot;); for(i=0;i&lt;8;i++) { printf(&quot;%d &quot;,a[i]); } printf(&quot;\n&quot;); return 0; } 实验验证环境：VC6.0 算法优化1用一个标记来记录在一趟的比较过程中是否存在交换，如果不存在交换则整个数组已经有序退出排序过程，反之则继续进行下一趟的比较。 void BubbleSort(int* pDataArray, int iDataNum) { BOOL flag = FALSE; //记录是否存在交换 for (int i = 0; i &lt; iDataNum - 1; i++) //走iDataNum-1趟 { flag = FALSE; for (int j = 0; j &lt; iDataNum - i - 1; j++) if (pDataArray[j] &gt; pDataArray[j + 1]) { flag = TRUE; DataSwap(&amp;pDataArray[j], &amp;pDataArray[j + 1]); } if (!flag) //上一趟比较中不存在交换，则退出排序 break; } } 算法优化2如果有100个数的数组，仅前面10个无序，后面90个都已排好序且都大于前面10个数字，那么在第一趟遍历后，最后发生交换的位置必定小于10，且这个位置之后的数据必定已经有序了，记录下这位置，第二次只要从数组头部遍历到这个位置就可以了。 void BubbleSort(int* pDataArray, int iDataNum) { int i; int j; int flag ; //记录是否存在交换 int k; flag=iDataNum; for (i = 0; i &lt; iDataNum - 1; i++) //走iDataNum-1趟 { k=flag; flag=0; for (j = 0; j &lt; k-1; j++) if (pDataArray[j] &gt; pDataArray[j + 1]) { flag = j+1; DataSwap(&amp;pDataArray[j], &amp;pDataArray[j + 1]); } if (flag&lt;0) //上一趟比较中不存在交换，则退出排序 break; } }]]></content>
    </entry>

    
    <entry>
      <title></title>
      <url>%2F2017%2F06%2F21%2F%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E4%B9%8B%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F%2F</url>
      <content type="text"><![CDATA[title: 排序算法之快速排序date: 2017-03-30categories: C语言tags: [C排序] 快速排序快速排序是对冒泡排序的改进，主要思想是分治与递归。分治即通过一次排序将序列分成两部分，左边的部分全部小于基准值，右边的部分大于基准值递归即对分治区间继续采取快速排序主要步骤： 1．先从数列中取出一个数作为基准数。 2．分区过程，将比这个数大的数全放到它的右边，小于或等于它的数全放到它的左边。 3．再对左右区间递归排序，直到各区间只有一个数。 算法描述假设要排序的数组是A[0]……A[N-1]，首先任意选取一个数据（通常选用第一个数据）作为关键数据(key)，然后将所有比它小的数都放到它前面，所有比它大的数都放到它后面，这个过程称为一趟快速排序。一趟快速排序的算法是：1）定义两个变量low和high，将low、high分别设置为要进行排序的序列的起始元素和最后一个元素的下标。第一次，low和high的取值分别为0和n-1，接下来的每次取值由划分得到的序列起始元素和最后一个元素的下标来决定。 2）定义一个变量key，接下来以key的取值为基准将数组A划分为左右两个部分，通 常，key值为要进行排序序列的第一个元素值。第一次的取值为A[0]，以后毎次取值由要划 分序列的起始元素决定。 3）从high所指向的数组元素开始向左扫描，扫描的同时将下标为high的数组元素依次与划分基准值key进行比较操作，直到high不大于low或找到第一个小于基准值key的数组元素，然后将该值赋值给low所指向的数组元素，同时将low右移一个位置。 4）如果low依然小于high，那么由low所指向的数组元素开始向右扫描，扫描的同时将下标为low的数组元素值依次与划分的基准值key进行比较操作，直到low不小于high或找到第一个大于基准值key的数组元素，然后将该值赋给high所指向的数组元素，同时将high左移一个位置。 5）重复步骤(3) (4)，直到low的植不小于high为止，这时成功划分后得到的左右两部分分别为A[low……pos-1]和A[pos+1……high]，其中，pos下标所对应的数组元素的值就是进行划分的基准值key，所以在划分结束时还要将下标为pos的数组元素赋值 为 key。 算法实现#include &lt;stdio.h&gt; #include &lt;stdlib.h&gt; #define N 6 int partition(int arr[], int low, int high){ int key; key = arr[low];//关键数据 //low==high停止 while(low&lt;high){ //从后向前查找比关键数据key小的数据，否则high减1继续查找 while(low &lt;high &amp;&amp; arr[high]&gt;= key ) high--; if(low&lt;high) //若找到第一个比关键数据key小的数据，进行交换，同时low+1开始从前向后查找比key大的数据 arr[low++] = arr[high]; //从前向后查找比关键数据key大的数据，否则low加1继续查找 while( low&lt;high &amp;&amp; arr[low]&lt;=key ) low++; if(low&lt;high) //若找到第一个比关键数据key大的数据，继续交换，同时high-1继续从后向前查找，直到循环结束 arr[high--] = arr[low]; } //low==high时循环结束，此时将关键数据放在此时位置，实现分治 arr[low] = key; return low; } void quick_sort(int arr[], int start, int end){ int pos; if (start&lt;end){ pos = partition(arr, start, end); quick_sort(arr,start,pos-1); quick_sort(arr,pos+1,end); } return; } int main(void){ int i; int arr[N]={32,12,7, 78, 23,45}; printf(&quot;排序前 \n&quot;); for(i=0;i&lt;N;i++) printf(&quot;%d\t&quot;,arr[i]); quick_sort(arr,0,N-1); printf(&quot;\n 排序后 \n&quot;); for(i=0; i&lt;N; i++) printf(&quot;%d\t&quot;, arr[i]); printf (&quot;\n&quot;); system(&quot;pause&quot;); return 0; } 算法实现2#include &lt;stdio.h&gt; #include &lt;time.h&gt; #include &lt;stdlib.h&gt; #define MAX 10 #define SWAP(x, y) {int t=x; x=y; y=t;} void quickSort(int *a, int left, int right); int main(void) { int a[MAX] = {0}; int i; printf(&quot;排序前:\n&quot;); for (i=0; i&lt;MAX; i++) { a[i] = rand()%100; printf(&quot;%d &quot;, a[i]); } quickSort(a, 0, MAX-1); printf(&quot;\n排序后:\n&quot;); for (i=0; i&lt;MAX; i++) { printf(&quot;%d &quot;, a[i]); } printf(&quot;\n&quot;); return 0; } void quickSort(int *a, int left, int right) { if (left &lt; right) { int i = left; int j = right+1; while (1) { //从前向后查找第一个比关键数据a[left]大的数据，否则i+1继续查找 while (i+1&lt;MAX &amp;&amp; a[++i]&lt;a[left]); //从后向前查找第一个比关键数据a[left]小的数据，否则j-1继续查找 while (j-1&gt;-1 &amp;&amp; a[--j]&gt;a[left]); //知道i==j跳出循环，第一次分治结束 if (i &gt;= j) { break; } //将两个数据进行交换，即小的数据到前面去，大数据到后面去 SWAP(a[i], a[j]); } //i==j时吗，将关键数据a[left]放在中间位置,实现分治 SWAP(a[left], a[j]); //分治区间递归排序 quickSort(a, left, j-1); quickSort(a, j+1, right); } } 算法优化将基准值设定为序列中间的数，从中间向两边寻找 #include &lt;stdio.h&gt; #include &lt;time.h&gt; #include &lt;stdlib.h&gt; #define MAX 10 #define SWAP(x, y) {int t=x; x=y; y=t;} void quickSort(int *a, int left, int right); int main(void) { int a[MAX] = {0}; int i; printf(&quot;排序前:\n&quot;); for (i=0; i&lt;MAX; i++) { a[i] = rand()%100; printf(&quot;%d &quot;, a[i]); } quickSort(a, 0, MAX-1); printf(&quot;\n排序后:\n&quot;); for (i=0; i&lt;MAX; i++) { printf(&quot;%d &quot;, a[i]); } printf(&quot;\n&quot;); return 0; } void quickSort(int *a, int left, int right) { if (left &lt; right) { //中间元素 int t = a[(left+right)/2]; int i = left - 1; int j = right + 1; while (1) { //从前向后查找比中间元素大的数据 while (a[++i] &lt; t); //从后向前查找比中间元素小的数据 while (a[--j] &gt; t); if (i &gt;= j) { break; } SWAP(a[i], a[j]); } quickSort(a, left, i-1); quickSort(a, j+1, right); } } 算法优化2有指针left和right，对于right，如果其所指的元素的值大于或者等于基准值，那么指针往左移一位，如果小于基准值，则和基准值交换；同理，对于left，如果left所指元素的值小于或者等于基准值，那么指针往右移一位，如果大于基准值，则和基准值交换。从right开始执行，重复这两步骤，直至left == right为止。 #include &lt;stdio.h&gt; #include &lt;time.h&gt; #include &lt;stdlib.h&gt; #define MAX 10 #define SWAP(x, y) {int t=x; x=y; y=t;} void quickSort(int *a, int left, int right); int Partition(int *a, int left, int right); int main(void) { int a[MAX] = {0}; int i; printf(&quot;排序前:\n&quot;); for (i=0; i&lt;MAX; i++) { a[i] = rand()%100; printf(&quot;%d &quot;, a[i]); } quickSort(a, 0, MAX-1); printf(&quot;\n排序后:\n&quot;); for (i=0; i&lt;MAX; i++) { printf(&quot;%d &quot;, a[i]); } printf(&quot;\n&quot;); return 0; } int Partition(int *a, int left, int right) { int pivot = a[left]; while (left &lt; right) { while (left &lt; right &amp;&amp; a[right] &gt;= pivot) { --right; } a[left] = a[right]; while (left &lt; right &amp;&amp; a[left] &lt;= pivot) { ++left; } a[right] = a[left]; } return left; } void quickSort(int *a, int left, int right) { int pivot; if (left &lt; right) { pivot = Partition(a, left, right); quickSort(a, left, pivot-1); quickSort(a, pivot+1, right); } } 性能分析平均时间复杂度：O(nlog2n) 空间复杂度：O(n) 稳定性：不稳定 实验验证环境：vc6.0 参考学习几种快速排序的实现c语言快速排序及代码]]></content>
    </entry>

    
    <entry>
      <title></title>
      <url>%2F2017%2F06%2F21%2F%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E4%B9%8B%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F%2F</url>
      <content type="text"><![CDATA[title: 排序算法之插入排序date: 2017-03-30categories: C语言 tags: [C排序]插入排序基本思想：通过构建有序序列，对于未排序数据，在已排序序列中从后向前扫描，找到相应的位置并插入。 插入排序有N-1趟排序组成，对于P=1趟到p=N-1趟排序，插入排序保证从位置0到位置P的元素为已排序状态。每次遍历的任务是：通过扫描前面已排序的子列表，将位置P处的元素定位到从0到P的子列表之内的正确的位置上。如下图所示，P=1时，位置1上的元素3与子列表4进行比较；P=2时，位置2上的元素1与子列表[3,4]比较；P=3时，位置3上的元素2与子列表[1,3,4]比较。 算法描述假定n是数组的长度，第一个元素被放置在正确的位置上，这样仅需从1-n-1范围内对剩余元素进行排序。对于每次遍历，从0-i-1范围内的元素已经被排好序， 每次遍历的任务是：通过扫描前面已排序的子列表，将位置i处的元素定位到从0到i的子列表之内的正确的位置上。 将arr[i]复制为一个名为key的临时元素。 采用向下扫描列表方式（从后向前方式），key依次与子列表arr[i-1]、arr[i-2]的大小比较 当key小于子列表的某一项时，a[j-1]&gt;key，该项向右移动一个位置，供key使用。a[j] = a[j-1]当key大于子列表某一项时，a[j-1]&lt;key,该项后一位即为key的位置。a[j] = key; 与选择排序不同的是，插入排序将数据向右滑动，并且不会执行交换。 代码实现#include&lt;stdio.h&gt; #define MAX 8 int main(void) { int a[MAX]={8,7,6,5,4,3,2,1}; void insert(int*a,int n);//函数声明 int i=0; insert(a,MAX); printf(&quot;after:\n&quot;); for(i=0;i&lt;8;i++) { printf(&quot;%d &quot;,a[i]); } printf(&quot;\n&quot;); return 0; } void insert(int *a,int n) { int i,j,key; for(i=1;i&lt;n;i++)//控制需要插入的元素 { key=a[i]; //key为要插入的元素 for(j=i;j&gt;0 &amp;&amp; a[j-1]&gt;key;j--) //查找要插入的位置,循环结束,则找到插入位置 { a[j] = a[j-1]; //移动元素的位置.供要插入元素使用 } a[j] = key; //插入需要插入的元素 } } 效率分析空间复杂度O(1)时间复杂度O(n2)：嵌套循环的每一个都花费N次迭代最差情况：反序，需要移动n*(n-1)/2个元素最好情况：正序，不需要移动元素 数组在已排序或者是“近似排序”时，插入排序效率的最好情况运行时间为O(n)（因为内层的for检测总是判定不成立的） 插入排序最坏情况运行时间和平均情况运行时间都为O(n2)。 在列表已被排序时，插入排序是线性算法O(n)。 在列表“近似排序”时，插入排序仍然是线性算法。 在列表的许多元素已位于正确的位置上时，就会出现“近似排序”的条件。 通过使用O(nlog2n)效率的算法（如快速排序）对数组进行部分排序， 然后再进行选择排序，某些高级的排序算法就是这样实现的。 实验验证环境：VC6.0 二分法插入排序插入排序中，总是先寻找插入位置，然后在实行挪动和插入过程；寻找插入位置采用顺序查找的方式（从前向后或者从后向前），既然需要插入的数组已经是有序的，那么可以采用二分查找方法来寻找插入位置，提高算法效率，但算法的时间复杂度仍为O(n2)。 二分法插入排序过程：1.首先，原数组是一个有序序列，iBegin=0 iEnd=count-1。2.将要插入的数与数组中间位置的元素进行比较，如果比中间元素大，则iBegin=mid+1作为下一次判断的数组开头。如果比中间元素小，则iEnd=mid-1作为下一次判断的数组结尾。3.直到iBegin&gt;iEnd结束，iBegin就是新元素插入的位置。4.将数组中从iBegin开始的元素全部向后移动一位，之后在iBegin位置插入新元素。 #include&lt;stdio.h&gt; #define MAX 8 //查找数值iData在长度为iLen的pDataArray数组中的插入位置 int FindInsertIndex(int *pDataArray, int iLen, int iData) { int iBegin = 0; int iEnd = iLen - 1; int index = -1; //记录插入位置 while (iBegin &lt;= iEnd) { index = (iBegin + iEnd) / 2; if (pDataArray[index] &gt; iData) iEnd = index - 1; else iBegin = index + 1; } if (pDataArray[index] &lt;= iData) index++; return index; } /*函数名称：BinaryInsertSort *参数说明：pDataArray 无序数组； * iDataNum为无序数据个数 *说明： 二分查找插入排序 *********************************************************/ void BinaryInsertSort(int* pDataArray, int iDataNum) { int i; for (i = 1; i &lt; iDataNum; i++) //从第2个数据开始插入 { int index = FindInsertIndex(pDataArray, i, pDataArray[i]); //二分寻找插入的位置 if (i != index) //插入位置不为i，才挪动、插入 { int j = i; int temp = pDataArray[i]; while (j &gt; index) //挪动位置 { pDataArray[j] = pDataArray[j-1]; j--; } pDataArray[j] = temp; //插入 } } } int main(void) { int a[MAX]={8,7,6,5,4,3,2,1}; int i=0; BinaryInsertSort(a,MAX); printf(&quot;after:\n&quot;); for(i=0;i&lt;8;i++) { printf(&quot;%d &quot;,a[i]); } printf(&quot;\n&quot;); return 0; }]]></content>
    </entry>

    
    <entry>
      <title></title>
      <url>%2F2017%2F06%2F21%2F%E5%87%BD%E6%95%B0%E6%8C%87%E9%92%88%E6%80%BB%E7%BB%93%2F</url>
      <content type="text"><![CDATA[title: 函数指针与指针函数总结date: 2017-04-30categories: C语言tags: [C指针] #函数指针定义#函数指针是指向函数的指针变量，即本质是一个指针变量。 ##一般函数指针定义## int (funcPtr)(char , int);(funcPtr)表明funcPtr是一个指针，(char , int)表明funcPtr是一个函数，函数参数为char *和int，返回值为in int *(*funcPtr)(char *, int); funcPtr是函数指针，不同的是前面的int *，表明该函数的返回值为int指针。 ##函数指针数组## int (funcPtr[])(char , int);[]的优先级较高，所以funcPtr是数组，里面的元素为函数指针，所指向的函数原型为int funcPtr(char *, int)。 #函数指针传参#函数指针作为一种类型同样可以作为函数的输入与输出。 //作为输入参数 void func(int x, int (*funcPtr)(char *, int)); //作为返回值 void (*func(int x, int y))(int); 这里括号的优先级最高，func(int x, int y)表面func是一个函数，前面的*表明返回值为一个指针，(int)说明该指针为一个参数为int的函数，void表示该函数指针的返回值为void。 上面定义了一个返回值为函数指针的函数，那怎么定义一个函数指针指向该函数呢，看下面： //一步一步来写，首先他是一个函数指针 (*funcPtr)() //指向的函数的参数为int x, int y (*funcPtr)(int x, int y) //指向的函数的返回值为一个指针 (*(*funcPtr)(int x, int y)) //指向的函数的返回值为一个指针，该指针是参数为int的函数指针 (*(*funcPtr)(int x, int y))(int) //指向的函数的返回值为一个指针，该指针是返回值为void的函数指针 void (*(*funcPtr)(int x, int y))(int) 函数指针和函数原型就差一个(*)，如果知道函数原型的话将函数名改成指针就行了。 void (*func(int x, int y))(int); void (*(*funcPtr)(int x, int y))(int); ##typedef定义##另一种简单的方法是使用typedef，将函数指针定义成一种类型后，可以方便的在函数中使用。 typedef void (*funcPtr1)(int);//定义返回值的函数指针 funcPtr1 (*funcPtr)(int x, int y); #函数指针应用# ##普通函数指针应用##一个函数总是占用一段连续的内存区，而函数名就是该函数所占内存区的首地址（入口地址），所以函数名跟数组名很类似，都是指针常量。函数指针就是指向这个入口地址的指针变量，注意函数指针是一个变量。 void f(int); int main() { //定义函数指针pf并给pf赋值使其指向函数f的入口地址 //pf先跟*结合，说明pf是一个指针，然后与括号结合，说明这个指针指向函数 void (*pf)(int)=f; //等价于void (*pf)(int)=&amp;f; pf(1); (*pf)(2);//把函数指针转换成函数名，这个转换并不需要 f(3); return 0; } void f(int a) { printf(&quot;%d\n&quot;,a); } void (*pf)(int)=&f;函数名被使用时总是由编译器把它转换为函数指针，&amp;操作符只是显示地说明了编译器将隐式执行的任务 。 ##函数指针数组应用## void Touch(); void DuanJiong(); void MeiKai(); void YinJun(); void JiangHaiLong(); void main() { int i; scanf(&quot;%d&quot;,&amp;i); switch(i){ case 0: Touch(); break; case 1: DuanJiong(); break; case 2: MeiKai(); break; case 3: YinJun(); break; case 4: JiangHaiLong(); break; } } void Touch() { puts(&quot;我是Touch&quot;); } void DuanJiong() { puts(&quot;我是段炯&quot;); } void MeiKai() { puts(&quot;我是梅凯&quot;); } void YinJun() { puts(&quot;我是殷俊&quot;); } void JiangHaiLong() { puts(&quot;我是木子&quot;); } 这里只列出了5种情况，如果总共有很多种情况呢，那么就要写一大堆的case语句。而且每次都是从case 1 开始判断。那么是否可以简化代码并且能让程序不做这么多判断呢？这就引出了函数指针数组，顾名思义，就是存放函数指针的数组。现主函数修改如下所示： void main() { int i; void (*p[])()={Touch,DuanJiong,MeiKai,YinJun,JiangHaiLong}; scanf(&quot;%d&quot;,&amp;i); p[i](); } void (*p[])()={Touch,DuanJiong,MeiKai,YinJun,JiangHaiLong};声明了一个函数指针数组并赋值。把每个函数的入口地址存入这个数组，这样就不需要用switch语句了，根据下标i直接找到函数入口，省去了判断的时间。 ##回调函数##回调函数就是一个通过函数指针调用的函数。如果你把函数的指针(地址)作为参数传递给另一个函数，当这个指针被用为调用它所指向的函数时，我们就说这是回调函数。这里函数指针是作为参数传递给另一个函数。冒泡排序，其代码如下： void bubbleSort(int *a,int n) { int i,j; for(i=1;i&lt;n;i++) for(j=1;j&lt;n-i+1;j++){ if(a[j+1]&lt;a[j]){ a[j]=a[j]+a[j+1]; a[j+1]=a[j]-a[j+1]; a[j]=a[j]-a[j+1]; } } } 这个冒泡排序只能对int型数组进行排序。如果我们想写这样一个函数，能同时对int型、float型、double型、char型、结构体类型…数组进行排序，该怎么写呢？也许你会想到函数重载，但是C语言没有这个概念。这里可以用函数指针来实现，其代码比重载更简洁，更高效这也是函数指针的最大用处，参考代码： //回调函数对多种数据类型数组进行冒泡排序 //a表示待排序数组 //n表示数组长度 //size表示数组元素大小(即每个数组元素占用的字节数) //int (*compare)(void *,void *) 声明了一个函数指针，在此作为参数 //void *类型的指针表示指向未知类型的指针,编译器并不会给void类型的指针分配空间,但我们可以把它进行强制类型转换 void bubbleSort(void *a,int n,int size,int (*compare)(void *,void *)) { int i,j,k; char *p,*q; char temp;//交换时暂存一个字节的数据 for(i=0;i&lt;n;i++) for(j=0;j&lt;n-i-1;j++){ //注意p,q都是字符类型的指针，加一都只移动一个字节 p=(char*)a+j*size; q=(char*)a+(j+1)*size; if(compare(p,q)&gt;0) { //一个一个字节的交换,从而实现了一个数据类型数据的交换 for(k=0;k&lt;size;k++){ temp=*p; *p=*q; *q=temp; p++; q++; } } } } （1）void类型的指针未分配空间的，我们可以把它进行强制类型转换成char。（2）对数组元素进行交换时，并不是一次就把两个数交换了，因为我们并不知道数据的确切类型。但知道数组元素的大小，这样就可以逐个字节进行交换。比如对int类型（占用四个字节）的值a、b进行交换，先交换a、b的第一个字节，然后第二个字节…理解了这个代码，该怎么用呢？参数要传入一个函数指针，于是必须要写一个比较两个数大小的函数，且函数原型必须与int (compare)(void ,void *)相匹配。下面是测试各种类型数组排序的代码： #include&lt;stdio.h&gt; typedef struct{ int data; }Node; //函数声明 int charCompare(void *a,void *b); int intCompare(void *a,void *b); int floatCompare(void *a,void *b); int doubleCompare(void *a,void *b); int nodeCompare(void *a,void *b); void bubbleSort(void *a,int n,int size,int (*compare)(void *,void *)); //比较两个char类型的数据的大小，a&gt;b返回1，a&lt;b返回-1，a==b返回0 int charCompare(void *a,void *b) { if(*(char*)a==*(char*)b) return 0; return *(char*)a&gt;*(char*)b?1:-1; } //比较两个int类型的数据的大小 int intCompare(void *a,void *b) { if(*(int*)a==*(int*)b) return 0; return *(int*)a&gt;*(int*)b?1:-1; } //比较两个float类型的数据的大小 int floatCompare(void *a,void *b) { if(*(float*)a==*(float*)b) return 0; return *(float*)a&gt;*(float*)b?1:-1; } //比较两个double类型的数据的大小 int doubleCompare(void *a,void *b) { if(*(double*)a==*(double*)b) return 0; return *(double*)a&gt;*(double*)b?1:-1; } //比较两个结构体类型（Node）的数据的大小 int nodeCompare(void *a,void *b) { if(((Node*)a)-&gt;data == ((Node*)b)-&gt;data) return 0; return ((Node*)a)-&gt;data &gt; ((Node*)b)-&gt;data ? 1 : -1; } void main() { int i=0; //用于测试的各种类型数组 char c[]={&apos;d&apos;,&apos;a&apos;,&apos;c&apos;,&apos;e&apos;,&apos;b&apos;}; int a[]={3,2,4,0,1}; float f[]={4.4,5.5,3.3,0,1}; double b[]={4.4,5.5,3.3,0,1}; Node n[]={{2},{0},{1},{4},{3}}; //对各种数组进行排序 puts(&quot;对char类型数组进行排序：&quot;); bubbleSort(c,5,sizeof(char),charCompare); for(i=0;i&lt;5;i++) printf(&quot;%c &quot;,c[i]); puts(&quot;&quot;); puts(&quot;对int类型数组进行排序：&quot;); bubbleSort(a,5,sizeof(int),intCompare); for(i=0;i&lt;5;i++) printf(&quot;%d &quot;,a[i]); puts(&quot;&quot;); puts(&quot;对float类型数组进行排序：&quot;); bubbleSort(f,5,sizeof(float),floatCompare); for(i=0;i&lt;5;i++) printf(&quot;%.2f &quot;,f[i]); puts(&quot;&quot;); puts(&quot;对double类型数组进行排序：&quot;); bubbleSort(b,5,sizeof(double),doubleCompare); for(i=0;i&lt;5;i++) printf(&quot;%.2lf &quot;,b[i]); puts(&quot;&quot;); puts(&quot;对结构体（Node）类型数组进行排序：&quot;); bubbleSort(n,5,sizeof(Node),nodeCompare); for(i=0;i&lt;5;i++) printf(&quot;%d &quot;,n[i].data); puts(&quot;&quot;); } //回调函数对多种数据类型数组进行冒泡排序 //a表示待排序数组 //n表示数组长度 //size表示数组元素大小(即每个数组元素占用的字节数) //int (*compare)(void *,void *) 声明了一个函数指针，在此作为参数 //void *类型的指针表示指向未知类型的指针,编译器并不会给void类型的指针分配空间,但我们可以把它进行强制类型转换 void bubbleSort(void *a,int n,int size,int (*compare)(void *,void *)) { int i,j,k; char *p,*q; char temp;//交换时暂存一个字节的数据 for(i=0;i&lt;n;i++) for(j=0;j&lt;n-i-1;j++){ //注意p,q都是字符类型的指针，加一都只移动一个字节 p=(char*)a+j*size; q=(char*)a+(j+1)*size; if(compare(p,q)&gt;0){ //一个一个字节的交换,从而实现了一个数据类型数据的交换 for(k=0;k&lt;size;k++){ temp=*p; *p=*q; *q=temp; p++; q++; } } } } #指针函数#指针函数是指带指针的函数，即本质是一个函数。函数返回类型是某一类型的指针 int f(int a, int b);此函数有返回值，返回值为int ，即返回值是指针类型的。上面的函数声明又可以写成如下形式：int f(int a, int b);让指针标志 与int紧贴在一起，而与函数名f间隔开，这样看起来就明了些了，f是函数名，返回值类型是一个int类型的指针。 #指针函数应用#返回指针的函数，确切的说是返回指针类型的函数 #include&lt;stdio.h&gt; //创建长度为n的动态数组 //这是一个指针函数 int* array(int n) { int *a=(int*)malloc(sizeof(int)*n); return a; } void main() { int i,n=3; int *a=array(n); for(i=0;i&lt;n;i++) a[i]=i; free(a);//注意a不用时要free掉，否则内存泄露 } 参考文章函数指针总结http://blog.csdn.net/touch_2011/article/details/6984029]]></content>
    </entry>

    
    <entry>
      <title></title>
      <url>%2F2017%2F06%2F21%2Fstatic%E5%85%B3%E9%94%AE%E5%AD%97%2F</url>
      <content type="text"><![CDATA[title: ｃ语言常用关键字date: 2017-03-30categories: C语言tags: [C关键字] 前言原文为C语言进阶之道中的关键字章节标准C程序一直由下列部分组成：1）正文段——CPU执行的机器指令部分，也就程序。一个程序只有一个副本；只读，这是为了防止程序由于意外事故而修改自身指令；2）初始化数据段（数据段）——在程序中所有赋了初值的全局变量，存放在这里。3）非初始化数据段（bss段）——在程序中没有初始化的全局变量；内核将此段初始化为0。注意：只有全局变量被分配到数据段中。4）栈——增长方向：自顶向下增长；自动变量以及每次函数调用时所需要保存的信息（返回地址；环境信息）。5）堆——动态存储分配。 static关键字作用1在函数体，一个被声明为静态的变量在这一函数被调用过程中维持其值不变。这样定义的变量称为局部静态变量：在局部变量之前加上关键字static，局部变量就被定义成为一个局部静态变量。也就是上面的作用一中提到的在函数体内定义的变量。除了类型符外，若不加其它关键字修饰，默认都是局部变量。比如以下代码： void test1（void） { unsigned char a； static unsigned char b； … a++； b++； } 变量a是局部变量，变量b为局部静态变量。在函数体，一个被声明为静态的变量（也就是局部静态变量）在这一函数被调用过程中维持其值不变。若是连续两次调用上面的函数test1(),读取a和b的值，a=1，b=2。每次调用test1函数，局部变量a都会重新初始化为0x00；然后执行a++；而局部静态变量在调用过程中却能维持其值不变。 局部静态变量的详细特性，注意它的作用域。1）内存中的位置：静态存储区2）初始化：未经初始化的全局静态变量会被程序自动初始化为0（自动对象的值是任意的，除非他被显示初始化）3）作用域：作用域仍为局部作用域，当定义它的函数或者语句块结束的时候，作用域随之结束。注：当static用来修饰局部变量的时候，它就改变了局部变量的存储位置，从原来的栈中存放改为静态存储区。但是局部静态变量在离开作用域之后，并没有被销毁，而是仍然驻留在内存当中，直到程序结束，只不过我们不能再对他进行访问。 作用2在模块内（但在函数体外），一个被声明为静态的变量可以被模块内所用函数访问，但不能被模块外其它函数访问。它是一个本地的全局变量。这样定义的变量也称为全局静态变量：在全局变量之前加上关键字static，全局变量就被定义成为一个全局静态变量。也就是模块内（但在函数体外）声明的静态变量。例如在源文件中，定义全局静态变量n，该变量只能用与该源文件中的函数。 static int n; void test(); void main() { test(); } 定义全局静态变量的好处： 不会被其他文件所访问，修改，是一个本地的局部变量。 其他文件中可以使用相同名字的变量，不会发生冲突。 全局变量的详细特性，注意作用域，可以和局部静态变量相比较：1）内存中的位置：静态存储区（静态存储区在整个程序运行期间都存在）2）初始化：未经初始化的全局静态变量会被程序自动初始化为0（自动对象的值是任意的，除非他被显示初始化）3）作用域：全局静态变量在声明他的文件之外是不可见的。准确地讲从定义之处开始到文件结尾。 当static用来修饰全局变量的时候，它就改变了全局变量的作用域（在声明他的文件之外是不可见的），但是没有改变它的存放位置，还是在静态存储区中。 作用3在模块内，一个被声明为静态的函数只可被这一模块内的其它函数调用。这个函数被限制在声明它的模块的本地范围内使用。这样定义的变量也称为全局静态变量：在全局变量之前加上关键字static，全局变量就被定义成为一个全局静态变量。也就是上述作用二中提到的在模块内（但在函数体外）声明的静态变量。 定义全局静态变量的好处： 不会被其他文件所访问，修改，是一个本地的局部变量。 其他文件中可以使用相同名字的变量，不会发生冲突。 全局变量的详细特性，注意作用域，可以和局部静态变量相比较：1）内存中的位置：静态存储区（静态存储区在整个程序运行期间都存在）2）初始化：未经初始化的全局静态变量会被程序自动初始化为0（自动对象的值是任意的，除非他被显示初始化）3）作用域：全局静态变量在声明他的文件之外是不可见的。准确地讲从定义之处开始到文件结尾。 当static用来修饰全局变量的时候，它就改变了全局变量的作用域（在声明他的文件之外是不可见的），但是没有改变它的存放位置，还是在静态存储区中。 const关键字（1）const关键字修饰的变量可以认为有只读属性，但它绝不与常量划等号。 const int i=5; int j=0; i=j; //非法，导致编译错误，因为只能被读 j=i; //合法 （2）const关键字修饰的变量在声明时必须进行初始化。 const int i=5; //合法 const int j; //非法，导致编译错误 （3）用const声明的变量虽然增加了分配空间，但是可以保证类型安全。const最初是从C++变化得来的，它可以替代define来定义常量。在旧版本(标准前)的c中，如果想建立一个常量，必须使用预处理器： #define PI 3.14159 此后无论在何处使用PI，都会被预处理器以3.14159替代。编译器不对PI进行类型检查，如果使用不慎，很可能由预处理引入错误。而且，我们也不能得到PI的地址（即不能向PI传递指针和引用）。const的出现，比较好的解决了上述问题。 （4）C标准中，const定义的常量是全局的。 （5）指针定义，若是想定义一个只读属性的指针，那么关键字const要放到‘* ’后面。 char *const cp; //指针不可改变，但指向的内容可以改变 char const *pc1; //指针可以改变，但指向的内容不能改变 const char *pc2; //同上（后两个声明是等同的） （6）将函数传入参数声明为const，以指明使用这种参数仅仅是为了效率的原因，而不是想让调用函数能够修改对象的值。参数const通常用于参数为指针或引用的情况，且只能修饰输入参数;若输入参数采用“值传递”方式，由于函数将自动产生临时变量用于复制该参数，该参数本就不需要保护，所以不用const修饰。 void fun0(const int * a ); void fun1(const int &amp; a); 调用函数的时候，用相应的变量初始化const常量，则在函数体中，按照const所修饰的部分进行常量化，如形参为const int * a，则不能对传递进来的指针所指向的内容进行改变，保护了原指针所指向的内容；如形参为const int &amp; a，则不能对传递进来的引用对象进行改变，保护了原对象的属性。 （7）修饰函数返回值，可以阻止用户修改返回值。（在嵌入式C中一般不用，主要用于C++） （8）const消除了预处理器的值替代的不良影响，并且提供了良好的类型检查形式和安全性 两个常用的标准C库函数声明，它们都是使用const的典范：1.字符串拷贝函数： char *strcpy（char *strDest，const char *strSrc）； 2.返回字符串长度函数： int strlen（const char *str）； volatile关键定义为volatile 的变量是说这变量可能会被意想不到地改变，这样，编译器就不会去假设这个变量的值了。精确地说就是，优化器在用到这个变量时必须每次都小心地重新读取这个变量的值，而不是使用保存在寄存器里的备份。 由于访问寄存器的速度要快过RAM，所以编译器一般都会作减少存取外部RAM的优化。比如： static int i=0; int main(void) { ... while (1) { if (i) dosomething(); } } /* Interrupt service routine. */ void ISR_2(void) { i=1; } 程序的本意是ISR_2中断产生时，在main当中调用dosomething函数，但是，由于编译器判断在main函数里面没有修改过i，因此可能只执行一次对从i到某寄存器的读操作，然后每次if判断都只使用这个寄存器里面的“i副本”，导致dosomething永远也不会被调用。如果将变量加上volatile修饰，则编译器保证对此变量的读写操作都不会被优化（肯定执行）。此例中i也应该如此说明。 volatile用在如下的几个地方： 1、中断服务程序中修改的供其它程序检测的变量需要加volatile； 2、多任务环境下各任务间共享的标志应该加volatile； 3、存储器映射的硬件寄存器通常也要加volatile说明，因为每次对它的读写都可能有不同意义； 举例分析： 代码一: int a,b,c; //读取I/O空间0x100端口的内容 a= inword(0x100); b=a; a=inword(0x100) c=a; 代码二: volatile int a; int a,b,c; //读取I/O空间0x100端口的内容 a= inword(0x100); b=a; a=inword(0x100) c=a; 在上述例子中,代码一会被绝大多数编译器优化为如下代码: a=inword(0x100) b=a; c=a;这显然与编写者的目的不相符,会出现I/O空间0x100端口漏读现象,若是增加volatile,像代码二所示的那样,优化器将不会优化掉任何代码 struct与typedef关键字在网络协议、通信控制、嵌入式系统的C/C++编程中，经常要传送的不是简单的字节流（char型数组），而是多种数据组合起来的一个整体，其表现形式是一个结构体 struct关键字的作用是它可以实现对数据的封装,有一点点类似与C++的对象,可以将一些分散的特性对象化,这在编写某些复杂程序时提供很大的方便性.用法:在C中定义一个结构体类型要用typedef: typedef struct Student { int a; }Stu; 声明变量 Stu stu1; 如果没有typedef声明变量 struct Student stu1; 这里的Stu实际上就是struct Student的别名，另外这里也可以不写Student typedef struct { int a; }Stu; 比如编写一个菜单程序,你要知道本级菜单的菜单索引号、焦点在屏上是第几项、显示第一项对应的菜单条目索引、菜单文本内容、子菜单索引、当前菜单执行的功能操作。若是对上述条目单独操作，那么程序的复杂程度将会大到不可想象，这时候结构体struct就开始显现它的威力了： //结构体定义 typedef struct { unsigned char CurrentPanel;//本级菜单的菜单索引号 unsigned char ItemStartDisplay; //显示第一项对应的菜单条目索引 unsigned char FocusLine; //焦点在屏上是第几项 }Menu_Statestruct; typedef struct { unsigned char *MenuTxt; //菜单文本内容 unsigned char MenuChildID;//子菜单索引 void (*CurrentOperate)();//当前菜单执行的功能操作 }MenuItemStruct; typedef struct { MenuItemStruct *MenuPanelItem; unsigned char MenuItemCount; }MenuPanelStruct;]]></content>
    </entry>

    
    <entry>
      <title></title>
      <url>%2F2017%2F06%2F21%2FNotepad%2B%2B%E4%BD%BF%E7%94%A8%E6%95%99%E7%A8%8B%2F</url>
      <content type="text"><![CDATA[title: notepad++使用date: 2017-04-30categories: 软件工具教程tags: [Notepad]comments: false #Notepad++简介#Notepad++是Windows平台上一款强大的文本编辑器，轻量化，可定制性强，加上功能强大的插件，可以胜任绝大部分工作。 常用功能书签功能书签是一种特殊的行标记，显示在编辑器的书签栏处。使用书签，可以很容易转到指定行处，进行一些相关的操作。在任意行点击左边栏或者按Ctrl+F2会出现蓝色小点，点击蓝色小点或按Ctrl+F2可以取消该行书签。F2光标移动到上一个书签，Shift+F2光标移动到下一个书签。 多视图功能可以在 Notepad++ 中打开第二个编辑窗口，这同时查看两个文档了（也可以是同一个文档）。如果它们是同一个文档的话，你就可以快速比较这两个文档，或者同时编辑文档的两个地方，而不需要滚动或通过书签来做到这点。对于同一文件，在文件标签项上右键-复制到另一视图对于不同文件，在文件标签项上右键-移动到另一视图 折叠功能根据文档语言可以隐藏文档中的多行文本，文本块分成多个层次，可以折叠父层的文本块，折叠后只会显示文本块的第一行内容。取消折叠文本块（展开或取消折叠）将会再次显示折叠的文本块。折叠所有层次： Alt+0展开所有层次： Alt+shift+0折叠当前层次： Ctrl+Alt+f展开当前层次： Ctrl+Alt+Shift+f 行定位功能用于快速跳至某一行。Ctrl+g会弹出一个对话框，可以选择输入绝对行号跳转或者相对于当前行做偏移量跳转。 向后回滚和向前回滚向后回滚即撤销： Ctrl+z，向前回滚即回到前一步骤： Ctrl+y。 快匹配功能选择一个括号，按Ctrl+b会跳转到与它对应的另外一半括号处。此处括号包括”(“和”{“。 颜色标记功能给内容用不同的颜色做标记，选择要标记的文本然后点击右键-&gt;Style token，选择一个标记即可。也可以通过点击右键选择删除颜色标记Remove style。 tab键转换成空格在设置-首选项-&gt;语言页面可以选择“以空格代替Tab”，同时可以配置一个Tab键替换成几个空格。可以很方便的按Tab键进行缩进，按Shift+Tab进行反向缩进。 显示符号功能在视图选项卡中能找到显示符号功能，可以显示空格、制表键、换行等 可以方便编辑，尤其可以防止无意中加入好多不需要的空格。 快捷键大全文件菜单快捷键 动作Ctrl-O 打开文件Ctrl-N 新建文件Ctrl-S 保存文件Ctrl-Alt-S 另存为Ctrl-Shift-S 保存所有Ctrl-P 打印Alt-F4 退出Ctrl-Tab 下一个文档 (显示所有打开的文件列表)。可以禁止此快捷键 - 参见 设置/首选项/全局.Ctrl-Shift-Tab 上一个文档 (显示所有打开的文件列表). 可以禁止此快捷键 - 同上.Ctrl-W 关闭当前文档 编辑菜单快捷键 动作Ctrl-C 拷贝Ctrl-Insert 拷贝Ctrl-Shift-T 拷贝当前行Ctrl-X 剪切Shift-Delete 剪切Ctrl-V 粘贴Shift-Insert 粘贴Ctrl-Z 撤销Alt-Backspace 撤销Ctrl-Y 重做Ctrl-A 选择全部Alt-Shift-方向键, 或者 Alt + 鼠标左键 列模式选择Ctrl + 鼠标左键 开始新的选择区域。仅在多块区域有效ALT-C 列编辑Ctrl-D 复制当前行Ctrl-T 当前行和前一行交换Ctrl-Shift-Up 当前行或当前单个选中文本块上移Ctrl-Shift-Down 当前行或当前单个选择文本块下移Ctrl-L 删除当前行Ctrl-I 分割当前行Ctrl-J 连结行Ctrl-G 打开转到对话框Ctrl-Q 行注释/取消行注释Ctrl-Shift-Q 块注释Tab (一行或多行被选中) 插入制表符或空格 (缩进)Shift-Tab (一行或多行被选中) 删除行首制表符或空格(取消缩进)Ctrl-BackSpace 删除到单词开头Ctrl-Delete 删除到单词末尾Ctrl-Shift-BackSpace 删除到行首Ctrl-Shift-Delete 删除到行尾Ctrl-U 转换为小写Ctrl-Shift-U 转换为大写Ctrl-B 转到匹配括号处Ctrl-Space 显示函数参数提示列表Ctrl-Shift-Space 显示函数提示列表Ctrl-Enter 显示单词提示列表Ctrl-Alt-R 文本方向从右到走Ctrl-Alt-L 文本方向从左到右Enter 回车插入新行或分割文本到新行Shift-Enter 插入新行或分割文本到新行 搜索菜单快捷键 操作Ctrl-F 打开查找对话框Ctrl-H 打开 查找 / 替换 对话框F3 查找下一个Shift-F3 查找上一个Ctrl-Shift-F 在文件中查找F7 切换到搜索结果窗口（即版本5.2之前的激活子视图）Ctrl-Alt-F3 查找 (快速) 下一个Ctrl-Alt-Shift-F3 查找 (快速) 上一个Ctrl-F3 选择并查找下一个（即版本5.6.5之前中的查找（快速）下一个）Ctrl-Shift-F3 选择并查找下一个(即版本5.6.5之前的查找 (快速) 上一个)F4 转到下一个结果Shift-F4 转到上一个结果Ctrl-Shift-I 增量搜索Ctrl-n 向下跳转（到下一个样式n标记的文本。 n 从1到5, 对于默认查找样式为0Ctrl-Shift-n 向上跳转 (到上一个样式n标记的文本。n 从1到5，对于默认查找样式为0Ctrl-F2 标记/取消标记书签F2 转到下一个书签Shift-F2 转到上一个书签 视图菜单快捷键 动作Ctrl-(Keypad-/Keypad+) 或者 Ctrl + 鼠标滚轮按钮 (如果你的鼠标有这个键的话) 放大 (+ 或者 向上键) 和 缩小 (- 或者 向下键)Ctrl-Keypad/ 恢复视图到原始大小F11 转到/退出全屏视图F12 转到/退出切换快捷视图Ctrl-Alt-F 折叠当前大纲级别Ctrl-Alt-Shift-F 展开当前大纲级别Alt-0 折叠所有Alt-(1~8) 折叠大纲级别 (1~8)Alt-Shift-0 展开所有Alt-Shift-(1~8) 展开大纲级别 (1~8) 运行菜单快捷键 操作F5 打开运行对话框Alt-F1 获取PHP帮助Alt-F2 Google 搜索Alt-F3 Wikipedia 搜索Alt-F5 打开文件(当前光标处的文件名)Alt-F6 在新的实例中打开文件 (当前光标处的文件名)Ctrl-Alt-Shift-R 在 Chrome 中打开Ctrl-Alt-Shift-X 在 Firefox 中打开Ctrl-Alt-Shift-I 在 IE 中打开Ctrl-Alt-Shift-F 在 Safari 中打开Ctrl-Alt-Shift-O 通过 Outlook 发送 参考文章Notepad++使用教程]]></content>
    </entry>

    
    <entry>
      <title></title>
      <url>%2F2017%2F05%2F09%2FUbuntu%E8%AF%86%E5%88%AB%E9%A9%B1%E5%8A%A8%E9%97%AE%E9%A2%98%2F</url>
      <content type="text"><![CDATA[title: Ubuntu常见问题date: 2017-03-30categories: Ubuntutags: [Ubuntu] 前言在Ubuntu下经常碰到这样那样的问题，将这些问题总结起来方便解决 USB无法识别情况：Host USb device connections disabled 解决：在Windows中的运行下输入services.MSC,进入系统服务列表项，启动USB服务。]]></content>
    </entry>

    
    <entry>
      <title></title>
      <url>%2F2017%2F05%2F09%2Fkeil%E5%85%BC%E5%AE%B9C51%E4%B8%8EARM%2F</url>
      <content type="text"><![CDATA[title: keil4兼容ARM与C51date: 2017-03-30categories: 单片机tags: [keil] 前言设置keil4使其兼容C51与ARM，避免装多个版本keil。环境：keil4 for ARM 方法第一步在keil4的安装文件中找到TOOLS.ini，在[ARM]前面添加C51项 [C51] PATH=&quot;E:\keil\C51\&quot; SN=K1DZP-5IUSH-A01UE VERSION=V9.01 BOOK0=HLP\RELEASE_NOTES.HTM(&quot;Release Notes&quot;,GEN) BOOK1=HLP\GS51.PDF(&quot;uVision2 Getting Started&quot;,GEN) BOOK2=HLP\C51.PDF(&quot;C51 User&apos;s Guide&quot;,GEN) BOOK3=HLP\C51LIB.CHM(&quot;C51 Library Functions&quot;,C) BOOK4=HLP\A51.PDF(&quot;Assembler/Utilities&quot;,GEN) BOOK5=HLP\TR51.CHM(&quot;RTX51 Tiny User&apos;s Guide&quot;,GEN) BOOK6=HLP\DBG51.CHM(&quot;uVision2 Debug Commands&quot;,GEN) BOOK7=HLP\ISD51.CHM(&quot;ISD51 In System Debugger&quot;,GEN) BOOK8=HLP\FlashMon51.CHM(&quot;Flash Monitor&quot;,GEN) BOOK9=MON390\MON390.HTM(&quot;MON390: Dallas Contiguous Mode Monitor&quot;,GEN) TDRV0=BIN\MON51.DLL (&quot;Keil Monitor-51 Driver&quot;) TDRV1=BIN\ISD51.DLL (&quot;Keil ISD51 In-System Debugger&quot;) TDRV2=BIN\MON390.DLL (&quot;MON390: Dallas Contiguous Mode&quot;) TDRV3=BIN\LPC2EMP.DLL (&quot;LPC900 EPM Emulator/Programmer&quot;) TDRV4=BIN\UL2UPSD.DLL (&quot;ST-uPSD ULINK Driver&quot;) RTOS1=RTXTINY.DLL (&quot;RTX-51 Tiny&quot;) RTOS2=RTX51.DLL (&quot;RTX-51 Full&quot;) TOOLS修改后如下图所示： 第二步按照安装ARM时注册一样，注册C51 第三步在keil4安装文件下添加C51编译器，可有从他人装好了的c51下复制过来。这里我采用的是keil2下的c51编译器 资源keil4c51编译器)]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[回顾51单片机之enum用法]]></title>
      <url>%2F2017%2F04%2F21%2F%E5%9B%9E%E9%A1%BE%E5%8D%95%E7%89%87%E6%9C%BA%E4%B9%8Benum%E7%94%A8%E6%B3%95%2F</url>
      <content type="text"><![CDATA[前言在单片机工程中使用enum来替代define，增加代码的可读性 enum简介enum定义enum DAY { MON=1, TUE, WED, THU, FRI, SAT, SUN }; (1) 枚举型是一个集合，集合中的元素(枚举成员)是一些命名的整型常量，元素之间用逗号隔开。(2) DAY是一个标识符，可以看成这个集合的名字，是一个可选项，即是可有可无的项。(3) 第一个枚举成员的默认值为整型的0，后续枚举成员的值在前一个成员上加1。(4) 可以人为设定枚举成员的值，从而自定义某个范围内的整数。(5) 枚举型是预处理指令#define的替代。(6) 类型定义以分号结束。在实际使用中，更倾向于利用Typedef进行定义，定以后Day=enum DAY，方便枚举对象的声明与赋值 typedef enum DAY { MON=1, TUE, WED, THU, FRI, SAT, SUN }Day; enum变量声明与赋值以typedef为例: Day day=MON; 单片机应用实例在单片机工程中的Led.h头文件中，定义以下结构体表面led灯号 /************************************************************ ***结构体名称：Led_Num ***简述：led灯号结构体，表面属于哪个led *************************************************************/ typedef enum LedNum { LED_ALL=0, LED1=1, LED2=2, LED3=3, LED4=4, LED5=5, LED6=6, LED7=7, LED8=8 }Led_Num; /************************************************************ ***结构体名称：Led_Status ***简述：led灯状态，亮或熄灭 *************************************************************/ typedef enum LedStatus { OFF=0, ON=1 }Led_Status; 在Led.c源文件中，Led_ON_OFF()用来点亮或熄灭指定led灯，如下： /************************************************************** // 作者:chamo // 日期:2017-4-20 // 函数名:Led_ON_OFF // 功能:指定led灯亮熄 // 输入参数 // 参数1:led等号LedNum // 参数2:led状态 // 参数3:LedStatus，ON or OFF // 参数4: // 返回值:无 **************************************************************/ void Led_ON_OFF(int LedNum,int LedStatus) { switch(LedNum) { case LED_ALL: if(LedStatus) { GPIO_LED=GPIO_LED&amp;0x00; } else { GPIO_LED=GPIO_LED|0xFF; } break; case LED1: if(LedStatus) { GPIO_LED=GPIO_LED&amp;0xFE; } else { GPIO_LED=GPIO_LED|0x01; } break; case LED2: if(LedStatus) { GPIO_LED=GPIO_LED&amp;0xFD; } else { GPIO_LED=GPIO_LED|0x02; } break; case LED3: if(LedStatus) { GPIO_LED=GPIO_LED&amp;0xFB; } else { GPIO_LED=GPIO_LED|0x04; } break; case LED4: if(LedStatus) { GPIO_LED=GPIO_LED&amp;0xF7; } else { GPIO_LED=GPIO_LED|0x08; } break; case LED5: if(LedStatus) { GPIO_LED=GPIO_LED&amp;0xEF; } else { GPIO_LED=GPIO_LED|0x10; } break; case LED6: if(LedStatus) { GPIO_LED=GPIO_LED&amp;0xDF; } else { GPIO_LED=GPIO_LED|0x20; } break; case LED7: if(LedStatus) { GPIO_LED=GPIO_LED&amp;0xBF; } else { GPIO_LED=GPIO_LED|0x40; } break; case LED8: if(LedStatus) { GPIO_LED=GPIO_LED&amp;0x7F; } else { GPIO_LED=GPIO_LED|0x80; } break; } 在main.c中，调用led接口函数即可实现指定led的亮熄 #include &lt;stdio.h&gt; #include &quot;common.h&quot; #include &quot;Led.h&quot; int main() { Led_Num LedNum=LED1;//1号灯 Led_Status LedStatus=ON;//亮 Initial_Peripheral();//初始化外设 while(1) { Led_ON_OFF(LedNum,LedStatus); } return 0; } 总结enum与define比较enum:缺点：只能为整型值，不仅占用空间，还消耗cpu资源优点：多个相关值一组，程序更容易维护，代码更加清晰，范围内有效，不会和其他定义冲突 define:缺点：没有范围限制，全局有效，容易产生冲突优点：可为多种类型之，如字符串，整型，浮点型 在一般情况下尽量选择enum,增加代码的可读性和维护性。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[回顾51单片机之定时器简介]]></title>
      <url>%2F2017%2F04%2F21%2F%E5%9B%9E%E9%A1%BE%E5%8D%95%E7%89%87%E6%9C%BA%E4%B9%8B%E5%AE%9A%E6%97%B6%E5%99%A8%E7%AE%80%E4%BB%8B%2F</url>
      <content type="text"><![CDATA[时钟周期单片机外接晶振的振荡周期就是时钟周期。80C51单片机外接了一个11.0592M的晶体振荡器，单片机系统的时钟周期是1/11.0592M，周期是频率的倒数。51单片机时钟频率范围是1.MHZ-12MHZ，把一个时钟周期定义为一个节拍（P）,二个节拍定义为一个状态周期（S）。 机器周期单片机执行指令所消耗的最小时间单位。51单片机采用的CISC(复杂指令指令集)，各条指令执行的时间可能不一样，但是它们执行的时间必须是机器周期的整数倍。51系列单片机将一个机器周期划分为6个状态周期，即S1-S6，每个状态周期又由两个节拍组成，P1和P2，而P1=P2=时钟周期。因此，51单片机的机器周期=6个状态周期=12个时钟周期。这也就是经常说的51单片机的的时钟频率是晶振频率的12分频，或者是1/12。 指令周期指令周期执行某一条指令所消耗的时间，它等于机器周期的整数倍。指令不同，所需的机器周期数也不同。简单的单字节指令。在取指令周期中，指令取出到指令寄存器后立即译码执行；复杂的指令如转移指令，乘法指令，则需要两个或以上的机器周期。 定时器C51单片机内部设有两个16位的可编程定时器/计数器，分别由两个8位专用寄存器组成，即：T0由TH0和TL0构成；T1由TH1和TL1构成，其访问地址依次为8AH-8DH。此外，其内部还有一个8位的定时器方式寄存器TMOD和一个8位的定时控制寄存器TCON，TMOD主要是用于选定定时器的工作方式；TCON主要是用于控制定时器的启动停止，此外TCON还可以保存T0、T1的溢出和中断标志。当定时器工作在计数方式时，外部事件通过引脚T0（P3.4）和T1（P3.5）输入。 定时计数原理16位的定时器/计数器实质上就是一个加1计数器,当定时器/计数器为定时工作方式时，计数器的加1信号由振荡器的12分频信号产生，即每过一个机器周期，计数器加1，直至计满溢出为止。显然，定时器的定时时间与系统的振荡频率有关。因一个机器周期等于12个振荡周期，所以计数频率fcount=1/12osc。如果晶振为12MHz，则计数周期为： T=1/（12×106）Hz×1/12=1μs 当定时器/计数器为计数工作方式时，通过引脚T0和T1对外部信号计数，外部脉冲的下降沿将触发计数。计数器在每个机器周期的S5P2期间采样引脚输入电平。若一个机器周期采样值为1，下一个机器周期采样值为0，则计数器加1。此后的机器周期S3P1期间，新的计数值装入计数器。所以检测一个由1至0的跳变需要两个机器周期，故外部事件的最高计数频率为振荡频率的1/24。例如，如果选用12MHz晶振，则最高计数频率为0.5MHz。为了确保某给定电平在变化前至少被采样一次，外部计数脉冲的高电平与低电平保持时间均需在一个机器周期以上。 定时器/计数器方式寄存器TMOD定时器方式控制寄存器TMOD在特殊功能寄存器中，字节地址为89H，无位地址。 C／T：定时器／计数器选择位。C/T＝1，为计数器方式；C／T＝0，为定时器方式。 M1M0：工作方式选择位，定时器／计数器的4种工作方式由M1M0设定。 0 0 工作方式0 13位计数器 0 1 工作方式1 16位计数器 1 0 工作方式2 自动再装入8位计数器 1 1 工作方式3 定时器0：分成两个8位计数器，定时器1：停止计数 定时器/计数器控制寄存器TCON TCON在特殊功能寄存器中，字节地址为88H，位地址(由低位到高位)为88H一8FH TF1：定时器1溢出标志位。当字时器1计满溢出时，由硬件使TF1置“1”，并且申请中断。进入中断服务程序后，由硬件自动清“0”，在查询方式下用软件清“0”。 TR1：定时器1运行控制位。由软件清“0”关闭定时器1。当GATE=1，且INT1为高电平时，TR1置“1”启动定时器1；当GATE=0，TR1置“1”启动定时器1。 TF0：定时器0溢出标志。其功能及操作情况同TF1。 TR0：定时器0运行控制位。其功能及操作情况同TR1。 IE1：外部中断1请求标志。 IT1：外部中断1触发方式选择位。 IE0：外部中断0请求标志。 IT0：外部中断0触发方式选择位。 定时器初始化确定工作方式方式0：13位定时计数方式，最大计数值为2^13=8192,定时8192个机器周期。 方式1：16位定时计数方式，最大计数值为2^16=65536,定时65536个机器周期。此方式可实现最大的定时时间和最大计数次数。是最常用方式之一。 方式2：8位自动重装计数方式，最大计数值为2^8=256,定时256个机器周期。此方式工作时定时或计数到了不用重装初值，精度较高。另外在串口通讯时常用此方式。是最常用方式之一。 方式3：特殊工作方式。将定时器0分成两个8位功能不全的定时计数器，要占用T1部分功能。 定时器初值定时时间=（最大计数值-初值）X 晶振周期 X 12或 定时时间=（最大计数值-初值）X 机器周期 定时器寄存器为16为，分高8位TH0和低8位TL0,以8位为单位进行封装，将TH0装入初值N/256,低8位TL0装入初值N%256。即定时器初值计算公式为：TH0=(最大计数值M-初值N)/256TL0=(最大计数值M-初值N)%256 机器周期=12时钟周期，12MHZ晶振下，机器周期=1us,定时1s=1000000机器周期，初值=最大机器周期-初值机器周期 例如：10MS定时器初值的计算：1.晶振12M12MHz除12为1MHz，也就是说一秒=1000000次机器周期。10ms=10000次 机器周期。65536-10000=55536(d8f0)TH0=0xd8，TL0=0xf0 2.晶振11.0592M11.0592MHz除12为921600Hz，就是一秒921600次机器周期，10ms=9216次机器周期。65536-9216=56320(dc00)TH0=0xdc，TL0=0x00 启动定时器根据需要打开定时器中断，启动定时器。 EA = 1; //打开总中断 ET0 = 1; //定时器0中断 TR0 = 1; //打开定时器0]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[单片机寄存器]]></title>
      <url>%2F2017%2F04%2F12%2F%E5%8D%95%E7%89%87%E6%9C%BA%E5%AF%84%E5%AD%98%E5%99%A8%E6%80%BB%E7%BB%93%2F</url>
      <content type="text"><![CDATA[#前言#51单片机内部有一个CPU用来运算、控制，四个并行I/O口，分别是P0、P1、P2、P3，ROM存放程序，RAM存放中间结果，此外包括定时/计数器，串行I/O口，中断系统，以及一个内部的时钟电路。在单片机中有一些独立的存储单元是用来控制这些器件的，被称之为特殊功能寄存器（SFR）。这样的特殊功能寄存器在51单片机中共有21个并且都是可位寻址的。 #单片机寄存器#21个特殊功能寄存器（52系列是26个）不连续地分布在128个字节的SFR存储空间中，地址空间为80H-FFH，在这片SFR空间中，包含有128个位地址空间，地址也是80H-FFH，但只有83个有效位地址，可对11个特殊功能寄存器的某些位作位寻址操作（其地址能被8整除的都可以位寻址）。列表如下(其中带*号的为52系列所增加的特殊功能寄存器）： ##B寄存器##在做乘、除法时放乘数或除数，不做乘除法时，可以随便使用。 ##ACC累加器##自身带有全零标志Z，若A＝0则Z＝1；若A≠0则z＝0。该标志常用作程序分枝转移的判断条件。 ##PSW程序状态字##里面放了CPU工作时的很多状态，可以了解CPU的当前状态，并作出相应的处理CY进位标志：8051中的运算器是一种8位的运算器，8位运算器只能表示到0-255，如果做加法的话，两数相加可能会超过255，这样最高位就会丢失，造成运算的错误。最高位就进到CY中来。有进、借位，CY＝1；无进、借位，CY＝0 AC辅助进、借位(高半字节与低半字节间的进、借位)： 例：57H+3AH（01010111+00111010） F0用户标志位：由用户（编程人员）决定什么时候用，什么时候不用。 RS1、RS0工作寄存器组选择位：通过修改PSW中的RS1、RS0两位的状态，就能任选一个工作寄存器区。这个特点提高了MCS-51现场保护和现场恢复的速度。对于提高CPU的工作效率和响应中断的速度是很有利的。若在一个实际的应用系统中，不需要四组工作寄存器，那么这个区域中多余单元可以作为一般的数据缓冲器使用。 0V溢出标志位： 运算结果按补码运算理解。有溢出，OV=1；无溢出，OV＝0。 P奇偶校验位：它用来表示运算结果中二进制数位“1”的个数的奇偶性。若为奇数，则P=1，否则为0。运算结果有奇数个1，P＝1；运算结果有偶数个1，P＝0。 例：某运算结果是78H（01111000），显然1的个数为偶数，所以P=0。 ##IP中断优先级控制寄存器##可按位寻址，地址位B8H （IP.7）：保留 （IP.6）：保留PT2（IP.5）：定时2中断优先（8052用）PS （IP.4）：串行口中断优先PT1（IP.3）：定时1中断优先PX1（IP.2）：外中断INT1中断优先PT0（IP.1）：定时器0中断优先PX0（IP.0）：外部中断INT0的中断优先##P0,P1,P2,P3寄存器##四个并行输入/输出口（I/O）的寄存器，对应着管脚的输出。##IE中断充许寄存器##可按位寻址，地址：A8HEA （IE.7）：EA=0时，所有中断禁止（即不产生中断）；EA=1时，各中断的产生由个别的允许位决定 （IE.6）：保留ET2（IE.5）：定时2溢出中断充许（8052用）ES （IE.4）：串行口中断充许（ES=1充许，ES=0禁止）ET1（IE.3）：定时1中断充许EX1（IE.2）：外中断INT1中断充许ET0（IE.1）：定时器0中断充许EX0（IE.0）：外部中断INT0的中断允许 ##TMOD定时器方式控制寄存器##不按位寻址，地址89HGATE ：定时操作开关控制位，当GATE=1时，INT0或INT1引脚为高电平，同时TCON中的TR0或TR1控制位为1时，计时/计数器0或1才开始工作。若GATE=0，则只要将TR0或TR1控制位设为1，计时/计数器0或1就开始工作。C/T ：定时器或计数器功能的选择位。C/T=1为计数器，通过外部引脚T0或T1输入计数脉冲。C/T=0时为定时器，由内部系统时钟提供计时工作脉冲。M1 、M0：T0、T1工作模式选择位 ##TCON定时器控制寄存器##可按位寻址，地址位88HTF1：定时器T1溢出标志，可由程序查询和清零，TF1也是中断请求源，当CPU响应T1中断时由硬件清零。TF0：定时器T0溢出标志，可由程序查询和清零，TF0也是中断请求源，当CPU响应T0中断时由硬件清零。TR1：T1充许计数控制位，为1时充许T1计数。TR0：T0充许计数控制位，为1时充许T0计数。IE1：外部中断1请示源（INT1，P3.3）标志。IE1＝1，外部中断1正在向CPU请求中断，当CPU响应该中断时由硬件清“0”IE1（边沿触发方式）。IT1：外部中断源1触发方式控制位。IT1＝0，外部中断1程控为电平触发方式，当INT1（P3.3）输入低电平时，置位IE1。IE0：外部中断0请示源（INT0，P3.2）标志。IE0＝1，外部中断1正在向CPU请求中断，当CPU响应该中断时由硬件清“0”IE0（边沿触发方式）。IT0：外部中断源0触发方式控制位。IT0＝0，外部中断1程控为电平触发方式，当INT0（P3.2）输入低电平时，置位IE0。 ##SCON—-串行通信控制寄存器##可寻址的专用寄存器，用于串行数据的通信控制，单元地址是98H(1)SM0、SM1：串行口工作方式控制位。 SM0，SM1 工作方式 00 方式0－波特率由振荡器频率所定：振荡器频率/12 01 方式1－波特率由定时器T1或T2的溢出率和SMOD所定：2SMOD ×(T1溢出率)/32 10 方式2－波特率由振荡器频率和SMOD所定：2SMOD ×振荡器频率/64 11 方式3－波特率由定时器T1或T2的溢出率和SMOD所定：2SMOD ×(T1溢出率)/32 (2)SM2：多机通信控制位。&lt; br&gt; 多机通信是工作于方式2和方式3，SM2位主要用于方式2和方式3。接收状态，当串行口工作于方式2或3，以及SM2=1时，只有当接收到第9位数据（RB8）为1时，才把接收到的前8位数据送入SBUF，且置位RI发出中断申请，否则会将接受到的数据放弃。当SM2=0时，就不管第位数据是0还是1，都难得数据送入SBUF，并发出中断申请。工作于方式0时，SM2必须为0。 (3)REN：允许接收位。&lt; br&gt; REN用于控制数据接收的允许和禁止，REN=1时，允许接收，REN=0时，禁止接收。 (4)TB8：发送接收数据位8。&lt; br&gt; 在方式2和方式3中，TB8是要发送的——即第9位数据位。在多机通信中同样亦要传输这一位，并且它代表传输的地址还是数据，TB8=0为数据，TB8=1时为地址。 (5)RB8：接收数据位8。在方式2和方式3中，RB8存放接收到的第9位数据，用以识别接收到的数据特征。 (6)TI：发送中断标志位。可寻址标志位。方式0时，发送完第8位数据后，由硬件置位，其它方式下，在发送或停止位之前由硬件置位，因此，TI=1表示帧发送结束，TI可由软件清“0”。 (7)RI：接收中断标志位。可寻址标志位。接收完第8位数据后，该位由硬件置位，在其他工作方式下，该位由硬件置位，RI=1表示帧接收完成。 ##PCON电源管理寄存器##PCON主要是为CHMOS型单片机的电源控制而设置的专用寄存器，单元地址是87H在CHMOS型单片机中，除SMOD位外，其他位均为虚设的，SMOD是串行口波特率倍增位，当SMOD=1时，串行口波特率加倍。系统复位默认为SMOD=0。 #文章来源#单片机寄存器]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[github创建本地仓库]]></title>
      <url>%2F2017%2F04%2F12%2Fgithub%E5%88%9B%E5%BB%BA%E6%9C%AC%E5%9C%B0%E4%BB%93%E5%BA%93%2F</url>
      <content type="text"><![CDATA[创建远程仓库在github上创建新仓库new repository,取名为Demo。勾选Initialize this repository with a README，可以省略本地创建README的步骤。 创建本地仓库新建文件夹后右键选择git bash here,进入git控制台 配置git创建ssh keyssh-keygen -t rsa -C &quot;your_email@youremail.com&quot; 之后会要求确认路径和输入密码，我们这使用默认的一路回车就行。成功的话会在c/Users/Administator下生成.ssh文件夹，打开id_rsa.pub，复制里面的key。回到github，进入Account Settings，左边选择SSH Keys，Add SSH Key,title随便填，粘贴key 验证ssh keyssh -T git@github.com 如出现You’ve successfully authenticated, but GitHub does not provide shell access ，则就表示已成功连上github。 关联本地仓库与远程仓库git config --global user.name &quot;your name&quot; git config --global user.email &quot;your_email@youremail.com&quot; git remote add origin https://github.com/yourName/yourRepo.git 后面的yourName和yourRepo表示你再github的用户名和刚才新建的仓库，加完之后进入.git，打开config，这里会多出一个remote “origin”内容，这就是刚才添加的远程地址，也可以直接修改config来配置远程地址。如果执行git remote add origin https://github.com/findingsea/myRepoForBlog.git，出现错误：fatal: remote origin already exists则执行以下语句： git remote rm origin 添加文件git add text.txt //添加指定文件 git add . //添加所有文件 提交文件git commit -m &quot;first add&quot; //提交，后面为当前提交说明 上传文件git push origin master //本地仓库推送到远程服务器。 在执行git push origin master时，报错：error:failed to push som refs to……. git pull origin master]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[linux命令学习之磁盘命令-du命令]]></title>
      <url>%2F2017%2F03%2F30%2Flinux%E5%91%BD%E4%BB%A4%E5%AD%A6%E4%B9%A0-%E7%A3%81%E7%9B%98%E5%91%BD%E4%BB%A4%E4%B9%8Bdu%E5%91%BD%E4%BB%A4%2F</url>
      <content type="text"><![CDATA[du简介 du命令也是查看使用空间的，但是与df命令不同的是du命令是对文件和目录磁盘使用的空间的查看。 命令学习 命令格式：du [选项][文件] 命令功能：显示每个文件和目录的磁盘使用空间。 命令参数：-a或-all 显示目录中个别文件的大小。-b或-bytes 显示目录或文件大小时，以byte为单位。-c或–total 除了显示个别目录或文件的大小外，同时也显示所有目录或文件的总和。-k或–kilobytes 以KB(1024bytes)为单位输出。-m或–megabytes 以MB为单位输出。-s或–summarize 仅显示总计，只列出最后加总的值。-h或–human-readable 以K，M，G为单位，提高信息的可读性。-x或–one-file-xystem 以一开始处理时的文件系统为准，若遇上其它不同的文件系统目录则略过。-L&lt;符号链接&gt;或–dereference&lt;符号链接&gt; 显示选项中所指定符号链接的源文件大小。-S或–separate-dirs 显示个别目录的大小时，并不含其子目录的大小。-X&lt;文件&gt;或–exclude-from=&lt;文件&gt; 在&lt;文件&gt;指定目录或文件。–exclude=&lt;目录或文件&gt; 略过指定的目录或文件。–max-depth=&lt;目录层数&gt; 超过指定层数的目录后，予以忽略。-D或–dereference-args 显示指定符号链接的源文件大小。-H或–si 与-h参数相同，但是K，M，G是以1000为换算单位。 -l或–count-links 重复计算硬件链接的文件。 常用范例 例1：显示目录或者文件所占空间du只显示当前目录下面的子目录的目录大小和当前目录的总的大小，最下面的当前目录的总大小 例2：显示指定文件所占空间du 1.log 例3：查看指定目录的所占空间du test1 例4：显示多个文件所占空间du 1.log 2.log 例5：只显示总和的大小 例6：方便阅读的格式显示 例7：文件和目录都显示du -h test1 例8：显示几个文件或目录各自占用磁盘空间的大小，还统计它们的总和du -c 1.log 2.log 例9：按照空间大小排序 du|sort -nr|more 例10：输出当前目录下各个子目录所使用的空间 du -h –max-depth=1表示深入的目录层数，为0则不深入子目录，1则进入第一层子目录]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[linux命令学习之文件目录命令-chmod命令]]></title>
      <url>%2F2017%2F03%2F30%2Flinux%E5%91%BD%E4%BB%A4%E5%AD%A6%E4%B9%A0-%E6%96%87%E4%BB%B6%E6%9D%83%E9%99%90%E4%B9%8Bchmod%E5%91%BD%E4%BB%A4%2F</url>
      <content type="text"><![CDATA[chmod简介chmod命令用于改变linux系统文件或目录的访问权限。用它控制文件或目录的访问权限。该命令有两种用法。一种是包含字母和操作符表达式的文字设定法；另一种是包含数字的数字设定法。Linux系统中的每个文件和目录都有访问许可权限，用它来确定谁可以通过何种方式对文件和目录进行访问和操作。 文件或目录的访问权限分为只读，只写和可执行三种。以文件为例，只读权限表示只允许读其内容，而禁止对其做任何的更改操作。可执行权限表示允许将该文件作为一个程序执行。文件被创建时，文件所有者自动拥有对该文件的读、写和可执行权限，以便于对文件的阅读和修改。用户也可根据需要把访问权限设置为需要的任何组合。 有三种不同类型的用户可对文件或目录进行访问：文件所有者，同组用户、其他用户。所有者一般是文件的创建者。所有者可以允许同组用户有权访问文件，还可以将文件的访问权限赋予系统中的其他用户。在这种情况下，系统中每一位用户都能访问该用户拥有的文件或目录。 每一文件或目录的访问权限都有三组，每组用三位表示，分别为文件属主的读、写和执行权限；与属主同组的用户的读、写和执行权限；系统中其他用户的读、写和执行权限。当用ls -l命令显示文件或目录的详细信息时，最左边的一列为文件的访问权限列表的列定义如下：[权限属性信息] [连接数] [拥有者] [拥有者所属用户组] [大小] [最后修改时间] [文件名] 权限属性列表为10个字符：第一个字符表示文件类型，d为目录 -为普通文件 l为连接 b为可存储的接口设备 c为键盘鼠标等输入设备2、3、4个字符表示所有者权限，5、6、7个字符表示所有者同组用户权限，8、9、10为其他用户权限第二个字符表示所有者读权限，如果有权限则为r，没有权限则为-第三个字符表示所有者写权限，如果有权限则为w，没有权限则为-第四个字符表示所有者执行权限，如果有权限则为x，没有权限则为-第五个字符表示所有者同组用户读权限，如果有权限则为r，没有权限则为-第六个字符表示所有者同组用户写权限，如果有权限则为w，没有权限则为-第七个字符表示所有者同组用户执行权限，如果有权限则为x，没有权限则为-第八个字符表示其他非同组读权限，如果有权限则为r，没有权限则为-第九个字符表示其他非同组写权限，如果有权限则为w，没有权限则为-第十个字符表示其他非同组执行权限，如果有权限则为x，没有权限则为- 命令学习命令格式:chmod [-cfvR] [–help] [–version] mode file命令功能：用于改变文件或目录的访问权限，用它控制文件或目录的访问权限。命令参数：必要参数：-c 当发生改变时，报告处理信息-f 错误信息不输出-R 处理指定目录以及其子目录下的所有文件-v 运行时显示详细处理信息 选择参数：–reference=&lt;目录或者文件&gt; 设置成具有指定目录或者文件具有相同的权限–version 显示版本信息 &lt;权限范围&gt;+&lt;权限设置&gt; 使权限范围内的目录或者文件具有指定的权限&lt;权限范围&gt;-&lt;权限设置&gt; 删除权限范围的目录或者文件的指定权限 &lt;权限范围&gt;=&lt;权限设置&gt; 设置权限范围内的目录或者文件的权限为指定的值 权限范围：u ：目录或者文件的当前的用户g ：目录或者文件的当前的群组o ：除了目录或者文件的当前用户或群组之外的用户或者群组a ：所有的用户及群组 权限设置：r ：读权限，用数字4表示w ：写权限，用数字2表示x ：执行权限，用数字1表示- ：删除权限，用数字0表示s ：特殊权限 Linux 文件的基本属性有9个，分别是 owner/group/others组别的read/write/excute属性。该命令有两种用法。一种是包含字母和操作符表达式的文字设定法；另一种是包含数字的数字设定法。1）文字设定法:如果想把一个文件属性设置为 -rwxr-xr–，可以这样： chmod u=rwx,g=rx,o=r filename如果不知道文件的原先属性，但想增加其的每人均可写入的权限，可以这样：chmod a+w filename去掉所有人的x属性：chmod a-x filename2）数字设定法 数字表示：r:4 w:2 x:1例子：将同一组(owner/group/others)的3个属性(r/w/x)累加，如当前属性为[-rwxrwx—]，则是：owner=rwx=4+2+1=7group=rwx=4+2+1=7others= — =0+0+0=0该属性为770.chmod 777 filename 常用范例例1：增加文件所有用户组可执行权限chmod a+x 1.loga ：所有的用户及群组即：文件属主（u） 增加执行权限；与文件属主同组用户（g） 增加执行权限；其他用户（o） 增加执行权限 例2：同时修改不同用户权限chmod ug+r,o-w 2.log文件属主（u） 增加读权限;与文件属主同组用户（g） 增加读权限;其他用户（o） 删除写权限 例3：删除文件权限chmod a-r 2.log删除所有用户的读权限 例4：使用“=”设置权限chmod u=rwx,g=rwx,o=rwz 2.log撤销原来所有的权限，然后使其具有新的权限 例5：对一个目录及其子目录所有文件添加权限chmod -R u+x test1]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[linux命令学习之文件查找命令-whereis命令]]></title>
      <url>%2F2017%2F03%2F30%2Flinux%E5%91%BD%E4%BB%A4%E5%AD%A6%E4%B9%A0-%E6%96%87%E4%BB%B6%E6%9F%A5%E6%89%BE%E4%B9%8Bwhereis%E5%91%BD%E4%BB%A4%2F</url>
      <content type="text"><![CDATA[whereis简介whereis命令只能用于程序名的搜索，而且只搜索二进制文件（参数-b）、说明文件（参数-m）和源代码文件（参数-s）。如果省略参数，则返回所有信息。和find相比，whereis查找的速度非常快，这是因为linux系统会将 系统内的所有文件都记录在一个数据库文件中，当使用whereis和locate时，会从数据库中查找数据，而不是像find命令那样，通过遍历硬盘来查找，效率自然会很高。但是该数据库文件并不是实时更新，默认情况下时一星期更新一次，因此，我们在用whereis和locate 查找文件时，有时会找到已经被删除的数据，或者刚刚建立文件，却无法查找到，原因就是因为数据库文件没有被更新。 命令学习命令格式：whereis [-bmsu] [BMS 目录名 -f ] 文件名命令功能：whereis命令是定位可执行文件、源代码文件、帮助文件在文件系统中的位置。这些文件的属性应属于原始代码，二进制文件，或是帮助文件。whereis 程序还具有搜索源代码、指定备用搜索路径和搜索不寻常项的能力。命令参数：-b 定位可执行文件。-m 定位帮助文件。-s 定位源代码文件。-u 搜索默认路径下除可执行文件、源代码文件、帮助文件以外的其它文件-B 指定搜索可执行文件的路径。-M 指定搜索帮助文件的路径。-S 指定搜索源代码文件的路径。 常用范例例1:指令”whereis”查看指令”bash”的位置]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[linux命令学习之文件查找命令-which命令]]></title>
      <url>%2F2017%2F03%2F30%2Flinux%E5%91%BD%E4%BB%A4%E5%AD%A6%E4%B9%A0-%E6%96%87%E4%BB%B6%E6%9F%A5%E6%89%BE%E4%B9%8Bwhich%E5%91%BD%E4%BB%A4%2F</url>
      <content type="text"><![CDATA[which简介经常在linux要查找某个文件，但不知道放在哪里了，可以使用下面的一些命令来搜索： which 查看可执行文件的位置。 whereis 查看文件的位置。 locate 配合数据库查看文件位置。 find 实际搜寻硬盘查询文件名称。which命令在PATH变量指定的路径中，搜索某个系统命令的位置，并且返回第一个搜索结果。也就是说，使用which命令，就可以看到某个系统命令是否存在，以及执行的到底是哪一个位置的命令。 命令学习命令格式：which 可执行文件名称命令功能：which指令会在PATH变量指定的路径中，搜索某个系统命令的位置，并且返回第一个搜索结果。命令参数：-n 指定文件名长度，指定的长度必须大于或等于所有文件中最长的文件名。-p 与-n参数相同，但此处的包括了文件的路径。-w 指定输出时栏位的宽度。-V 显示版本信息 常用范例例1：查找文件、显示命令路径cd 是bash 内建的命令，但是 which 默认是找 PATH 内所规范的目录，所以找不到 查找有别名的命令时会列出具体的别名信息]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[linux命令学习之文件目录命令-cd命令]]></title>
      <url>%2F2017%2F03%2F30%2Flinux%E5%91%BD%E4%BB%A4%E5%AD%A6%E4%B9%A0-%E6%96%87%E4%BB%B6%E7%9B%AE%E5%BD%95%E4%B9%8Bcd%E5%91%BD%E4%BB%A4%2F</url>
      <content type="text"><![CDATA[cd 命令学习命令格式：cd [dirname] 命令功能：切换当前目录至dirName 常用范例例一：进入系统根目录cd / 例一：进入用户主目录cd 或 cd ~ 例三：返回上层目录cd ..cd ../.. （返回上两级目录） 例四：返回进入此目录之前所在的目录cd - 例五：把上个命令的参数作为cd参数使用cd !$（相当于仍然执行上次操作，如果上次cd -,这次也cd -）]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[linux命令学习之文件目录命令-cp命令]]></title>
      <url>%2F2017%2F03%2F30%2Flinux%E5%91%BD%E4%BB%A4%E5%AD%A6%E4%B9%A0-%E6%96%87%E4%BB%B6%E7%9B%AE%E5%BD%95%E4%B9%8Bcp%E5%91%BD%E4%BB%A4%2F</url>
      <content type="text"><![CDATA[cp简介cp命令用来复制文件或者目录，一般情况下，shell会设置一个别名，在命令行下复制文件时，如果目标文件已经存在，就会询问是否覆盖，不管你是否使用-i参数。但是如果是在shell脚本中执行cp时，没有-i参数时不会询问是否覆盖。这说明命令行和shell脚本的执行方式有些不同。 命令学习命令格式：cp [选项] [-T] 源 目的或：cp [选项] 源 目录cp [选项]… -t 目录 源命令功能：将源文件复制至目标文件，或将多个源文件复制至目标目录。命令参数：-a, 为每个已存在的目标文件创建备份-b，类似–backup 但不接受参数，在递归处理是复制特殊文件内容-f, 如果目标文件无法打开则将其移除并重试(当-n选项存在时则不需再选此项)-i, 覆盖前询问(使前面的 -n 选项失效)-H，跟随源文件中的命令行符号链接-l, 链接文件而不复制-L, 总是跟随符号链接-n, 不要覆盖已存在的文件(使前面的 -i 选项失效)-P, 跟随源文件中的符号链接-p，等于–preserve=模式,所有权,时间戳，保持指定的属性(默认：模式,所有权,时间 戳)，如果可能保持附加属性：环境、链接、xattr 等-R, -r, 复制目录及目录内的所有项目 常用范例例一：复制单个文件到目标目录，文件在目标文件中不存在cp l.log test 例二：目标文件存在时，会询问是否覆盖cp 1.log test 例三：复制整个目录目标目录存在时： 整个源目录被复制到目标目录里面cp -a test3 test5目标目录不存在： 类似改名cp -a test3 test4 例四：复制的 log.log 建立一个连结档 log_link.logcp -s log.log log_link.log]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[linux命令学习之文件目录命令-find命令]]></title>
      <url>%2F2017%2F03%2F30%2Flinux%E5%91%BD%E4%BB%A4%E5%AD%A6%E4%B9%A0-%E6%96%87%E4%BB%B6%E7%9B%AE%E5%BD%95%E4%B9%8Bfind%E5%91%BD%E4%BB%A4%2F</url>
      <content type="text"><![CDATA[find简介Linux下find命令在目录结构中搜索文件，并执行指定的操作。find命令提供了相当多的查找条件，功能很强大。即使系统中含有网络文件系统( NFS)，find命令在该文件系统中同样有效，只你具有相应的权限。 在运行一个非常消耗资源的find命令时，很多人都倾向于把它放在后台执行，因为遍历一个大的文件系统可能会花费很长的时间(这里是指30G字节以上的文件系统)。 命令学习命令格式：find pathname -options [-print -exec -ok …] 命令功能：用于在文件树种查找文件，并作出相应的处理 命令参数：pathname: find命令所查找的目录路径。例如用.来表示当前目录，用/来表示系统根目录。-print： find命令将匹配的文件输出到标准输出。-exec： find命令对匹配的文件执行该参数所给出的shell命令。相应命令的形式为’command’ { } \;，注意{ }和\；之间的空格。-ok： 和-exec的作用相同，只不过以一种更为安全的模式来执行该参数所给出的shell命令，在执行每一个命令之前，都会给出提示，让用户来确定是否执行。 命令选项：-name 按照文件名查找文件。-perm 按照文件权限来查找文件。-prune 使用这一选项可以使find命令不在当前指定的目录中查找，如果同时使用-depth选项，那么-prune将被find命令忽略。-user 按照文件属主来查找文件。-group 按照文件所属的组来查找文件。-mtime -n +n 按照文件的更改时间来查找文件， - n表示文件更改时间距现在n天以内，+ n表示文件更改时间距现在n天以前。find命令还有-atime和-ctime 选项，但它们都和-m time选项。-nogroup 查找无有效所属组的文件，即该文件所属的组在/etc/groups中不存在。-nouser 查找无有效属主的文件，即该文件的属主在/etc/passwd中不存在。-newer file1 ! file2 查找更改时间比文件file1新但比文件file2旧的文件。-type 查找某一类型的文件，诸如：b - 块设备文件。d - 目录。c - 字符设备文件。p - 管道文件。l - 符号链接文件。f - 普通文件。-size n：[c] 查找文件长度为n块的文件，带有c时表示文件长度以字节计。-depth：在查找文件时，首先查找当前目录中的文件，然后再在其子目录中查找。-fstype：查找位于某一类型文件系统中的文件，这些文件系统类型通常可以在配置文件/etc/fstab中找到，该配置文件中包含了本系统中有关文件系统的信息。-mount：在查找文件时不跨越文件系统mount点。-follow：如果find命令遇到符号链接文件，就跟踪至链接所指向的文件。-cpio：对匹配的文件使用cpio命令，将这些文件备份到磁带设备中。另外,下面三个的区别:-amin n 查找系统中最后N分钟访问的文件-atime n 查找系统中最后n24小时访问的文件-cmin n 查找系统中最后N分钟被改变文件状态的文件-ctime n 查找系统中最后n24小时被改变文件状态的文件-mmin n 查找系统中最后N分钟被改变文件数据的文件-mtime n 查找系统中最后n*24小时被改变文件数据的文件 常用范例例1：查找指定时间内修改过的文件find -atime -2查找48小时内修改过的文件 例2：根据关键字查找find . -name “*.log”当前目录查找 以.log结尾的文件。 “. “代表当前目录 例3：按照目录或文件的权限来查找文件find ~/Test/ -perm 777 例4：按类型查找find . -type f -name “*.log”查找当前目录，以.log结尾的普通文件 例5：查找当前所有目录并排序find . -type d | sort 例6：按大小查找文件find . -size +1000c -print查找当前目录大于1K的文件]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[linux命令学习之文件目录命令-head命令]]></title>
      <url>%2F2017%2F03%2F30%2Flinux%E5%91%BD%E4%BB%A4%E5%AD%A6%E4%B9%A0-%E6%96%87%E4%BB%B6%E7%9B%AE%E5%BD%95%E4%B9%8Bhead%E5%91%BD%E4%BB%A4%2F</url>
      <content type="text"><![CDATA[head简介head是用来显示开头某个数量的文字区块，显示档案的开头至标准输出中，与tai是查看档案的结尾 命令学习命令格式：head [参数] [文件]命令功能：显示档案的开头至标准输出中，默认head命令打印其相应文件的开头10行。命令参数：-q 隐藏文件名-v 显示文件名-c&lt;字节&gt; 显示字节数-n&lt;行数&gt; 显示的行数 常用范例例1：显示文件的前n行head -n 5 1.log 例2：显示文件前n个字节head -c 20 1.log 例3：文件的除了最后n个字节以外的内容head -c -32 1.log 例4：输出文件除了最后n行的全部内容head -n -6 log2014.log]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[linux命令学习之文件目录命令-less命令]]></title>
      <url>%2F2017%2F03%2F30%2Flinux%E5%91%BD%E4%BB%A4%E5%AD%A6%E4%B9%A0-%E6%96%87%E4%BB%B6%E7%9B%AE%E5%BD%95%E4%B9%8Bless%E5%91%BD%E4%BB%A4%2F</url>
      <content type="text"><![CDATA[less简介less工具也是对文件或其它输出进行分页显示的工具，功能极其强大。less 的用法比起 more 更加的有弹性。在more的时候，没有办法向前面翻，只能往后面看，但若使用了 less 时，就可以使用 [pageup] [pagedown] 等按键的功能来往前往后翻看文件，更容易用来查看一个文件的内容！除此之外，在 less 里头可以拥有更多的搜索功能，不止可以向下搜，也可以向上搜。 命令简介命令格式：less [参数] 文件命令功能：less 与 more 类似，但使用 less 可以随意浏览文件，而 more 仅能向前移动，却不能向后移动，less在查看之前不会加载整个文件命令参数：-b &lt;缓冲区大小&gt; 设置缓冲区的大小-e 当文件显示结束后，自动离开-f 强迫打开特殊文件，例如外围设备代号、目录和二进制文件-g 只标志最后搜索的关键词-i 忽略搜索时的大小写-m 显示类似more命令的百分比-N 显示每行的行号-o &lt;文件名&gt; 将less 输出的内容在指定文件中保存起来-Q 不使用警告音-s 显示连续空行为一行-S 行过长时间将超出部分舍弃-x &lt;数字&gt; 将“tab”键显示为规定的数字空格/字符串：向下搜索“字符串”的功能?字符串：向上搜索“字符串”的功能n：重复前一个搜索（与 / 或 ? 有关）N：反向重复前一个搜索（与 / 或 ? 有关）b 向后翻一页d 向后翻半页h 显示帮助界面Q 退出less 命令u 向前滚动半页y 向前滚动一行空格键 滚动一行回车键 滚动一页[pagedown]： 向下翻动一页[pageup]： 向上翻动一页 常用范例例1：查看文件less 1.log 例2：ps查看进程信息并通过less分页显示ps -ef |less 例3：查看命令历史使用记录并通过less分页显示history | less 例4：浏览多个文件Less 1.log 2.log输入 ：n后，切换到 2.log输入 ：p后, 切换到 1.log 附加备注全屏导航ctrl + F - 向前移动一屏ctrl + B - 向后移动一屏ctrl + D - 向前移动半屏ctrl + U - 向后移动半屏 单行导航j - 向前移动一行k - 向后移动一行 其它导航G - 移动到最后一行g - 移动到第一行q / ZZ - 退出 less 命令 其它有用的命令v - 使用配置的编辑器编辑当前文件h - 显示 less 的帮助文档&amp;pattern - 仅显示匹配模式的行，而不是整个文件 标记导航当使用 less 查看大文件时，可以在任何一个位置作标记，可以通过命令导航到标有特定标记的文本位置：ma - 使用 a 标记文本的当前位置‘a - 导航到标记 a 处]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[linux命令学习之文件目录命令-ls命令]]></title>
      <url>%2F2017%2F03%2F30%2Flinux%E5%91%BD%E4%BB%A4%E5%AD%A6%E4%B9%A0-%E6%96%87%E4%BB%B6%E7%9B%AE%E5%BD%95%E4%B9%8Bls%E5%91%BD%E4%BB%A4%2F</url>
      <content type="text"><![CDATA[ls简介&nbsp;ls用来打印出当前目录的清单，如果ls指定目录那么就会显示指定目录里的文件及文件夹清单。 通过ls 命令不仅可以查看linux文件夹包含的文件，而且可以查看文件权限(包括目录、文件夹、文件权限)，目录信息等等。 命令学习命令格式：ls [选项] [目录名]命令功能：列出目标目录中所有的子目录和文件常用参数：-a 列出目录下的所有文件，包括以 . 开头的隐含文件-b 把文件名中不可输出的字符用反斜杠加字符编号的形式列出。-c 输出文件的 i 节点的修改时间，并以此排序。-d 将目录象文件一样显示，而不是显示其下的文件。-e 输出时间的全部信息，而不是输出简略信息。-i 输出文件的 i 节点的索引信息。-k 以 k 字节的形式表示文件的大小。-l 列出文件的详细信息。-m 横向输出文件名，并以“，”作分格符。-n 用数字的 UID,GID 代替名称。-o 显示文件的除组信息外的详细信息。-p -F 在每个文件名后附上一个字符以说明该文件的类型，“”表示可执行的普通文件；“/”表示目录；“@”表示符号链接；“|”表示FIFOs；“=”表示套接字(sockets)-q 用?代替不可输出的字符。-r 对目录反向排序。-s 在每个文件名后输出该文件的大小。-t 以时间排序。-u 以文件上次被访问的时间排序。-x 按列输出，横向排序。-A 显示除 “.”和“..”外的所有文件。-B 不输出以 “~”结尾的备份文件。-C 按列输出，纵向排序。-G 输出文件的组的信息。-L 列出链接文件名而不是链接到的文件。-N 不限制文件长度。-Q 把输出的文件名用双引号括起来。-R 列出所有子目录下的文件。*-S 以文件大小排序。-X 以文件的扩展名(最后一个 . 后的字符)排序。-1 一行只输出一个文件。–color=no 不显示彩色文件名–help 在标准输出上显示帮助信息。–version 在标准输出上输出版本信息并退出。 常用范例例一：列出/home/文件夹下的所有文件和目录的详细资料ls -l -R /home/Testls -lR /home/peidachang(参数可以一起) 例二：列出当前目录中所有以“t”开头的目录的详细内容ls -l t* 例三：只列出文件下的子目录ls -F /opt/soft |grep /$ 列出 /opt/soft 文件下面的子目录ls -l /opt/soft | grep “^d” 列出 /opt/soft 文件下面的子目录详细情况例四：列出目前工作目录下所有名称是s 开头的档案，愈新的排愈后面命令：ls -ltr s例五：计算当前目录下的文件数和目录数ls -l |grep “^-“|wc -l —文件个数ls -l * |grep “^d”|wc -l —目录个数例七: 在ls中列出文件的绝对路径ls | sed “s:^:pwd/:”例九：列出当前目录下的所有文件（包括隐藏文件）的绝对路径， 对目录不做递归命令：find $PWD -maxdepth 1 | xargs ls -ld例十：递归列出当前目录下的所有文件（包括隐藏文件）的绝对路径find $PWD | xargs ls -ld例十一：指定文件时间输出格式ls -tl –time-style=full-iso扩展： 显示彩色目录列表 打开/etc/bashrc, 加入如下一行: alias ls=”ls –color”下次启动bash时就可以像在Slackware里那样显示彩色的目录列表了, 其中颜色的含义如下: 蓝色–&gt;目录 绿色–&gt;可执行文件 红色–&gt;压缩文件 浅蓝色–&gt;链接文件 灰色–&gt;其他文件]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[linux命令学习之文件目录命令-cat命令]]></title>
      <url>%2F2017%2F03%2F30%2Flinux%E5%91%BD%E4%BB%A4%E5%AD%A6%E4%B9%A0-%E6%96%87%E4%BB%B6%E7%9B%AE%E5%BD%95%E4%B9%8Bcat%E5%91%BD%E4%BB%A4%2F</url>
      <content type="text"><![CDATA[cat简介cat命令的用途是连接文件或标准输入并打印。常用来显示文件内容，或者将几个文件连接起来显示，或者从标准输入读取内容并显示，它常与重定向符号配合使用。 命令学习命令格式：cat [选项] [文件]命令功能：1.一次显示整个文件:cat filename2.从键盘创建一个文件:cat &gt; filename 只能创建新文件,不能编辑已有文件.3.将几个文件合并为一个文件:cat file1 file2 &gt; file命令参数：-b, –number-nonblank 对非空输出行编号-E, –show-ends 在每行结束处显示 $-n, –number 对输出的所有行编号,由1开始对所有输出的行数编号-s, –squeeze-blank 有连续两行以上的空白行，就代换为一行的空白行-T, –show-tabs 将跳格字符显示为 ^I-v, –show-nonprinting 显示非打印字符 常用范例例一：把 1.log 的文件内容加上行号后附加到2.log 文件里cat -n 1.log 2.log 例二：把1.log 的文件内容加上行号后覆盖2.log 文件（2.log存在）cat -n 1.log &gt; 2.log 2.log不存在时会先创建2.log这里&gt;与》的区别：》是追加，不会覆盖 例三：使用标准输入来创建文件 cat &gt;log.txt &lt;&lt;EOFtac (反向列示)tac log.txt]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[linux命令学习之文件目录命令-mkdir命令]]></title>
      <url>%2F2017%2F03%2F30%2Flinux%E5%91%BD%E4%BB%A4%E5%AD%A6%E4%B9%A0-%E6%96%87%E4%BB%B6%E7%9B%AE%E5%BD%95%E4%B9%8Bmkdir%E5%91%BD%E4%BB%A4%2F</url>
      <content type="text"><![CDATA[mkdir简介mkdir命令用来创建指定的名称的目录，要求创建目录的用户在当前目录中具有写权限，并且指定的目录名不能是当前目录中已有的目录。 mkdi学习命令格式：mkdir [选项] 目录…命令功能：mkdir 命令可以实现在指定位置创建以 DirName(指定的文件名)命名的文件夹或目录。要创建文件夹或目录的用户必须对所创建的文件夹的父文件夹具有写权限。并且，所创建的文件夹(目录)不能与其父目录(即父文件夹)中的文件名重名，即同一个目录下不能有同名的(区分大小写)。命令参数：-m,设定权限&lt;模式&gt; (类似 chmod)-p,可以是一个路径名称。此时若路径中的某些目录尚不存在,加上此选项 后,系统将自动建立好那些尚不存在的目录,即一次可以建立多个目录-v, –verbose 每次创建新目录都显示信息–help 显示此帮助信息并退出–version 输出版本信息并退出 常用范例例1：创建一个空目录mkdir test1 例2:递归创建多个目录mkdir -p test2/test22创建test2目录，且在test2目录下创建子目录test22 例3：创建权限为777的目录mkdir -m 777 test3 例4：创建新目录都显示信息mkdir -v test4 例五：一个命令创建项目的目录结构mkdir -vp test2/{test22/,test23/,test24/{test31,test32},test25/test33/{test34,test35}}]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[linux命令学习之文件目录命令-more命令]]></title>
      <url>%2F2017%2F03%2F30%2Flinux%E5%91%BD%E4%BB%A4%E5%AD%A6%E4%B9%A0-%E6%96%87%E4%BB%B6%E7%9B%AE%E5%BD%95%E4%B9%8Bmore%E5%91%BD%E4%BB%A4%2F</url>
      <content type="text"><![CDATA[more简介more命令，功能类似 cat ，cat命令是整个文件的内容从上到下显示在屏幕上。 more会以一页一页的显示方便使用者逐页阅读，而最基本的指令就是按空白键（space）就往下一页显示，按 b 键就会往回（back）一页显示，而且还有搜寻字串的功能 。more命令从前向后读取文件，因此在启动时就加载整个文件。 命令学习命令格式：more [-dlfpcsu ] [-num ] [+/ pattern] [+ linenum] [file … ]命令功能： more命令和cat的功能一样都是查看文件里的内容，但有所不同的是more可以按页来查看文件的内容，还支持直接跳转行等功能。命令参数：+n 从笫n行开始显示-n 定义屏幕大小为n行+/pattern 在每个档案显示前搜寻该字串（pattern），然后从该字串前两行之后开始显示-c 从顶部清屏，然后显示-d 提示“Press space to continue，’q’ to quit（按空格键继续，按q键退出）”，禁用响铃功能-l 忽略Ctrl+l（换页）字符-p 通过清除窗口而不是滚屏来对文件进行换页，与-c选项相似-s 把连续的多个空行显示为一行-u 把文件内容中的下画线去掉 操作命令Enter 向下n行，需要定义。默认为1行Ctrl+F 向下滚动一屏空格键 向下滚动一屏Ctrl+B 返回上一屏= 输出当前行的行号：f 输出文件名和当前行的行号 V 调用vi编辑器!命令 调用Shell，并执行命令q 退出more 常用范例例1：显示文件中从第3行起的内容more +3 1.log 例2：从文件中查找第一个出现”b”字符串的行，并从该处前两行开始显示输出more +/b 1.log 例3：设定每屏显示行数more -5 1.log 例4：列一个目录下的文件，由于内容太多，会用more来分页显示(和管道 | 结合起来 )ls -l | more -3每页显示3个文件信息，按 Ctrl+F 或者 空格键 将会显示下3条文件信息]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[linux命令学习之文件目录命令-mv命令]]></title>
      <url>%2F2017%2F03%2F30%2Flinux%E5%91%BD%E4%BB%A4%E5%AD%A6%E4%B9%A0-%E6%96%87%E4%BB%B6%E7%9B%AE%E5%BD%95%E4%B9%8Bmv%E5%91%BD%E4%BB%A4%2F</url>
      <content type="text"><![CDATA[mv简介mv命令可以用来移动文件或者将文件改名（move (rename) files），经常用来备份文件或者目录 命令学习命令格式：mv [选项] 源文件或目录 目标文件或目录命令功能：根据mv命令中第二个参数类型（是目标文件还是目标目录），mv命令将文件重命名或将其移至一个新的目录中。当第二个参数类型是文件时，mv命令完成文件重命名，此时，源文件只能有一个（也可以是源目录名），它将所给的源文件或目录重命名为给定的目标文件名。当第二个参数是已存在的目录名称时，源文件或目录参数可以有多个，mv命令将各参数指定的源文件均移至目标目录中。在跨文件系统移动文件时，mv先拷贝，再将原有文件删除，而链至该文件的链接也将丢失。命令参数：-b ：若需覆盖文件，则覆盖前先行备份。-f ：force 强制的意思，如果目标文件已经存在，不会询问而直接覆盖-i ：若目标文件 (destination) 已经存在时，就会询问是否覆盖-u ：若目标文件已经存在，且 source 比较新，才会更新(update)-t ：指定mv的目标目录，该选项适用于移动多个源文件到一个目录的情况，此时目标目录在前，源文件在后。 常用范例例一：文件改名mv test.log test1.txttest.log 改为test1.txt 例二：移动文件mv test1.txt test3将test1.txt文件移到目录test3中 例三：将文件log1.txt,log2.txt,log3.txt移动到目录test3中。mv log1.txt log2.txt log3.txt test3将log1.txt ，log2.txt， log3.txt 三个文件移到 test3目录mv -t /opt/soft/test/test4/ log1.txt log2.txt log3.txt将三个文件移动到test4目录 例五：将文件file1改名为file2，即使file2存在，也是直接覆盖掉。mv -f log3.txt log2.txt 例六：目录的移动mv dir1 dir2如果目录dir2不存在，将目录dir1改名为dir2；否则，将dir1移动到dir2中 例7：移动当前文件夹下的所有文件到上一级目录mv * ../ 例8：把当前目录的一个子目录里的文件移动到另一个子目录里mv test3/*.txt test5]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[linux命令学习之文件目录命令-pwd命令]]></title>
      <url>%2F2017%2F03%2F30%2Flinux%E5%91%BD%E4%BB%A4%E5%AD%A6%E4%B9%A0-%E6%96%87%E4%BB%B6%E7%9B%AE%E5%BD%95%E4%B9%8Bpwd%E5%91%BD%E4%BB%A4%2F</url>
      <content type="text"><![CDATA[pwd简介pwd 命令查看”当前工作目录“的完整路径。每当在终端进行操作时，都会有一个当前工作目录。在不太确定当前位置时，使用pwd来判定当前目录在文件系统内的确切位置。 命令学习命令格式：pwd [选项] 目录命令功能：查看”当前工作目录“的完整路径常用参数：一般情况下不带任何参数如果目录是链接时：pwd -P 显示出实际路径，而连接（link）路径。pwd -L：与pwd -P完全相反，显示链接路径 环境变量PWD：显示当前工作路径的环境变量echo $PWD环境变量OLDPWD：显示上一次的工作路径echo $PWD注意：由于是环境变量，使用的时候需要加上$变量标志 内建命令pwd和外部命令/bin/pwd,二者的基本功能是一致的，但是在显示当前目录时，/bin/pwd显示得更准确些，而pwd容易被操作者糊弄常用范例例1：用 pwd 命令查看当前工作目录的完整路径pwd 例2：目录连接链接时，pwd -P 显示出实际路径，而非使用连接（link）路径pwd -p 例3：当前目录被删除了，而pwd命令仍然显示那个目录实例4：/bin/pwd/bin/pwd [选项]选项：-L 目录连接链接时，输出连接路径-P 输出物理路径]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[linux命令学习之文件目录命令-nl命令]]></title>
      <url>%2F2017%2F03%2F30%2Flinux%E5%91%BD%E4%BB%A4%E5%AD%A6%E4%B9%A0-%E6%96%87%E4%BB%B6%E7%9B%AE%E5%BD%95%E4%B9%8Bnl%E5%91%BD%E4%BB%A4%2F</url>
      <content type="text"><![CDATA[nl简介nl命令在linux系统中用来计算文件中行号。nl 可以将输出的文件内容自动的加上行号。其默认的结果与 cat -n 有点不太一样， nl可以将行号做比较多的显示设计，包括位数与是否自动补齐 0 等的功能。 命令学习命令格式：nl [选项] [文件]命令功能：nl 命令读取 File 参数（缺省情况下标准输入），计算输入中的行号，将计算过的行号写入标准输出。 在输出中，nl 命令根据您在命令行中指定的标志来计算左边的行。 输入文本必须写在逻辑页中。每个逻辑页有头、主体和页脚节（可以有空节）。 除非使用 -p 标志，nl 命令在每个逻辑页开始的地方重新设置行号。 可以单独为头、主体和页脚节设置行计算标志（例如，头和页脚行可以被计算然而文本行不能）。命令参数：-b ：行号指定的方式，主要有两种：-b a ：表示不论是否为空行，也同样列出行号(类似 cat -n)；-b t ：如果有空行，空的那一行不要列出行号(默认值)； -n ：列出行号表示的方法，主要有三种：-n ln ：行号在萤幕的最左方显示；-n rn ：行号在自己栏位的最右方显示，且不加 0 ；-n rz ：行号在自己栏位的最右方显示，且加 0 ； -w ：行号栏位的占用的位数。-p 在逻辑定界符处不重新开始计算。 常用范例例一：用 nl 列出 1.log的内容nl 1.log文件中的空白行，nl 不会加上行号 例二：用 nl 列出 1.log 的内容，空本行也加上行号nl -b a 1.log 例3：让行号前面自动补上0,统一输出格式nl -b a -n rz 1.lognl -b a -n rz -w 3 1.log]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[C语言位域]]></title>
      <url>%2F2017%2F03%2F30%2FC%E8%AF%AD%E8%A8%80%E4%BD%8D%E5%9F%9F%2F</url>
      <content type="text"><![CDATA[前言有些信息在存储时，并不需要占用一个完整的字节， 而只需占几个或一个二进制位。例如在存放一个开关量时，只有0和1 两种状态，用一位二进位即可。为了节省存储空间，并使处理简便，Ｃ语言提供了一种数据结构，称为“位域”或“位段”。所谓“位域”是把一个字节中的二进位划分为几个不同的区域，并说明每个区域的位数。每个域有一个域名，允许在程序中按域名进行操作。 这样就可以把几个不同的对象用一个字节的二进制位域来表示。 位域的定义和位域变量的说明位域定义与结构定义相仿，其形式为：struct 位域结构名{ 位域列表 };其中位域列表的形式为： 类型说明符 位域名：位域长度例如： struct bs { int a:8; int b:2; int c:6; }; 位域变量的说明与结构变量说明的方式相同。 可采用先定义后说明，同时定义说明或者直接说明这三种方式。例如： struct bs { int a:8; int b:2; int c:6; }data; 说明data为bs变量，共占两个字节。其中位域a占8位，位域b占2位，位域c占6位。备注： 一个位域必须存储在同一个字节中，不能跨两个字节。如一个字节所剩空间不够存放另一位域时，应从下一单元起存放该位域。也可以有意使某位域从下一单元开始。例如：struct bs{ unsigned a:4; unsigned :0; unsigned b:4; unsigned c:4;}在这个位域定义中，a占第一字节的4位，后4位填0表示不使用，b从第二字节开始，占用4位，c占用4位。 由于位域不允许跨两个字节，因此位域的长度不能大于一个字节的长度，也就是说不能超过8位二进位。位域可以无位域名，这时它只用来作填充或调整位置。无名的位域是不能使用的。例如： struct k { int a:1; int :2; int b:3; int c:2; }; 位域的使用位域的使用和结构成员的使用相同，其一般形式为：位域变量名·位域名位域允许用各种格式输出。 main(){ struct bs { unsigned a:1; unsigned b:3; unsigned c:4; } bit,*pbit; bit.a=1; bit.b=7; bit.c=15; printf(&quot;%d,%d,%d\n&quot;,bit.a,bit.b,bit.c); pbit=&amp;bit; pbit-&gt;a=0; pbit-&gt;b&amp;=3; pbit-&gt;c|=1; printf(&quot;%d,%d,%d\n&quot;,pbit-&gt;a,pbit-&gt;b,pbit-&gt;c); } 上例程序中定义了位域结构bs，三个位域为a,b,c。说明了bs类型的变量bit和指向bs类型的指针变量pbit。这表示位域也是可以使用指针的。程序的9、10、11三行分别给三个位域赋值。( 赋值不能超过该位域的允许范围)程序第12行以整型量格式输出三个域的内容。第13行把位域变量bit的地址送给指针变量pbit。第14行用指针方式给位域a重新赋值，赋为0。第15行使用了复合的位运算符”&amp;=”，该行相当于：pbit-&gt;b=pbit-&gt;b&amp;3位域b中原有值为7，与3作按位与运算的结果为3(111&amp;011=011,十进制值为3)。同样，程序第16行中使用了复合位运算”|=” 位域规则C99规定int、unsigned int和bool可以作为位域类型，但编译器几乎都对此作了扩展，允许其它类型类型的存在。使用位域的主要目的是压缩存储，其大致规则为：1) 如果相邻位域字段的类型相同，且其位宽之和小于类型的sizeof大小，则后面的字段将紧邻前一个字段存储，直到不能容纳为止；2) 如果相邻位域字段的类型相同，但其位宽之和大于类型的sizeof大小，则后面的字段将从新的存储单元开始，其偏移量为其类型大小的整数倍；3) 如果相邻的位域字段的类型不同，则各编译器的具体实现有差异，VC6采取不压缩方式，Dev-C++采取压缩方式；4) 如果位域字段之间穿插着非位域字段，则不进行压缩；5) 整个结构体的总大小为最宽基本类型成员大小的整数倍。 位域实例typedef struct AA { unsigned char b1:5; unsigned char b2:5; unsigned char b3:5; unsigned char b4:5; unsigned char b5:5; }AA; sizeof(AA) = 5; 但实际上只用了25位，即4个字节 （1）typedef struct AA { unsigned int b1:5; unsigned int b2:5; unsigned int b3:5; unsigned int b4:5; unsigned int b5:5; }AA; （2）typedef struct AA { unsigned int b1:5; unsigned int b2:5; unsigned int b3:5; unsigned int b4:5; unsigned int b5:5; unsigned int b6:5; unsigned int b7:5; }AA; （1）是5个成员,按第一条规则,共占25位,按第五条规则,即sizeof(AA)=4现把成员加到7个，参考（2）,按第一条规则,共占35位,按第五条规则,即sizeof(AA)=8, struct test1 { char a:1; char :2; long b:3; char c:2; }; int len = sizeof(test1);对于上述例子，len的值应该是12. 首先以最长的类型位宽做为偏移量，最长的是long型，占4位，所以不同类型之间应该是4个字节的偏移，即test1应该是4字节的整数倍。 char a：1； //用一个字节去存储char ：2； //空域。因为与前面的a的类型相同，而两个位域的位宽相加仍然少于8位，所以依然用1个字节表示long b：3； //long类型的位宽是4个字节，与前面的char类型不同，所以b与a之间偏移4个字节，它们之间自动补充3个字节 char c：2； //因为c与b又不同型，以test1中的最长的long类型的位宽进行偏移，所以虽然char只用1个字节就够了//但依然要占4个字节。总共是12字节。 struct s1 { int i: 8; int j: 4; int a: 3; double b; }; struct s2 { int i: 8; int j: 4; double b; int a:3; }; printf(&quot;sizeof(s1)= %d\n&quot;, sizeof(s1)); printf(&quot;sizeof(s2)= %d\n&quot;, sizeof(s2)); result: 16, 24 第一个struct s1 { int i: 8; int j: 4; int a: 3; double b; }; 理论上是这样的，首先是i在相对0的位置，占8位一个字节，然后，j就在相对一个字节的位置，由于一个位置的字节数是4位的倍数，因此不用对齐，就放 在那里了，然后是a，要在3位的倍数关系的位置上，因此要移一位，在15位的位置上放下，目前总共是18位，折算过来是2字节2位的样子，由于 double是8 字节的，因此要在相对0要是8个字节的位置上放下，因此从18位开始到8个字节之间的位置被忽略，直接放在8字节的位置了，因此，总共是16字节。 位域应用但是当我们编写网络程序的时候，要注意网络字节序和位序都是大端序的，而主机很多都是小端序。所以在网络中的第一个位字段通常放在一个字节的末尾，而在网络中的最后一个字节的位字段，则放在一个字节的前面。 struct{ uint8_t type: 4; uint8_t flag: 1; //1: control, 0:data uint8_t extension: 1; uint8_t R: 2; } __attribute__((__packed__)) MacCtlHdr_t; 这个是小端序主机上的定义，对应于下图中的帧格式 struct{ uint8_t RN_M4: 4; uint8_t cause: 3; uint8_t type: 1; uint8_t RN_M8: 8; uint8_t RN_L8: 8; uint8_t R: 4; uint8_t bsr: 4; }__attribute__((__packed__)) RA_HEADER; 对应于这样的帧格式：本地存储的是小端序，但是机器发送的时候是大端序。对已从每个字节的高位先行发送。所以顺序是第一字节的type，cause，RN4，之后是第二字节RNM8和第三字节RNL8，之后是第三字节的bsr和R。 #参考C语言位域精解C语言位域，字节序，帧格式]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[linux命令学习之文件目录命令-rm命令]]></title>
      <url>%2F2017%2F03%2F30%2Flinux%E5%91%BD%E4%BB%A4%E5%AD%A6%E4%B9%A0-%E6%96%87%E4%BB%B6%E7%9B%AE%E5%BD%95%E4%B9%8Brm%E5%91%BD%E4%BB%A4%2F</url>
      <content type="text"><![CDATA[rm简介rm命令为删除一个目录中的一个或多个文件或目录，也可以某个目录及其下的所有文件及子目录均删除。对于链接文件，只是删除了链接，原有文件均保持不变rm是一个危险的命令，使用的时候要特别当心，否则整个系统就会毁在这个命令（比如在/（根目录）下执行rm * -rf）。所以，在执行rm之前最好先确认一下在哪个目录，到底要删除什么东西。 命令学习命令格式：rm [选项] 文件命令功能：删除一个目录中的一个或多个文件或目录，如果没有使用- r选项，则rm不会删除目录。如果使用 rm 来删除文件，通常仍可以将该文件恢复原状。命令参数：-f,忽略不存在的文件，从不给出提示。-i,进行交互式删除-r, -R,指示rm将参数中列出的全部目录和子目录均递归地删除。-v, –verbose 详细显示进行的步骤–help 显示此帮助信息并退出–version 输出版本信息并退出 常用范例例一：删除文件file，系统会先询问是否删除。rm filename 例二：强行删除file，系统不再提示rm -f filename 例三：删除任何.log文件；删除前逐一询问确认rm -i *.log 例四：将 test1子目录及子目录中所有档案删除rm -r test1 例七：自定义回收站功能myrm(){D=/tmp/$(date +%Y%m%d%H%M%S);//在/tmp文件夹中创建名为“当前日期”的文件//其中“date+%Y%m%d%H%M%S”是规定了日期的输出格式mkdir -p $D;//以变量D中的路径创建文件夹mv “$@” $D &amp;&amp; echo “moved to $D ok”;//将所要删除的文件移入变量D中的文件夹内，移入成功后，输出移动成功}]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[linux命令学习之磁盘命令-df命令]]></title>
      <url>%2F2017%2F03%2F30%2Flinux%E5%91%BD%E4%BB%A4%E5%AD%A6%E4%B9%A0-%E7%A3%81%E7%9B%98%E5%91%BD%E4%BB%A4%E4%B9%8Bdf%E5%91%BD%E4%BB%A4%2F</url>
      <content type="text"><![CDATA[df命令简介 df命令的功能是用来检查linux服务器的文件系统的磁盘空间占用情况。可以利用该命令来获取硬盘被占用了多少空间，目前还剩下多少空间等信息。 命令学习命令格式：df [选项] [文件] 命令功能：显示指定磁盘文件的可用空间。如果没有文件名被指定，则所有当前被挂载的文件系统的可用空间将被显示。默认情况下，磁盘空间将以 1KB 为单位进行显示，除非环境变量 POSIXLY_CORRECT 被指定，那样将以512字节为单位进行显示 命令参数：必要参数：-a 全部文件系统列表-h 方便阅读方式显示-H 等于“-h”，但是计算式，1K=1000，而不是1K=1024-i 显示inode信息-k 区块为1024字节-l 只显示本地文件系统-m 区块为1048576字节–no-sync 忽略 sync 命令-P 输出格式为POSIX–sync 在取得磁盘信息前，先执行sync命令-T 文件系统类型 选择参数：–block-size=&lt;区块大小&gt; 指定区块大小-t&lt;文件系统类型&gt; 只显示选定文件系统的磁盘信息-x&lt;文件系统类型&gt; 不显示选定文件系统的磁盘信息–help 显示帮助信息–version 显示版本信息 常用范例例1：显示磁盘使用情况dflinux中df命令的输出清单的第1列是代表文件系统对应的设备文件的路径名（一般是硬盘上的分区）；第2列给出分区包含的数据块（1024字节）的数目；第3，4列分别表示已用的和可用的数据块数目。用户也许会感到奇怪的是，第3，4列块数之和不等于第2列中的块数。这是因为缺省的每个分区都留了少量空间供系统管理员使用。即使遇到普通用户空间已满的情况，管理员仍能登录和留有解决问题所需的工作空间。第5列已用% 列表示普通用户空间使用的百分比，即使这一数字达到100％，分区仍然留有系统管理员使用的空间。第6列挂载点列表示文件系统的挂载点。 例2：以inode模式来显示磁盘使用情况 df -i 例3：列出各文件系统的i节点使用情况 例5：列出文件系统的类型df -T 例6：以更易读的方式显示目前磁盘空间和使用情况 例7：显示所有的信息df –total]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[linux命令学习之文件目录命令-touch命令]]></title>
      <url>%2F2017%2F03%2F30%2Flinux%E5%91%BD%E4%BB%A4%E5%AD%A6%E4%B9%A0-%E6%96%87%E4%BB%B6%E7%9B%AE%E5%BD%95%E4%B9%8Btouch%E5%91%BD%E4%BB%A4%2F</url>
      <content type="text"><![CDATA[touch简介linux的touch命令不常用，一般在使用make的时候可能会用到，用来修改文件时间戳，或者新建一个不存在的文件 命令学习命令格式：touch [选项] 文件命令功能：可更改文档或目录的日期时间，包括存取时间和更改时间。命令参数：-a 只更改存取时间。-c 不建立任何文档。-d 使用指定的日期时间，而非现在的时间。参数是年月日-f 此参数将忽略不予处理，仅负责解决BSD版本touch指令的兼容性问题。-m 只更改变动时间。-r 把指定文档或目录的日期时间，统统设成和参考文档或目录的日期时间相同。-t 使用指定的日期时间，而非现在的时间。参数是年月日时分秒 常用范例例一：创建不存在的文件touch 1.log 2.log 例二：更改时间戳touch -r 1.log 2.log将2.log文件的时间改为与1.log相同 例二：修改为当前时间touch filename系统自动将文件修改时间更新为当前时间 例三：设定文件的时间戳touch -t 201211142234.50 1.log测试后发现不管是否为当月时间都是显示形式为年月日]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[linux命令学习之网络命令-netstat命令]]></title>
      <url>%2F2017%2F03%2F30%2Flinux%E5%91%BD%E4%BB%A4%E5%AD%A6%E4%B9%A0-%E7%BD%91%E7%BB%9C%E5%91%BD%E4%BB%A4%E4%B9%8Bnetstat%E5%91%BD%E4%BB%A4%2F</url>
      <content type="text"><![CDATA[netstat简介netstat命令用于显示与IP、TCP、UDP和ICMP协议相关的统计数据，一般用于检验本机各端口的网络连接情况。netstat是在内核中访问网络及相关信息的程序，它能提供TCP连接，TCP和UDP监听，进程内存管理的相关报告。如果你的计算机有时候接收到的数据报导致出错数据或故障，你不必感到奇怪，TCP/IP可以容许这些类型的错误，并能够自动重发数据报。但如果累计的出错情况数目占到所接收的IP数据报相当大的百分比，或者它的数目正迅速增加，那么你就应该使用netstat查一查为什么会出现这些情况了。 命令学习命令格式：netstat [-acCeFghilMnNoprstuvVwx][-A&lt;网络类型&gt;][–ip] 命令功能：netstat用于显示与IP、TCP、UDP和ICMP协议相关的统计数据，一般用于检验本机各端口的网络连接情况。 命令参数：-a或–all 显示所有连线中的Socket。-A&lt;网络类型&gt;或–&lt;网络类型&gt; 列出该网络类型连线中的相关地址。-c或–continuous 持续列出网络状态。-C或–cache 显示路由器配置的快取信息。-e或–extend 显示网络其他相关信息。-F或–fib 显示FIB。-g或–groups 显示多重广播功能群组组员名单。-h或–help 在线帮助。-i或–interfaces 显示网络界面信息表单。-l或–listening 显示监控中的服务器的Socket。-M或–masquerade 显示伪装的网络连线。-n或–numeric 直接使用IP地址，而不通过域名服务器。-N或–netlink或–symbolic 显示网络硬件外围设备的符号连接名称。-o或–timers 显示计时器。-p或–programs 显示正在使用Socket的程序识别码和程序名称。-r或–route 显示Routing Table。-s或–statistice 显示网络工作信息统计表。-t或–tcp 显示TCP传输协议的连线状况。-u或–udp 显示UDP传输协议的连线状况。-v或–verbose 显示指令执行过程。-V或–version 显示版本信息。-w或–raw 显示RAW传输协议的连线状况。-x或–unix 此参数的效果和指定”-A unix”参数相同。–ip或–inet 此参数的效果和指定”-A inet”参数相同。 常用范例例1：无参数使用netstat 从整体上看，netstat的输出结果可以分为两个部分：一个是Active Internet connections，称为有源TCP连接，其中”Recv-Q”和”Send-Q”指的是接收队列和发送队列。这些数字一般都应该是0。如果不是则表示软件包正在队列中堆积。这种情况只能在非常少的情况见到。另一个是Active UNIX domain sockets，称为有源Unix域套接口(和网络套接字一样，但是只能用于本机通信，性能可以提高一倍)。Proto显示连接使用的协议,RefCnt表示连接到本套接口上的进程号,Types显示套接口的类型,State显示套接口当前的状态,Path表示连接到套接口的其它进程使用的路径名。套接口类型：-t ：TCP-u ：UDP-raw ：RAW类型–unix ：UNIX域类型–ax25 ：AX25类型–ipx ：ipx类型–netrom ：netrom类型状态说明：LISTEN：侦听来自远方的TCP端口的连接请求SYN-SENT：再发送连接请求后等待匹配的连接请求（如果有大量这样的状态包，检查是否中招了）SYN-RECEIVED：再收到和发送一个连接请求后等待对方对连接请求的确认（如有大量此状态，估计被flood攻击了）ESTABLISHED：代表一个打开的连接FIN-WAIT-1：等待远程TCP连接中断请求，或先前的连接中断请求的确认FIN-WAIT-2：从远程TCP等待连接中断请求CLOSE-WAIT：等待从本地用户发来的连接中断请求CLOSING：等待远程TCP对连接中断的确认LAST-ACK：等待原来的发向远程TCP的连接中断请求的确认（不是什么好东西，此项出现，检查是否被攻击）TIME-WAIT：等待足够的时间以确保远程TCP接收到连接中断请求的确认CLOSED：没有任何连接状态 例2：列出所有端口netstat -a 显示一个所有的有效连接信息列表，包括已建立的连接（ESTABLISHED），也包括监听连接请（LISTENING）的那些连接。 例3：显示当前UDP连接状况netstat -nu 例4：显示UDP端口号的使用情况netstat -apu 例5：显示网卡列表netstat -i 例6：显示组播组的关系netstat -g 例7：显示网络统计信息netstat -s 例8：显示监听的套接口netstat -l 例9：显示所有已建立的有效连接netstat -n 例10：显示关于以太网的统计数据netstat -e 用于显示关于以太网的统计数据。它列出的项目包括传送的数据报的总字节数、错误数、删除数、数据报的数量和广播的数量。这些统计数据既有发送的数据报数量，也有接收的数据报数量。这个选项可以用来统计一些基本的网络流量） 例11：显示关于路由表的信息netstat -r 例12：列出所有 tcp 端口netstat -at 例13：统计机器中网络连接各个状态个数netstat -a | awk ‘/^tcp/ {++S[$NF]} END {for(a in S) print a, S[a]}’ 例14：把状态全都取出来后使用uniq -c统计后再进行排序netstat -nat |awk ‘{print $6}’|sort|uniq -c 例15：查看连接某服务端口最多的的IP地址netstat -nat | grep “192.168.120.20:16067” |awk ‘{print $5}’|awk -F: ‘{print $4}’|sort|uniq -c|sort -nr|head -20 例16：找出程序运行的端口 netstat -ap | grep ssh 例17：在 netstat 输出中显示 PID 和进程名称netstat -pt 例18：找出运行在指定端口的进程netstat -anpt | grep ‘:16064’运行在端口16064的进程id为24596，再通过ps命令就可以找到具体的应用程序了。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[linux下VNC远程访问]]></title>
      <url>%2F2017%2F03%2F30%2Flinux%E4%B8%8Bvnc%E8%BF%9C%E7%A8%8B%E6%A1%8C%E9%9D%A2%E8%AE%BF%E9%97%AE%2F</url>
      <content type="text"><![CDATA[VNC远程桌面原理 vnc访问流程如下：1，vnc客户端通过浏览器或者vnc viewer 连接至vnc server2,vnc server 传送一个对话框至客户端，要求输入连接密码，以及存取的vnc server显示装置3，在客户端输入联机密码后，vnc server验证客户端是否具有存取权限。4，若是客户端通过vnc server的验证，客户端即要求vnc server显示桌面环境5，vnc server通过x xprotocol协议要求x server将画面显示控制权交给vnc server6，vnc server将来自x server的桌面环境利用vnc通信协议送至客户端，并且允许客户端控制vnc server的桌面环境及输入装置。 安装vncsudo apt-get install vnc4server 启动vncvncserver第一次启动时会提示输入密码注：创建一个指定会话号的vnc桌面vncserver :2 创建一个指定会话号为2的桌面 编辑启动脚本sudo gedit ~/.vnc/xstartup若有twm,则注释掉，添加如下 重启vnc结束之前的vnc线程vncserver -kill :1然后再启动vnc服务输入vncserver vnc viewer登入ifconfig查询linux的ip地址，ok后填入vncserver启动时设置的密码登入后发现只出现控制台界面，无法显示桌面将脚本中改为如下，关闭vncservervncserver -kill :1再重启vncserver]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[linux命令学习之ifconfig命令]]></title>
      <url>%2F2017%2F03%2F30%2Flinux%E5%91%BD%E4%BB%A4%E5%AD%A6%E4%B9%A0-%E7%BD%91%E7%BB%9C%E5%91%BD%E4%BB%A4%E4%B9%8Bifconfig%E5%91%BD%E4%BB%A4%2F</url>
      <content type="text"><![CDATA[ifconfig简介 通常需要以root身份登录或使用sudo以便在Linux机器上使用ifconfig工具。依赖于ifconfig命令中使用一些选项属性，ifconfig工具不仅可以被用来简单地获取网络接口配置信息，还可以修改这些配置。 用ifconfig命令配置的网卡信息，在网卡重启后机器重启后，配置就不存在。要想配置信息永远的存的电脑里，那就要修改网卡的配置文件了。 命令学习 命令格式：ifconfig [网络设备] [参数] 命令功能：ifconfig 命令用来查看和配置网络设备。当网络环境发生改变时可通过此命令对网络进行相应的配置。 命令参数：up 启动指定网络设备/网卡。down 关闭指定网络设备/网卡。该参数可以有效地阻止通过指定接口的IP信息流，如果想永久地关闭一个接口，我们还需要从核心路由表中将该接口的路由信息全部删除。arp 设置指定网卡是否支持ARP协议。-promisc 设置是否支持网卡的promiscuous模式，如果选择此参数，网卡将接收网络中发给它所有的数据包-allmulti 设置是否支持多播模式，如果选择此参数，网卡将接收网络中所有的多播数据包-a 显示全部接口信息-s 显示摘要信息（类似于 netstat -i）add 给指定网卡配置IPv6地址del 删除指定网卡的IPv6地址&lt;硬件地址&gt; 配置网卡最大的传输单元mtu&lt;字节数&gt; 设置网卡的最大传输单元 (bytes)netmask&lt;子网掩码&gt; 设置网卡的子网掩码。掩码可以是有前缀0x的32位十六进制数，也可以是用点分开的4个十进制数。如果不打算将网络分成子网，可以不管这一选项；如果要使用子网，那么请记住，网络中每一个系统必须有相同子网掩码。tunel 建立隧道dstaddr 设定一个远端地址，建立点对点通信-broadcast&lt;地址&gt; 为指定网卡设置广播协议-pointtopoint&lt;地址&gt; 为网卡设置点对点通讯协议multicast 为网卡设置组播标志address 为网卡设置IPv4地址txqueuelen&lt;长度&gt; 为网卡设置传输列队的长度 常用范例 例1：显示网络设备信息（激活状态的） eth0 表示第一块网卡， 其中硬件地址表示网卡的物理地址，可以看到目前这个网卡的物理地址(MAC地址）是 00:50:56:BF:26:20inet addr 用来表示网卡的IP地址，此网卡的 IP地址是 192.168.120.204广播地址 Bcast:192.168.120.255，掩码地址Mask:255.255.255.0lo 是表示主机的回坏地址，这个一般是用来测试一个网络程序，但又不想让局域网或外网的用户能够查看，只能在此台主机上运行和查看所用的网络接口。比如把 HTTPD服务器的指定到回坏地址，在浏览器输入 127.0.0.1 就能看到你所架WEB网站了。但只是您能看得到，局域网的其它主机或用户无从知道。第一行：连接类型：Ethernet（以太网）HWaddr（硬件mac地址）第二行：网卡的IP地址、子网、掩码第三行：UP（代表网卡开启状态）RUNNING（代表网卡的网线被接上）MULTICAST（支持组播） MTU:1500（最大传输单元）：1500字节第四、五行：接收、发送数据包情况统计第七行：接收、发送数据字节数统计信息。 例2：启动关闭指定网卡ifconfig eth0 upifconfig eth0 downifconfig eth0 up 为启动网卡eth0 ；ifconfig eth0 down 为关闭网卡eth0。ssh登陆linux服务器操作要小心，关闭了就不能开启了，除非你有多网卡。 例4：用ifconfig修改MAC地址 ifconfig eth0 down //关闭网卡ifconfig eth0 hw ether 00:AA:BB:CC:DD:EEifconfig eth0 up //启动网卡 例5：配置IP地址ifconfig eth0 192.168.120.56给eth0网卡配置IP地：192.168.120.56 ifconfig eth0 192.168.120.56 netmask 255.255.255.0给eth0网卡配置IP地址：192.168.120.56 ，并加上子掩码：255.255.255.0ifconfig eth0 192.168.120.56 netmask 255.255.255.0 broadcast 192.168.120.255给eth0网卡配置IP地址：192.168.120.56，加上子掩码：255.255.255.0，加上个广播地址： 192.168.120.255 例6：启用和关闭ARP协议ifconfig eth0 arp 开启网卡eth0 的arp协议ifconfig eth0 -arp 关闭网卡eth0 的arp协议； 例7：设置最大传输单元ifconfig eth0 mtu 1500设置能通过的最大数据包大小为 1500 bytes]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[linux命令学习之网络命令-ping命令]]></title>
      <url>%2F2017%2F03%2F30%2Flinux%E5%91%BD%E4%BB%A4%E5%AD%A6%E4%B9%A0-%E7%BD%91%E7%BB%9C%E5%91%BD%E4%BB%A4%E4%B9%8Bping%E5%91%BD%E4%BB%A4%2F</url>
      <content type="text"><![CDATA[ping简介Linux系统的ping命令是常用的网络命令，它通常用来测试与目标主机的连通性。我们经常会说“ping一下某机器，看是不是开着”、不能打开网页时会说“你先ping网关地址192.168.1.1试试”。它通过发送ICMP ECHO_REQUEST数据包到网络主机（send ICMP ECHO_REQUEST to network hosts），并显示响应情况，这样我们就可以根据它输出的信息来确定目标主机是否可访问（但这不是绝对的）。有些服务器为了防止通过ping探测到，通过防火墙设置了禁止ping或者在内核参数中禁止ping，这样就不能通过ping确定该主机是否还处于开启状态。linux下的ping和windows下的ping稍有区别,linux下ping不会自动终止,需要按ctrl+c终止或者用参数-c指定要求完成的回应次数。 命令学习命令格式：ping [参数] [主机名或IP地址] 命令功能：ping命令用于：确定网络和各外部主机的状态；跟踪和隔离硬件和软件问题；测试、评估和管理网络。如果主机正在运行并连在网上，它就对回送信号进行响应。每个回送信号请求包含一个网际协议（IP）和 ICMP 头，后面紧跟一个 tim 结构，以及来填写这个信息包的足够的字节。缺省情况是连续发送回送信号请求直到接收到中断信号（Ctrl-C）。ping 命令每秒发送一个数据报并且为每个接收到的响应打印一行输出。ping 命令计算信号往返时间和(信息)包丢失情况的统计信息，并且在完成之后显示一个简要总结。ping 命令在程序超时或当接收到 SIGINT 信号时结束。Host 参数或者是一个有效的主机名或者是因特网地址。 命令参数：-d 使用Socket的SO_DEBUG功能。-f 极限检测。大量且快速地送网络封包给一台机器，看它的回应。-n 只输出数值。-q 不显示任何传送封包的信息，只显示最后的结果。-r 忽略普通的Routing Table，直接将数据包送到远端主机上。通常是查看本机的网络接口是否有问题。-v 详细显示指令的执行过程。 -c 数目：在发送指定数目的包后停止。-i 秒数：设定间隔几秒送一个网络封包给一台机器，预设值是一秒送一次。-I 网络界面：使用指定的网络界面送出数据包。-l 前置载入：设置在送出要求信息之前，先行发出的数据包。-p 范本样式：设置填满数据包的范本样式。-s 字节数：指定发送的数据字节数，预设值是56，加上8字节的ICMP头，一共是64ICMP数据字节。-t 存活数值：设置存活数值TTL的大小。 常用范例例1：ping的通的情况ping 192.168.120.205 例2：ping不通的情况ping 192.168.120.202 例3：ping网关ping -b 192.168.120.1 例4：ping指定次数ping -c 10 192.168.120.206 例5：时间间隔和次数限制的pingping -c 10 -i 0.5 192.168.120.206 例6：通过域名ping公网上的站点ping -c 5 www.58.com 例7：多参数使用ping -i 3 -s 1024 -t 255 192.168.120.206-i 3 发送周期为 3秒 -s 设置发送包的大小为1024 -t 设置TTL值为 255]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[linux命令学习之route命令]]></title>
      <url>%2F2017%2F03%2F30%2Flinux%E5%91%BD%E4%BB%A4%E5%AD%A6%E4%B9%A0-%E7%BD%91%E7%BB%9C%E5%91%BD%E4%BB%A4%E4%B9%8Broute%E5%91%BD%E4%BB%A4%2F</url>
      <content type="text"><![CDATA[route简介route命令用于显示和操作IP路由表。要实现两个不同的子网之间的通信，需要一台连接两个网络的路由器，或者同时位于两个网络的网关来实现。在Linux系统中，设置路由通常是为了解决以下问题：该Linux系统在一个局域网中，局域网中有一个网关，能够让机器访问Internet，那么就需要将这台机器的IP地址设置为Linux机器的默认路由。直接在命令行下执行route命令来添加路由，不会永久保存，当网卡重启或者机器重启之后，该路由就失效了。可以在/etc/rc.local中添加route命令来保证该路由设置永久有效。 命令学习命令格式：route [-f] [-p] [Command [Destination] [mask Netmask] [Gateway] [metric Metric]] [if Interface]] 命令功能：Route命令是用于操作基于内核ip路由表，它的主要作用是创建一个静态路由让指定一个主机或者一个网络通过一个网络接口，如eth0。当使用”add”或者”del”参数时，路由表被修改，如果没有参数，则显示路由表当前的内容。 命令参数：-c 显示更多信息-n 不解析名字-v 显示详细的处理信息-F 显示发送信息-C 显示路由缓存-f 清除所有网关入口的路由表。-p 与 add 命令一起使用时使路由具有永久性。 add:添加一条新路由。del:删除一条路由。-net:目标地址是一个网络。-host:目标地址是一个主机。netmask:当添加一个网络路由时，需要使用网络掩码。gw:路由数据包通过网关。注意，你指定的网关必须能够达到。metric：设置路由跳数。 Command 指定您想运行的命令 (Add/Change/Delete/Print)。Destination 指定该路由的网络目标。mask Netmask 指定与网络目标相关的网络掩码（也被称作子网掩码）。Gateway 指定网络目标定义的地址集和子网掩码可以到达的前进或下一跃点 IP 地址。metric Metric 为路由指定一个整数成本值标（从 1 至 9999），当在路由表(与转发的数据包目标地址最匹配)的多个路由中进行选择时可以使用。if Interface 为可以访问目标的接口指定接口索引。若要获得一个接口列表和它们相应的接口索引，使用 route print 命令的显示功能。可以使用十进制或十六进制值进行接口索引。 常用范例例1：显示当前路由routeroute -n route -n (-n 表示不解析名字,列出速度会比route 快) 第一行表示主机所在网络的地址为192.168.120.0，若数据传送目标是在本局域网内通信，则可直接通过eth0转发数据包;第四行表示数据传送目的是访问Internet，则由接口eth0，将数据包发送到网关192.168.120.240其中Flags为路由标志，标记当前网络节点的状态。Flags标志说明：U Up表示此路由当前为启动状态H Host，表示此网关为一主机G Gateway，表示此网关为一路由器R Reinstate Route，使用动态路由重新初始化的路由D Dynamically,此路由是动态性地写入M Modified，此路由是由路由守护程序或导向器动态修改! 表示此路由当前为关闭状态 例2：添加网关/设置网关route add -net 224.0.0.0 netmask 240.0.0.0 dev eth0增加一条 到达244.0.0.0的路由 例3：屏蔽一条路由route add -net 224.0.0.0 netmask 240.0.0.0 reject 例4：删除路由记录route del -net 224.0.0.0 netmask 240.0.0.0route del -net 224.0.0.0 netmask 240.0.0.0 reject 例5：删除和添加设置默认网关 route del default gw 192.168.120.240route add default gw 192.168.120.240]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[linux命令学习之网络命令-traceroute命令]]></title>
      <url>%2F2017%2F03%2F30%2Flinux%E5%91%BD%E4%BB%A4%E5%AD%A6%E4%B9%A0-%E7%BD%91%E7%BB%9C%E5%91%BD%E4%BB%A4%E4%B9%8Btraceroute%E5%91%BD%E4%BB%A4%2F</url>
      <content type="text"><![CDATA[traceroute简介通过traceroute可以知道信息从你的计算机到互联网另一端的主机是走的什么路径。每次数据包由某一同样的出发点（source）到达某一同样的目的地(destination)走的路径可能会不一样，但基本上来说大部分时候所走的路由是相同的。linux系统中，我们称之为traceroute,在MS Windows中为tracert。 traceroute通过发送小的数据包到目的设备直到其返回，来测量其需要多长时间。一条路径上的每个设备traceroute要测3次。输出结果中包括每次测试的时间(ms)和设备的名称（如有的话）及其IP地址。在大多数情况下，在linux主机系统下，直接执行命令行：traceroute hostname而在Windows系统下是执行tracert的命令：tracert hostname traceroute工作原理Traceroute程序的设计是利用ICMP及IP header的TTL（Time To Live）栏位（field）。 首先，traceroute送出一个TTL是1的IP datagram（其实，每次送出的为3个40字节的包，包括源地址，目的地址和包发出的时间标签）到目的地，当路径上的第一个路由器（router）收到这个datagram时，它将TTL减1。此时，TTL变为0了，所以该路由器会将此datagram丢掉，并送回一个「ICMP time exceeded」消息（包括发IP包的源地址，IP包的所有内容及路由器的IP地址），traceroute 收到这个消息后，便知道这个路由器存在于这个路径上，接着traceroute 再送出另一个TTL是2 的datagram，发现第2 个路由器。 traceroute 每次将送出的datagram的TTL 加1来发现另一个路由器，这个重复的动作一直持续到某个datagram 抵达目的地。当datagram到达目的地后，该主机并不会送回ICMP time exceeded消息，因为它已是目的地了，那么traceroute如何得知目的地到达了呢？ Traceroute在送出UDP datagrams到目的地时，它所选择送达的port number 是一个一般应用程序都不会用的号码（30000 以上），所以当此UDP datagram 到达目的地后该主机会送回一个「ICMP port unreachable」的消息，而当traceroute 收到这个消息时，便知道目的地已经到达了。所以traceroute 在Server端也是没有所谓的Daemon 程式。 Traceroute提取发 ICMP TTL到期消息设备的IP地址并作域名解析。每次 ，Traceroute都打印出一系列数据,包括所经过的路由设备的域名及 IP地址,三个包每次来回所花时间。 命令学习命令格式：traceroute[参数][主机] 命令功能：traceroute指令让你追踪网络数据包的路由途径，预设数据包大小是40Bytes，用户可另行设置。具体参数格式：traceroute [-dFlnrvx][-f&lt;存活数值&gt;][-g&lt;网关&gt;…][-i&lt;网络界面&gt;][-m&lt;存活数值&gt;][-p&lt;通信端口&gt;][-s&lt;来源地址&gt;][-t&lt;服务类型&gt;][-w&lt;超时秒数&gt;][主机名称或IP地址][数据包大小] 命令参数：-d 使用Socket层级的排错功能。-f 设置第一个检测数据包的存活数值TTL的大小。-F 设置勿离断位。-g 设置来源路由网关，最多可设置8个。-i 使用指定的网络界面送出数据包。-I 使用ICMP回应取代UDP资料信息。-m 设置检测数据包的最大存活数值TTL的大小。-n 直接使用IP地址而非主机名称。-p 设置UDP传输协议的通信端口。-r 忽略普通的Routing Table，直接将数据包送到远端主机上。-s 设置本地主机送出数据包的IP地址。-t 设置检测数据包的TOS数值。-v 详细显示指令的执行过程。-w 设置等待远端主机回报的时间。-x 开启或关闭数据包的正确性检验。 常用范例例1：traceroute 用法简单、最常用的用法traceroute www.baidu.com 记录按序列号从1开始，每个纪录就是一跳 ，每跳表示一个网关，我们看到每行有三个时间，单位是 ms，其实就是-q的默认参数。探测数据包向每个网关发送三个数据包后，网关响应后返回的时间；如果您用 traceroute -q 4 www.58.com ，表示向每个网关发送4个数据包。有时我们traceroute 一台主机时，会看到有一些行是以星号表示的。出现这样的情况，可能是防火墙封掉了ICMP的返回信息，所以我们得不到什么相关的数据包返回数据。有时我们在某一网关处延时比较长，有可能是某台网关比较阻塞，也可能是物理设备本身的原因。当然如果某台DNS出现问题时，不能解析主机名、域名时，也会 有延时长的现象；您可以加-n 参数来避免DNS解析，以IP格式输出数据。如果在局域网中的不同网段之间，我们可以通过traceroute 来排查问题所在，是主机的问题还是网关的问题。如果我们通过远程来访问某台服务器遇到问题时，我们用到traceroute 追踪数据包所经过的网关，提交IDC服务商，也有助于解决问题；但目前看来在国内解决这样的问题是比较困难的，就是我们发现问题所在，IDC服务商也不可能帮助我们解决。 例2：跳数设置traceroute -m 10 www.baidu.com 例3：显示IP地址，不查主机名traceroute -n www.baidu.com 例4：探测包使用的基本UDP端口设置6888traceroute -p 6888 www.baidu.com 例5：把探测包的个数设置为值4traceroute -q 4 www.baidu.com 例6：绕过正常的路由表，直接发送到网络相连的主机 traceroute -r www.baidu.com 例7：把对外发探测包的等待响应时间设置为3秒traceroute -w 3 www.baidu.com]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[linux文件类型与扩展名]]></title>
      <url>%2F2017%2F03%2F30%2Flinux%E6%96%87%E4%BB%B6%E7%B1%BB%E5%9E%8B%E4%B8%8E%E6%89%A9%E5%B1%95%E5%90%8D%2F</url>
      <content type="text"><![CDATA[linux文件类型与扩展名文件类型Linux文件类型常见的有：普通文件、目录文件、字符设备文件和块设备文件、符号链接文件等。1. 普通文件我们用 ls -lh 来查看某个文件的属性，可以看到有类似-rwxrwxrwx，值得注意的是第一个符号是 - ，这样的文件在Linux中就是普通文件。这些文件一般是用一些相关的应用程序创建，比如图像工具、文档工具、归档工具或 cp工具等。这类文件的删除方式是用rm 命令。 另外，依照文件的内容，又大略可以分为：1&gt;. 纯文本档(ASCII)：Linux系统中最多的一种文件类型，称为纯文本档是因为内容为我们可以直接读到的数据，例如数字、字母等等。 几乎只要我们可以用来做为设定的文件都属于这一种文件类型。举例来说，你可以用命令： cat ~/.bashrc 来看到该文件的内容。 (cat 是将一个文件内容读出来的指令).2&gt;. 二进制文件(binary)：Linux系统其实仅认识且可以执行二进制文件(binary file)。Linux当中的可执行文件(scripts, 文字型批处理文件不算)就是这种格式的文件。 使用的命令cat就是一个binary file。3&gt;. 数据格式文件(data)：有些程序在运作的过程当中会读取某些特定格式的文件，那些特定格式的文件可以被称为数据文件 (data file)。举例来说，我们的Linux在使用者登录时，都会将登录的数据记录在 /var/log/wtmp那个文件内，该文件是一个data file，能够透过last这个指令读出来！ 但是使用cat时，会读出乱码～因为他是属于一种特殊格式的文件 2. 目录文件当我们在某个目录下执行，看到有类似 drwxr-xr-x ，这样的文件就是目录，目录在Linux是一个比较特殊的文件。注意它的第一个字符是d。创建目录的命令可以用 mkdir 命令，或cp命令，cp可以把一个目录复制为另一个目录。删除用rm 或rmdir命令。 3. 字符设备或块设备文件如时您进入/dev目录，列一下文件，会看到类似如下的:[root@localhost ~]# ls -al /dev/ttycrw-rw-rw- 1 root tty 5, 0 11-03 15:11 /dev/tty[root@localhost ~]# ls -la /dev/sda1brw-r—– 1 root disk 8, 1 11-03 07:11 /dev/sda1我们看到/dev/tty的属性是 crw-rw-rw- ，前面第一个字符是 c ，表示字符设备文件。比如猫等串口设备。我们看到 /dev/sda1 的属性是 brw-r—– ，注意前面的第一个字符是b，这表示块设备，比如硬盘，光驱等设备。这个种类的文件，是用mknode来创建，用rm来删除。目前在最新的Linux发行版本中，我们一般不用自己来创建设备文件。因为这些文件是和内核相关联的。与系统周边及储存等相关的一些文件， 通常都集中在/dev这个目录之下！通常又分为两种：区块(block)设备档 ：就是一些储存数据， 以提供系统随机存取的接口设备。举例来说，硬盘与软盘等就是！ 可以随机的在硬盘的不同区块读写。可以自行查一下/dev/sda看看， 会发现第一个属性为[ b ]！字符(character)设备文件：一些串行端口的接口设备， 例如键盘、鼠标等等！这些设备的特色就是一次性读取，不能够截断输出。 举例来说，你不可能让鼠标跳到另一个画面，而是滑动到另一个地方！第一个属性为 [ c ]。 4. 数据接口文件(sockets)：数据接口文件（套接口文件），这种类型的文件通常被用在网络上的数据承接了。我们可以启动一个程序来监听客户端的要求， 而客户端就可以透过这个socket来进行数据的沟通了。第一个属性为 [ s ]， 最常在/var/run这个目录中看到这种文件类型了。例如：当我们启动MySQL服务器时，会产生一个mysql.sock的文件。[root@localhost ~]# ls -lh /var/lib/mysql/mysql.socksrwxrwxrwx 1 mysql mysql 0 04-19 11:12 /var/lib/mysql/mysql.sock注意这个文件的属性的第一个字符是 s。 5. 符号链接文件：当我们查看文件属性时，会看到有类似 lrwxrwxrwx,注意第一个字符是l，这类文件是链接文件。通过ln -s 源文件名 新文件名 。和Windows操作系统中的快捷方式有点相似。 6. 数据输送文件（FIFO,pipe）FIFO也是一种特殊的文件类型，他主要的目的在解决多个程序同时存取一个文件所造成的错误问题。 FIFO是first-in-first-out的缩写。第一个属性为[p] 。 文件扩展名1. 扩展名类型Linux的文件是没有所谓的扩展名的，一个Linux文件能不能被执行，与他的第一栏的十个属性有关，与文档名根本一点关系也没有。这个观念跟Windows的情况不相同！在Windows底下，能被执行的文件扩展名通常是 .com .exe .bat等等，而在Linux底下，只要你的权限当中具有x的话，例如[ -rwx-r-xr-x ] 即代表这个文件可以被执行。不过，可以被执行跟可以执行成功是不一样的举例来说，在root家目录下的install.log 是一个纯文本档，如果经由修改权限成为 -rwxrwxrwx 后，这个文件能够真的执行成功吗？ 当然不行。因为他的内容根本就没有可以执行的数据。所以说，这个x代表这个文件具有可执行的能力， 但是能不能执行成功，当然就得要看该文件的内容。所以，通常我们还是会以适当的扩展名来表示该文件是什么种类的。底下有数种常用的扩展名：.sh ： 脚本或批处理文件 (scripts)，因为批处理文件为使用shell写成的，所以扩展名就编成 .sh Z, .tar, .tar.gz, .zip, .tgz： 经过打包的压缩文件。这是因为压缩软件分别为 gunzip, tar 等等的，由于不同的压缩软件，而取其相关的扩展名！.html, .php：网页相关文件，分别代表 HTML 语法与 PHP 语法的网页文件。 .html 的文件可使用网页浏览器来直接开启，至于 .php 的文件， 则可以透过 client 端的浏览器来 server 端浏览，以得到运算后的网页结果。基本上，Linux系统上的文件名真的只是让你了解该文件可能的用途而已，真正的执行与否仍然需要权限的规范才行。例如虽然有一个文件为可执行文件，如常见的/bin/ls这个显示文件属性的指令，不过，如果这个文件的权限被修改成无法执行时，那么ls就变成不能执行。上述的这种问题最常发生在文件传送的过程中。例如你在网络上下载一个可执行文件，但是偏偏在你的 Linux系统中就是无法执行！那么就是可能文件的属性被改变了。从网络上传送到你的 Linux系统中，文件的属性与权限确实是会被改变的。 2. Linux文件名长度限制在Linux底下，使用预设的Ext2/Ext3文件系统时，针对文件名长度限制为：单一文件或目录的最大容许文件名为 255 个字符包含完整路径名称及目录 (/) 之完整档名为 4096 个字符 3. Linux文件名的字符的限制由于Linux在文字接口下的一些指令操作关系，一般来说，在设定Linux底下的文件名时， 最好可以避免一些特殊字符比较好！例如这些： ? &gt; &lt; ; &amp; ! [ ] | \ ‘ “ ` ( ) { } 因为这些符号在文字接口下，是有特殊意义的。另外，文件名的开头为小数点“.”时， 代表这个文件为隐藏文件！同时，由于指令下达当中，常常会使用到 -option 之类的选项， 所以最好也避免将文件档名的开头以 - 或 + 来命名。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[linux命令学习之网络命令-ss命令]]></title>
      <url>%2F2017%2F03%2F30%2Flinux%E5%91%BD%E4%BB%A4%E5%AD%A6%E4%B9%A0-%E7%BD%91%E7%BB%9C%E5%91%BD%E4%BB%A4%E4%B9%8Bss%E5%91%BD%E4%BB%A4%2F</url>
      <content type="text"><![CDATA[ss简介ss是Socket Statistics的缩写。ss命令可以用来获取socket统计信息，它可以显示和netstat类似的内容。但ss的优势在于它能够显示更多更详细的有关TCP和连接状态的信息，而且比netstat更快速更高效。当服务器的socket连接数量变得非常大时，无论是使用netstat命令还是直接cat /proc/net/tcp，执行速度都会很慢。当服务器维持的连接达到上万个的时候，使用netstat等于浪费 生命，而用ss才是节省时间。 ss快的秘诀在于，它利用到了TCP协议栈中tcp_diag。tcp_diag是一个用于分析统计的模块，可以获得Linux 内核中第一手的信息，这就确保了ss的快捷高效。当然，如果你的系统中没有tcp_diag，ss也可以正常运行，只是效率会变得稍慢。（但仍然比 netstat要快。） 命令学习命令格式:ss [参数]ss [参数] [过滤] 命令功能：ss(Socket Statistics的缩写)命令可以用来获取 socket统计信息，此命令输出的结果类似于 netstat输出的内容，但它能显示更多更详细的 TCP连接状态的信息，且比 netstat 更快速高效。它使用了 TCP协议栈中 tcp_diag（是一个用于分析统计的模块），能直接从获得第一手内核信息，这就使得 ss命令快捷高效。在没有 tcp_diag，ss也可以正常运行。 命令参数：-h, –help 帮助信息-V, –version 程序版本信息-n, –numeric 不解析服务名称-r, –resolve 解析主机名-a, –all 显示所有套接字（sockets）-l, –listening 显示监听状态的套接字（sockets）-o, –options 显示计时器信息-e, –extended 显示详细的套接字（sockets）信息-m, –memory 显示套接字（socket）的内存使用情况-p, –processes 显示使用套接字（socket）的进程-i, –info 显示 TCP内部信息-s, –summary 显示套接字（socket）使用概况-4, –ipv4 仅显示IPv4的套接字（sockets）-6, –ipv6 仅显示IPv6的套接字（sockets）-0, –packet 显示 PACKET 套接字（socket）-t, –tcp 仅显示 TCP套接字（sockets）-u, –udp 仅显示 UCP套接字（sockets）-d, –dccp 仅显示 DCCP套接字（sockets）-w, –raw 仅显示 RAW套接字（sockets）-x, –unix 仅显示 Unix套接字（sockets）-f, –family=FAMILY 显示 FAMILY类型的套接字（sockets），FAMILY可选，支持 unix, inet, inet6, link, netlink-A, –query=QUERY, –socket=QUERY QUERY := {all|inet|tcp|udp|raw|unix|packet|netlink}[,QUERY]-D, –diag=FILE 将原始TCP套接字（sockets）信息转储到文件 -F, –filter=FILE 从文件中都去过滤器信息 FILTER : = [ state TCP-STATE ] [ EXPRESSION ] 常用范例例1：显示TCP连接ss -t -a 例2：显示 Sockets 摘要ss -s 列出当前的established, closed, orphaned and waiting TCP sockets 例3：列出所有打开的网络连接端口ss -l 例4：查看进程使用的socketss -pl 例5：找出打开套接字/端口应用程序ss -lp | grep 3306 例6：显示所有UDP Socketsss -u -a 例7：显示所有状态为established的SMTP连接ss -o state established ‘( dport = :smtp or sport = :smtp )’ 例8：显示所有状态为Established的HTTP连接ss -o state established ‘( dport = :http or sport = :http )’ 例9：列举出处于 FIN-WAIT-1状态的源端口为 80或者 443，目标网络为 193.233.7/24所有 tcp套接字ss -o state fin-wait-1 ‘( sport = :http or sport = :https )’ dst 193.233.7/24 例10：用TCP 状态过滤Sockets:ss -4 state FILTER-NAME-HEREss -6 state FILTER-NAME-HERE FILTER-NAME-HERE 可以代表以下任何一个：establishedsyn-sentsyn-recvfin-wait-1fin-wait-2time-waitclosedclose-waitlast-acklistenclosing all : 所有以上状态connected : 除了listen and closed的所有状态synchronized :所有已连接的状态除了syn-sentbucket : 显示状态为maintained as minisockets,如：time-wait和syn-recv.big : 和bucket相反. 例11：匹配远程地址和端口号ss dst ADDRESS_PATTERNss dst 192.168.1.5ss dst 192.168.119.113:httpss dst 192.168.119.113:smtpss dst 192.168.119.113:443 例12：匹配本地地址和端口号ss src ADDRESS_PATTERNss src 192.168.119.103ss src 192.168.119.103:httpss src 192.168.119.103:80ss src 192.168.119.103:smtpss src 192.168.119.103:25 例13：将本地或者远程端口和一个数比较ss dport OP PORTss sport OP PORT ss dport OP PORT 远程端口和一个数比较；ss sport OP PORT 本地端口和一个数比较。OP 可以代表以下任意一个:&lt;= or le : 小于或等于端口号&gt;= or ge : 大于或等于端口号&gt;== or eq : 等于端口号!= or ne : 不等于端口号&lt; or gt : 小于端口号&gt; or lt : 大于端口号 例14：ss 和 netstat 效率对比time netstat -attime ss 用time 命令分别获取通过netstat和ss命令获取程序和概要占用资源所使用的时间。在服务器连接数比较多的时候，netstat的效率完全没法和ss比。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[linux目录结构]]></title>
      <url>%2F2017%2F03%2F30%2Flinux%E7%9B%AE%E5%BD%95%E7%BB%93%E6%9E%84%2F</url>
      <content type="text"><![CDATA[linux目录结构简介当在使用Linux的时候，如果通过ls –l / 就会发现，在/下包含很多的目录，比如etc、usr、var、bin … … 等目录，而在这些目录中，我们进去看看，发现也有很多的目录或文件。文件系统在Linux下看上去就象树形结构，所以可以把文件系统的结构形象的称为 树形结构。文件系统的是用来组织和排列文件存取的，所以是可见的，在Linux中，可以通过ls等工具来查看其结构，在Linux系统中，我们见到的都是树形结构；比如操作系统安装在一个文件系统中，他表现为由/ 起始的树形结构。linux文件系统的最顶端是/，我们称/为Linux的root，也就是 Linux操作系统的文件系统。 Linux的文件系统的入口就是/，所有的目录、文件、设备都在/之下，/就是Linux文件系统的组织者，也是最上级的领导者。 目录结构学习目录定义成为四种交互作用的形态 ：四中类型:1. 可分享的：可以分享给其他系统挂载使用的目录，所以包括执行文件与用户的邮件等数据， 是能够分享给网络上其他主机挂载用的目录；2. 不可分享的：自己机器上面运作的装置文件或者是与程序有关的socket文件等， 由于仅与自身机器有关，所以当然就不适合分享给其他主机了。3. 不变的：有些数据是不会经常变动的，跟随着distribution而不变动。 例如函式库、文件说明文件、系统管理员所管理的主机服务配置文件等等；4. 可变动的：经常改变的数据，例如登录文件、一般用户可自行收受的新闻组等。 FHS针对目录树架构仅定义出三层目录底下应该放置什么数据而已，分别是底下这三个目录的定义：/ (root, 根目录)：与开机系统有关；/usr (unix software resource)：与软件安装/执行有关；/var (variable)：与系统运作过程有关。 一. 根目录 (/) 的意义与内容：根目录是整个系统最重要的一个目录，因为不但所有的目录都是由根目录衍生出来的， 同时根目录也与开机/还原/系统修复等动作有关。 由于系统开机时需要特定的开机软件、核心文件、开机所需程序、 函式库等等文件数据，若系统出现错误时，根目录也必须要包含有能够修复文件系统的程序才行。 因为根目录是这么的重要，所以在FHS的要求方面，他希望根目录不要放在非常大的分区， 因为越大的分区内你会放入越多的数据，如此一来根目录所在分区就可能会有较多发生错误的机会。因此FHS标准建议：根目录(/)所在分区应该越小越好， 且应用程序所安装的软件最好不要与根目录放在同一个分区内，保持根目录越小越好。 如此不但效能较佳，根目录所在的文件系统也较不容易发生问题。（根目录和Windows的C盘一个样）根据以上原因，FHS认为根目录(/)下应该包含如下子目录：事实上FHS针对根目录所定义的标准就仅限于上表，不过仍旧有些目录也需要了解一下，具体如下： 除了这些目录的内容之外，另外要注意的是，因为根目录与开机有关，开机过程中仅有根目录会被挂载， 其他分区则是在开机完成之后才会持续的进行挂载的行为。就是因为如此，因此根目录下与开机过程有关的目录， 就不能够与根目录放到不同的分区去。有底下这些：/etc：配置文件/bin：重要执行档/dev：所需要的装置文件/lib：执行档所需的函式库与核心所需的模块/sbin：重要的系统执行文件五个目录千万不可与根目录分开在不同的分区。 二. /usr 的意义与内容：依据FHS的基本定义，/usr里面放置的数据属于可分享的与不可变动的，如果你知道如何透过网络进行分区的挂载(例如在服务器篇会谈到的NFS服务器)，那么/usr确实可以分享给局域网络内的其他主机来使用。/usr不是user的缩写，其实usr是Unix Software Resource的缩写， 也就是Unix操作系统软件资源所放置的目录，而不是用户的数据。 FHS建议所有软件开发者，应该将他们的数据合理的分别放置到这个目录下的次目录，而不要自行建立该软件自己独立的目录。因为是所有系统默认的软件(distribution发布者提供的软件)都会放置到/usr底下，因此这个目录有点类似Windows 系统的C:\Windows\ + C:\Program files\这两个目录的综合体，系统刚安装完毕时，这个目录会占用最多的硬盘容量。 一般来说，/usr的次目录建议有底下这些： 三. /var 的意义与内容如果/usr是安装时会占用较大硬盘容量的目录，那么/var就是在系统运作后才会渐渐占用硬盘容量的目录。 因为/var目录主要针对常态性变动的文件，包括缓存(cache)、登录档(log file)以及某些软件运作所产生的文件， 包括程序文件(lock file, run file)，或者例如MySQL数据库的文件等等。常见的次目录有：由于FHS仅是定义出最上层(/)及次层(/usr, /var)的目录内容应该要放置的文件或目录数据， 因此，在其他次目录层级内，就可以随开发者自行来配置了。 四. 目录树(directory tree)在Linux底下，所有的文件与目录都是由根目录开始的。那是所有目录与文件的源头, 然后再一个一个的分支下来，因此，我们也称这种目录配置方式为：目录树(directory tree), 这个目录树的主要特性有：目录树的启始点为根目录 (/, root)；每一个目录不止能使用本地端的 partition 的文件系统，也可以使用网络上的 filesystem 。举例来说， 可以利用 Network File System (NFS) 服务器挂载某特定目录等。每一个文件在此目录树中的文件名(包含完整路径)都是独一无二的。如果我们将整个目录树以图的方法来显示，并且将较为重要的文件数据列出来的话，那么目录树架构就如下图 五. 绝对路径与相对路径除了需要特别注意的FHS目录配置外，在文件名部分也要特别注意。因为根据档名写法的不同，也可将所谓的路径(path)定义为绝对路径(absolute)与相对路径(relative)。 这两种文件名/路径的写法依据是这样的：绝对路径：由根目录(/)开始写起的文件名或目录名称， 例如 /home/dmtsai/.bashrc；相对路径：相对于目前路径的文件名写法。 例如 ./home/dmtsai 或 http://www.cnblogs.com/home/dmtsai/ 等等。反正开头不是 / 就属于相对路径的写法必须要了解，相对路径是以你当前所在路径的相对位置来表示的。举例来说，你目前在 /home 这个目录下， 如果想要进入 /var/log 这个目录时，可以怎么写呢？cd /var/log (absolute)cd ../var/log (relative)因为你在 /home 底下，所以要回到上一层 (../) 之后，才能继续往 /var 来移动的，特别注意这两个特殊的目录：. ：代表当前的目录，也可以使用 ./ 来表示；.. ：代表上一层目录，也可以 ../ 来代表。这个 . 与 .. 目录概念是很重要的，你常常会看到 cd .. 或 ./command 之类的指令下达方式， 就是代表上一层与目前所在目录的工作状态。实例1：如何先进入/var/spool/mail/目录，再进入到/var/spool/cron/目录内？命令：cd /var/spool/mailcd ../cron说明：由于/var/spool/mail与/var/spool/cron是同样在/var/spool/目录中。如此就不需要在由根目录开始写起了。实例2：网络文件常常提到类似./run.sh之类的数据，这个指令的意义为何？说明：由于指令的执行需要变量的支持，若你的执行文件放置在本目录，并且本目录并非正规的执行文件目录(/bin, /usr/bin等为正规)，此时要执行指令就得要严格指定该执行档。./代表本目录的意思，所以./run.sh代表执行本目录下， 名为run.sh的文件。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[linux终端设备-基本类型]]></title>
      <url>%2F2017%2F03%2F30%2Flinux%E7%BB%88%E7%AB%AF%E8%AE%BE%E5%A4%87%E5%AD%A6%E4%B9%A0%E2%80%94%E5%9F%BA%E6%9C%AC%E7%B1%BB%E5%9E%8B%2F</url>
      <content type="text"><![CDATA[linux终端设备类型linux下有多种终端设备类型，包括当前终端，前台控制终断，串口以及虚拟终端主设备。可在linux的/proc/tty下查看各设备的基本信息。将这些终端设备统一由TTY管理，从而屏蔽硬件实现。同时，将所有的设备分别映射成一个文件（设备文件）。因此，可由文件管理函数IO函数操作这些文件，达到控制终端设备的目的。 实际的物理串口串口终端/dev/ttyS[n],ttyS系列指物理串行接口，即ttyS0为COM1,ttyS1为COM2。在/sys下的主次设备号如下：即物理串口设备主设备好为4，次设备号从64开始。相关的资源信息： 可通过如下命令想串口发送数据：echo ttyS1&gt;/dev/ttyS1echo hello world &gt;/dev/ttys1虚拟机下：采用windows的文件来代替串口，然后在window下查看该文件内容。设置：虚拟机下的setting中设置add一个串口设备号（没有要再关机情况下添加）,添加后在底部图标可看到添加的串口号以及window下的文件。 控制台终端tty1-tty6为控制台终端，即非图像界面下的命令行输入模式。控制台终端设备主设备号为4，次设备号从1开始 虚拟终端当下多数使用linux都是通过网络连接到服务器的方式，如telent和ssh工具。如果是在服务器的图像界面下，运行命令一般会打开一个虚拟终端窗口。这两类情况在服务器上显示的是虚拟网络终端。虚拟网络终端有两个虚拟设备：/dev/ptmx和/dev/pts /dev/ptmx虚拟设备/dev/ptmx是一个字符文件，用于创建虚拟网络终端设备master/slave配对设备。要打开一个未使用的虚拟终端，通过调用posix_openpt()函数，来打开/dev/ptmx设备。每次open打开这个文件，返回一个独立的master设备的文件描述符，可通过这个描述符找到关联的slave设备，且slave设备会在/dev/pts/目录下创建。 /dev/pts虚拟终端通过网络telent到linux主机或者windows环境下打开一个终端，将在/dev/pts目录下依次创建一个虚拟终端设备，相应地退出一个虚拟终端，将自动减少一个设备文件。 当前终端当前控制台终端/dev/console/dev/console代表当前系统使用的实际控制台终端（tty1-tty6）。/dev/console设备号信息如下：其主设备号为5，次设备号为1.它始终代表当前主机打开的实际控制台终端 当前终端/dev/tty/dev/tty代表当前终端，无论是通过控制台终端还是虚拟终端，/dev/tty都代表自己。该设备信息如下：在任意终端下。如telent下连接终端执行，即向/dev/tty发送消息，会直接回显]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[linux读写串口]]></title>
      <url>%2F2017%2F03%2F30%2Flinux%E8%AF%BB%E5%86%99%E4%B8%B2%E5%8F%A3%2F</url>
      <content type="text"><![CDATA[串口操作串口操作需要的头文件 #include &lt;stdio.h&gt; #include &lt;stdlib.h&gt; #include &lt;unistd.h&gt; #include &lt;sys/types.h&gt; #include &lt;sys/stat.h&gt; #include &lt;fcntl.h&gt; #include &lt;termios.h&gt; #include &lt;errno.&gt; 打开串口在 Linux 下串口文件是位于 /dev 下的串口一 为 /dev/ttyS0串口二 为 /dev/ttyS1打开串口是通过使用标准的文件打开函数操作： int open_port(void) { int fd; fd = open( &quot;/dev/ttyS0&quot;, O_RDWR | O_NOCTTY ); if(-1 == fd) { perror(&quot; 提示错误！&quot;); } return (fd); } O_NOCTTY: 表示当前进程不期望与终端关联，从而避免控制端输入的信息影响当前进程 设置串口最基本的设置串口包括波特率设置，效验位和停止位设置。串口的设置主要是设置 struct termios 结构体的各成员值。 struct termio { unsigned short c_iflag; /* 输入模式标志 */ unsigned short c_oflag; /* 输出模式标志 */ unsigned short c_cflag; /* 控制模式标志*/ unsigned short c_lflag; /* local mode flags */ unsigned char c_line; /* line discipline */ unsigned char c_cc[NCC]; /* control characters */ }; 下面是修改波特率的代码： struct termios Opt; tcgetattr(fd, &amp;Opt); cfsetispeed(&amp;Opt,B19200); /*设置为19200Bps*/ cfsetospeed(&amp;Opt,B19200); tcsetattr(fd,TCANOW,&amp;Opt); 设置波特率的例子函数：/** *@brief 设置串口通信速率 *@param fd 类型 int 打开串口的文件句柄 *@param speed 类型 int 串口速度 *@return void */ int speed_arr[] = { B38400, B19200, B9600, B4800, B2400, B1200, B300, B38400, B19200, B9600, B4800, B2400, B1200, B300, }; int name_arr[] = {38400, 19200, 9600, 4800, 2400, 1200, 300, 38400, 19200, 9600, 4800, 2400, 1200, 300, }; void set_speed(int fd, int speed) { int i; int status; struct termios Opt; tcgetattr(fd, &amp;Opt); for ( i= 0; i &lt; sizeof(speed_arr) / sizeof(int); i++) { if (speed == name_arr[i]) { tcflush(fd, TCIOFLUSH); cfsetispeed(&amp;Opt, speed_arr[i]); cfsetospeed(&amp;Opt, speed_arr[i]); status = tcsetattr(fd1, TCSANOW, &amp;Opt); if (status != 0) { perror(&quot;tcsetattr fd1&quot;); return; } tcflush(fd,TCIOFLUSH); } } } 效验位和停止位的设置：无效验 8位 Option.c_cflag &amp;= ~PARENB; Option.c_cflag &amp;= ~CSTOPB; Option.c_cflag &amp;= ~CSIZE; Option.c_cflag |= ~CS8; 奇效验(Odd) 7位 Option.c_cflag |= ~PARENB; Option.c_cflag &amp;= ~PARODD; Option.c_cflag &amp;= ~CSTOPB; Option.c_cflag &amp;= ~CSIZE; Option.c_cflag |= ~CS7; 偶效验(Even) 7位 Option.c_cflag &amp;= ~PARENB; Option.c_cflag |= ~PARODD; Option.c_cflag &amp;= ~CSTOPB; Option.c_cflag &amp;= ~CSIZE; Option.c_cflag |= ~CS7; Space效验 7位 Option.c_cflag &amp;= ~PARENB; Option.c_cflag &amp;= ~CSTOPB; Option.c_cflag &amp;= &amp;~CSIZE; Option.c_cflag |= CS8; 设置效验的函数： 需要注意的是:如果不是开发终端之类的，只是串口传输数据，而不需要串口来处理，那么使用原始模式(Raw Mode)方式来通讯。设置方式如下： options.c_lflag &amp;= ~(ICANON | ECHO | ECHOE | ISIG); /*Input*/ options.c_oflag &amp;= ~OPOST; /*Output*/ 读写串口设置好串口之后，把串口当作文件读写。发送数据 char buffer[1024]; int Length;int nByte; nByte = write(fd, buffer ,Length) 读取串口数据使用文件操作read函数读取，如果设置为原始模式(Raw Mode)传输数据，那么read函数返回的字符数是实际串口收到的字符数。可以使用操作文件的函数来实现异步读取，如fcntl，或者select等来操作。 char buff[1024];int Len;int readByte = read(fd,buff,Len); 关闭串口关闭串口就是关闭文件。 close(fd);]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[linux命令学习之exec命令]]></title>
      <url>%2F2017%2F03%2F30%2Flinu%E5%91%BD%E4%BB%A4%E5%AD%A6%E4%B9%A0-find%E4%B9%8Bexec%E5%91%BD%E4%BB%A4%2F</url>
      <content type="text"><![CDATA[find之exec简介find一般查找文件，进一步的操作由exec完成。 使用find时，只要把想要的操作写在一个文件里，就可以用exec来配合find查找 命令学习exec解释：-exec 参数后面跟的是command命令，它的终止是以;为结束标志的，考虑到各个系统中分号会有不同的意义，前面加反斜杠。{} 花括号代表前面find查找出来的文件名。在有些操作系统中只允许-exec选项执行诸如l s或ls -l这样的命令。大多数用户使用这一选项是为了查找旧文件并删除它们。建议在真正执行rm命令删除文件之前，最好先用ls命令看一下，确认它们是所要删除的文件exec选项后面跟随着所要执行的命令或脚本，然后是一对儿{ }，一个空格和一个\，最后是一个分号。 为了使用exec选项，必须要同时使用print选项。如果验证一下find命令，会发现该命令只输出从当前路径起的相对路径及文件名。 常用范例例1：ls -l命令放在find命令的-exec选项中find . -type f -exec ls -l {} \;find命令匹配到了当前目录下的所有普通文件，并在-exec选项中使用ls -l命令将它们列出。 例2：在目录中查找更改时间在n日以前的文件并删除它们find . -type f -mtime +14 -exec rm {} \; 例3：在目录中查找更改时间在n日以前的文件并删除它们，在删除之前先给出提示find . -name “*.log” -mtime +5 -ok rm {} \; 例4：-exec中使用grep命令find /etc -name “passwd“ -exec grep “root” {} \;find命令首先匹配所有文件名为“ passwd”的文件，例如passwd、passwd.old、passwd.bak，然后执行grep命令看看在这些文件中是否存在一个root用户。 例5：查找文件移动到指定目录find . -name “*.log” -exec mv {} .. \; 例6：用exec选项执行cp命令find . -name “*.log” -exec cp {} test3 \;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[linux命令学习之文件查找命令——find-exec命令]]></title>
      <url>%2F2017%2F03%2F30%2Flinu%E5%91%BD%E4%BB%A4%E5%AD%A6%E4%B9%A0-%E6%96%87%E4%BB%B6%E6%9F%A5%E6%89%BE%E4%B9%8Bfind-exec%E5%91%BD%E4%BB%A4%2F</url>
      <content type="text"><![CDATA[find之exec简介find一般查找文件，进一步的操作由exec完成。 使用find时，只要把想要的操作写在一个文件里，就可以用exec来配合find查找 命令学习exec解释：-exec 参数后面跟的是command命令，它的终止是以;为结束标志的，考虑到各个系统中分号会有不同的意义，前面加反斜杠。{} 花括号代表前面find查找出来的文件名。在有些操作系统中只允许-exec选项执行诸如l s或ls -l这样的命令。大多数用户使用这一选项是为了查找旧文件并删除它们。建议在真正执行rm命令删除文件之前，最好先用ls命令看一下，确认它们是所要删除的文件exec选项后面跟随着所要执行的命令或脚本，然后是一对儿{ }，一个空格和一个\，最后是一个分号。 为了使用exec选项，必须要同时使用print选项。如果验证一下find命令，会发现该命令只输出从当前路径起的相对路径及文件名。 常用范例例1：ls -l命令放在find命令的-exec选项中find . -type f -exec ls -l {} \;find命令匹配到了当前目录下的所有普通文件，并在-exec选项中使用ls -l命令将它们列出。例2：在目录中查找更改时间在n日以前的文件并删除它们find . -type f -mtime +14 -exec rm {} \; 例3：在目录中查找更改时间在n日以前的文件并删除它们，在删除之前先给出提示find . -name “*.log” -mtime +5 -ok rm {} \; 例4：-exec中使用grep命令find /etc -name “passwd“ -exec grep “root” {} \;find命令首先匹配所有文件名为“ passwd”的文件，例如passwd、passwd.old、passwd.bak，然后执行grep命令看看在这些文件中是否存在一个root用户。 例5：查找文件移动到指定目录find . -name “*.log” -exec mv {} /home/jiangbiao/Test/test4 \; 例6：用exec选项执行cp命令find . -name “*.log” -exec cp {} /home/jiangbiao/Test/test3 \;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[linux命令学习之文件查找命令——find-exec命令]]></title>
      <url>%2F2017%2F03%2F30%2Flinu%E5%91%BD%E4%BB%A4%E5%AD%A6%E4%B9%A0-%E6%96%87%E4%BB%B6%E6%9F%A5%E6%89%BE%E4%B9%8Bfind-xargs%E5%91%BD%E4%BB%A4%2F</url>
      <content type="text"><![CDATA[find之xargs简介在使用 find命令的-exec选项处理匹配到的文件时， find命令将所有匹配到的文件一起传递给exec执行。但有些系统对能够传递给exec的命令长度有限制，这样在find命令运行几分钟之后，就会出现溢出错误。错误信息通常是“参数列太长”或“参数列溢出”。这就是xargs命令的用处所在，特别是与find命令一起使用。find命令把匹配到的文件传递给xargs命令，而xargs命令每次只获取一部分文件而不是全部，这样它可以先处理最先获取的一部分文件，然后是下一批，并如此继续下去。在有些系统中，使用-exec选项会为处理每一个匹配到的文件而发起一个相应的进程，并非将匹配到的文件全部作为参数一次执行；这样在有些情况下就会出现进程过多，系统性能下降的问题，因而效率不高； 而使用xargs命令则只有一个进程。另外，在使用xargs命令时，究竟是一次获取所有的参数，还是分批取得参数，以及每一次获取参数的数目都会根据该命令的选项及系统内核中相应的可调参数来确定。 命令学习-0 当sdtin含有特殊字元时候，将其当成一般字符，/‘空格等-a file 从文件中读入作为sdtin-e flag ，注意有的时候可能会是-E，flag必须是一个以空格分隔的标志，当xargs分析到含有flag这个标志的时候就停止。-p 当每次执行一个argument的时候询问一次用户。-n num 后面加次数，表示命令在执行的时候一次用的argument的个数，默认是用所有的。-t 表示先打印命令，然后再执行。-i 或者是-I，这得看linux支持了，将xargs的每项名称，一般是一行一行赋值给{}，可以用{}代替。-r no-run-if-empty 当xargs的输入为空的时候则停止xargs，不用再去执行了。-s num 命令行的最好字符数，指的是xargs后面那个命令的最大命令行字符数。-L num Use at most max-lines nonblank input lines per command line.-s是含有空格的。-l 同-L-d delim 分隔符，默认的xargs分隔符是回车，argument的分隔符是空格，这里修改的是xargs的分隔符-x exit的意思，主要是配合-s使用。-P 参数会提示让你确认是否执行后面的命令,y执行，n不执行。 常用范例例1： 查找系统中的每一个普通文件，然后使用xargs命令来测试它们分别属于哪类文件find . -type f -print | xargs file 例2:在当前目录下查找所有用户具有读、写和执行权限的文件，并收回相应的写权限find . -perm -7 -print | xargs chmod o-w 例3：用grep命令在所有的普通文件中搜索in这个词find . -type f -print | xargs grep “in” 例4：用grep命令在当前目录下的所有普通文件中搜索hostnames这个词find . -name * -type f -print | xargs grep “hostnames”\用来取消find命令中的*在shell中的特殊含义。 例5：使用xargs执行mvfind . -name “*.log” | xargs -i mv {} test5将当前目录下.log文件移到test5目录下 例6：find后执行xargs提示xargs: argument line too long解决方法find . -type f -atime +0 -print0 | xargs -0 -l1 -t rm -f-l1是一次处理一个；-t是处理之前打印出命令 例7：xargs的-p参数的使用-p参数会提示让你确认是否执行后面的命令,y执行，n不执行。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[linux终端设备-终端属性termios]]></title>
      <url>%2F2017%2F03%2F30%2Flinux%E7%BB%88%E7%AB%AF%E8%AE%BE%E5%A4%87%E5%AD%A6%E4%B9%A0%E2%80%94%E7%BB%88%E7%AB%AF%E5%B1%9E%E6%80%A7termios%E7%BB%93%E6%9E%84%E4%BD%93%2F</url>
      <content type="text"><![CDATA[termios结构体简介 为便于用户层统一管理终端属性，linux使用termios结构体来统一管理struct termios{ unsigned short c_iflag; / 输入模式标志/ unsigned short c_oflag; / 输出模式标志/ unsigned short c_cflag; / 控制模式标志/ unsigned short c_lflag; /区域模式标志或本地模式标志或局部模式/ unsigned char c_line; /行控制line discipline / unsigned char c_cc[NCC]; / 控制字符特性/};可以调用函数tcgetattr来初始化一个终端对应的termios结构，该函数的原型如下： #include&lt;termios.h&gt; int tcgetattr(int fd, struct termios *termios_p); 这个函数调用获取fd所指向的当前终端对象fd的相关属性，并写入termios_p参数指向的结构。 通过调用函数tcsetattr来重新配置某个终端的属性，函数原型如下： #include&lt;termios.h&gt; int tcsetattr(int fd , int actions , const struct termios *termios_h); 函数根据actions所指示的行为来设置与fp所指向的终端设备的属性参数actions控制修改方式，共有三种修改方式，如下所示。1.TCSANOW：立刻对值进行修改2.TCSADRAIN：等当前的输出完成后再对值进行修改。3.TCSAFLUSH：等当前的输出完成之后，再对值进行修改，但丢弃还未从read调用返回的当前的可用的任何输入。 五种模式标志 输入模式标志c_iflag输入模式控制输入数据在传递给程序之前的处理方式。通过设置termios结构中的c_iflag成员的标志对它们进行控制。所有的标志都被定义为宏,并可通过按位或的方式结合起来。可用于c_iflag成员的宏如下所示：BRKINT：当在输入行中检测到一个终止状态时，产生一个中断。TGNBRK：忽略输入行中的终止状态。TCRNL：将接受到的回车符转换为新行符。TGNCR：忽略接受到的新行符。INLCR：将接受到的新行符转换为回车符。IGNPAR：忽略奇偶校检错误的字符。INPCK：对接收到的字符执行奇偶校检。PARMRK：对奇偶校检错误作出标记。ISTRIP：将所有接收的字符裁减为7比特。IXOFF：对输入启用软件流控。IXON：对输出启用软件流控。 注意：如果BRKINT和TGNBRK标志都未被设置，则输入行中的终止状态就被读取为NULL（0X00）字符。对于PARKMRK如果没有设置IGNPAR,在有奇偶校验错误的字符前插入\337\0如果没有设置IGNPAR也没有设置PARMRK，将有奇偶校验错误或帧错误的字符视为/0对于BRKINT,如果设置了IGNBRK,将忽略BREAK,如果没有设置，但是设置了BRKINT,那么BREAK将使得输入和输出队列被刷新。如果终端是一个前台进程组的控制终端，这个进程组所有进程将收到SIGINT信号。如果既未设置IGNBRK也为设置BRKINT,BRKINT将视为与NUL字符同意。除非设置了PARMRK，这种情况下被视为序列/337/0/0 输出模式标志c_oflag输出模式控制输出字符的处理方式,即由程序发出的字符在传递到串行口或屏幕之前如何处理.通过设置c_oflag成员的标识对输出模式进行控制.可用于c_iflag成员的宏如下所示（部分）：OPSOT:打开输出处理功能OLCUC:将输出的小写字母映射为大写字母ONLCR:将输出中的换行符转换为回车符OCRNL:将回车符转换为换行符ONOCR:第０行不输出回车符ONLRET:不输出回车符NLDLY:换行符延时选择CRDLY:回车符延时TABDLY:制表符延时 控制模式标志c_cflag控制模式控制终端的硬件特性,通过c_cflag成员标识配置. 包括：波特率，数据位长度，停止位长度，奇偶校验位等CBAUD ：(不属于 POSIX) 波特率掩码 (4+1 位)。CSIZE：字符长度掩码（传送或接收字元时用的位数）。 取值为CS5（传送或接收字元时用5bits）, CS6, CS7, 或 CS8。CSTOPB ：设置两个停止位，而不是一个。CREAD ：打开接受者。PARENB ：允许输出产生奇偶信息以及输入的奇偶校验（启用同位产生与侦测）。PARODD ：输入和输出是奇校验（使用奇同位而非偶同位）。HUPCL ：在最后一个进程关闭设备后，降低 modem 控制线 (挂断)。CLOCAL ：忽略 modem 控制线。LOBLK :(不属于 POSIX) 从非当前 shell 层阻塞输出。CIBAUD :(不属于 POSIX) 输入速度的掩码。CIBAUD 各位的值与CBAUD 各位相同，左移了 IBSHIFT 位。CRTSCTS :(不属于 POSIX) 启用 RTS/CTS (硬件) 流控制 设置波特率波特率即调制速率，指信号被调制以后在单位时间内的变化。即单位时间内载波参数变化的次数。为了减少用户编程负担，函数cfgetospeed()将获取存储于struct stermios结构中的输出波特率属性函数cfgetispeed()将获取存储于struct stermios结构中的输入波特率属性，不需要自己进行位操作。函数cfsetospeed()和cfsetispeed分别设置存储于termios结构的输出和输入波特率。cfsetspeed()可以同时设置termios结构的输入和输出波特率。例子：struct termios options;tcgetattr(fd,&amp;options);cfsetispeed(&amp;options,B19200); //输入波特率19200cfsetospeed(&amp;options,B19200); //输出波特率19200options.c_cflag | =(CLOCAL | CREAD ); //允许接收，本地模式tcsetattr(fd,TCSANOW,&amp;options); //生效时间立即生效 设置帧数据位宽度终端可以设置为每帧数据位为5，6，7,8bit。修改数据位宽度如下：options.c_cflag &amp;=~CSIZE; //清除现在数据位宽度options.c_cflag ｜＝CS8; //设置为每帧8bit 设置奇偶校验奇偶校验是串行通信所采用的简单的差错检测方式。例子：设置为8N1，即每帧数据位8bit，无奇偶校验，一位停止位options.c_cflag &amp; =~PARENG;options.c_cflag &amp; =~CSTOPB;options.c_cflag &amp; =~CSIZE;options.c_cflag &amp; =~CS8； 本地模式标志c_lflag本地模式标志用来管理用何种方式输入字符，一般设置为标准模式或者原始模式。标准模式：回显由客户端完成，用户输入的字符先缓存到一个缓存区，直到用户输入回车或者换行才发送到服务端原始模式：又称为字符模式，回显由服务端完成。用户输入的一个字符立即发送到服务端，服务端然后将该字符回显到客户端。ISIG ： 当输入INTR、QUIT、SUSP或DSUSP时，产生相应的信号ICANON ： 使用标准输入模式XCASE ： 在ICANON和XCASE同时设置的情况下，终端只使用大写。如果只设置了XCASE，则输入字符将被转换为小写字符，除非字符使用了转义字符（非POSIX，且Linux不支持该参数）ECHO ： 显示输入字符ECHOE ： 如果ICANON同时设置，ERASE将删除输入的字符，WERASE将删除输入的单词ECHOK ： 如果ICANON同时设置，KILL将删除当前行ECHONL ： 如果ICANON同时设置，即使ECHO没有设置依然显示换行符ECHOPRT： 如果ECHO和ICANON同时设置，将删除打印出的字符（非POSIX）TOSTOP ： 向后台输出发送SIGTTOU信号 控制字符标志c_cc[NCCS]标准模式和非标准模式下,c_cc数组的下标有不同的值:标准模式:VEOF:ＥＯＦ字符VEOL:ＥＯＬ字符VERASE:ERASE字符VINTR:INTR字符VKILL:KILL字符VQUIT:QUIT字符VSTART:START字符VSTOP:STOP字符非标准模式:VINTR:INTR字符VMIN:MIN值VQUIT:QUIT字符VSUSP:SUSP字符VTIME:TIME值VSTART:START字符VSTOP:STOP字符 字符INTR:该字符使终端驱动程序向与终端相连的进程以送SIGINT信号QUIT:该字符使终端驱动程序向与终端相连的进程发送SIGQUIT信号EOF;该字符使终端驱动程序将输入行中的全部字符传递给正在读取输入的应用程序.如果输入行为空,read调用将返回０,就好像在文件尾调用read一样 TIME和MIN值 这两个值只用于非标准模式,两者结合共同控制对输入的读取方式,还能控制在一个程序试图与一个终端关联的文件描述符时将发生的情况MIN = 0, TIME = 0时:read立即返回,如果有待处理的字符,它们就会被返回,如果没有,read调用返回0,且不读取任何字符MIN = 0, TIME &gt; 0时:有字符处理或经过TIME个0.1秒后返回MIN &gt; 0, TIME = 0时:read一直等待,直到有ＭＩＮ个字符可以读取,返回值是字符的数量.到达文件尾时返回0MIN &gt; 0, TIME &gt; 0时:read调用时,它会等待接收一个字符.在接收到第一个字符及其后续的每个字符后,启用一个字符间隔定时器.当有ＭＩＮ个字符可读或两字符间的时间间隔超进TIME个0.1秒时,read返回通过设置ＭＩＮ和ＴＩＭＥ值,我们可以逐个字符地对输入进行处理 其他函数这些函数直接作用于文件描述符,不需要读写termios结构:#include int tcdrain(int fd);让调用程序一直等待,直到所有排队的输出都发送完毕int tcflow(int, int flowtype);暂停或重新开始输出int tcflush(int fd, int in_out_selector);清空输入,输出或两者都清空]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[linux命令学习之文件查找命令——find参数详解]]></title>
      <url>%2F2017%2F03%2F30%2Flinu%E5%91%BD%E4%BB%A4%E5%AD%A6%E4%B9%A0-%E6%96%87%E4%BB%B6%E6%9F%A5%E6%89%BE%E4%B9%8Bfind%E5%8F%82%E6%95%B0%E8%AF%A6%E8%A7%A3%2F</url>
      <content type="text"><![CDATA[find参数范例1．使用name选项：文件名选项是find命令最常用的选项，要么单独使用该选项，要么和其他选项一起使用。 可以使用某种文件名模式来匹配文件，记住要用引号将文件名模式引起来。用户目录$HOME中查找文件名符合.log的文件，使用~作为 ‘pathname’参数，波浪号~代表了$HOME目录。find ~ -name “.log” -print 想要在当前目录及子目录中查找所有的”.log”文件find . -name “.log” -print 想要的当前目录及子目录中查找文件名以一个大写字母开头的文件find . -name “[A-Z]*” -print 想要在/etc目录中查找文件名以host开头的文件find /etc -name “host*” -print 要想让系统高负荷运行，就从根目录开始查找所有的文件find / -name “*” -print 想在当前目录查找文件名以一个个小写字母开头，最后是4到9加上.log结束的文件find . -name “[a-z]*[4-9].log” -print 2. 用perm选项：按照文件权限模式用-perm选项如在当前目录下查找文件权限位为755的文件，即文件属主可以读、写、执行，其他用户可以读、执行的文件find . -perm 755 -print 数字前面要加一个横杠-，表示都匹配，如-005表示至少005,-757至少757 3．忽略某个目录-prune：如果在查找文件时希望忽略某个目录，因为你知道那个目录中没有你所要查找的文件，那么可以使用-prune选项来指出需要忽略的目录。在使用-prune选项时要当心，因为如果你同时使用了-depth选项，那么-prune选项就会被find命令忽略。find [-path ..] [expression]在路径列表的后面的是表达式-path “test” -prune -o -print 是 -path “test” -a -prune -o -print 的简写表达式按顺序求值, -a 和 -o 都是短路求值，与 shell 的 &amp;&amp; 和 || 类似如果-path “test” 为真，则求值 -prune , -prune 返回真，与逻辑表达式为真；否则不求值 -prune，与逻辑表达式为假。如果 -path “test” -a -prune 为假，则求值 -print ，-print返回真，或逻辑表达式为真；否则不求值 -print，或逻辑表达式为真。这个表达式组合特例可以用伪码写为:if -path “test” then-pruneelse-print 查看Test目录下文件，但不希望在Test/test2目录下查找find Test -path “Test/test2” -prune -o -print 避开多个文件夹:find Test ( -path Test/test2 -o -path Test/test1 ) -prune -o -print圆括号表示表达式的结合。 \ 表示引用，即指示 shell 不对后面的字符作特殊解释，而留给 find 命令去解释其意义。 查找某一确定文件，-name等选项加在-o 之后find Test (-path Test/test2 -o -path test/test1 ) -prune -o -name “*.log” -print 5．使用user和nouser选项：按文件属主查找文件：在$HOME目录中查找文件属主为peida的文件find ~ -user username -print 在/etc目录下查找文件属主为peida的文件:命令：find /etc -user username -print 实例3：为了查找属主帐户已经被删除的文件，可以使用-nouser选项。在/home目录下查找所有的这类文件find /home -nouser -print这样就能够找到那些属主在/etc/passwd文件中没有有效帐户的文件。在使用-nouser选项时，不必给出用户名； find命令能够为你完成相应的工作。 6．使用group和nogroup选项：就像user和nouser选项一样，针对文件所属于的用户组， find命令也具有同样的选项。为了在/apps目录下查找属于gem用户组的文件，可以用：find /apps -group gem -print要查找没有有效所属用户组的所有文件，可以使用nogroup选项。下面的find命令从文件系统的根目录处查找这样的文件:find / -nogroup-print 7．按照更改时间或访问时间等查找文件：如果希望按照更改时间来查找文件，可以使用mtime,atime或ctime选项。如果系统突然没有可用空间了，很有可能某一个文件的长度在此期间增长迅速，这时就可以用mtime选项来查找这样的文件。用减号-来限定更改时间在距今n日以内的文件，而用加号+来限定更改时间在距今n日以前的文件。希望在系统根目录下查找更改时间在5日以内的文件，可以用：find / -mtime -5 -print为了在/var/adm目录下查找更改时间在3日以前的文件，可以用:find /var/adm -mtime +3 -print 8．查找比某个文件新或旧的文件：如果希望查找更改时间比某个文件新但比另一个文件旧的所有文件，可以使用-newer选项。它的一般形式为：newest_file_name ! oldest_file_name其中，！是逻辑非符号。 查找更改时间比文件1log新但比文件3.log旧的文件（包含3.log） 9．使用type选项：在当前目录下查找所有的目录find . -type d -print 在当前目录下查找除目录以外的所有类型的文件find . ! -type d -print 在当前目录下查找所有的符号链接文件find . -type l -print 10．使用size选项：可以按照文件长度来查找文件，这里所指的文件长度既可以用块（block）来计量，也可以用字节来计量。以字节计量文件长度的表达形式为数字加c结尾；以块计量文件长度只用数字表示即可。在按照文件长度查找文件时，一般使用这种以字节表示的文件长度，在查看文件系统的大小，因为这时使用块来计量更容易转换。 在当前目录下查找文件长度大于1 M字节的文件find . -size +1000000c -print 在当前目录下查找文件长度恰好为100字节的文件:find . -size 100c -print 在当前目录下查找长度超过10块的文件（一块等于512字节）find . -size +10 -print 11．使用depth选项：在使用find命令时，可能希望先匹配所有的文件，再在子目录中查找。使用depth选项就可以使find命令这样做。这样做的一个原因就是，当在使用find命令向磁带上备份文件系统时，希望首先备份所有的文件，其次再备份子目录中的文件。下面例子可以看出输出是相反的。 12．使用mount选项：在当前的文件系统中查找文件（不进入其他文件系统），可以使用find命令的mount选项。 从当前目录开始查找位于本文件系统中文件名以XC结尾的文件find . -name “*.XC” -mount -print]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[linux下telnet远程登入]]></title>
      <url>%2F2017%2F03%2F30%2Flinux%E4%B8%8Btelnet%E8%BF%9C%E7%A8%8B%E7%99%BB%E5%85%A5%2F</url>
      <content type="text"><![CDATA[telnet原理当用Telnet登录进入远程计算机系统时，事实上启动了两个程序，一个 叫Telnet客户程序，它运行在你的本地机上；另一个叫Telnet服务器程序，它运行在你要登录的远程计算机上。本地机上的客户程序要完成如下功能：1 、建立与服务器的TCP 联接；2 、从键盘上接收你输入的字符；3 、把你输入的字符串变成标准格式并送给远程服务器；4 、从远程服务器接收输出的信息；5 、把该信息显示在你的屏幕上。 远程计算机的“服务”程序通常被称为“精灵”，它平时不声不响地候在远程计算机上，一接到你的请求，就马上活跃起来，并完成如下功能：1 、通知你的计算机，远程计算机已经准备好了；2 、等候你输入命令；3 、对你的命令作出反应（如显示目录内容，或执行某个程序等）；4 、把执行命令的结果送回给你的计算机；5 、重新等候你的命令。 客户机上装一个telnet的客户端，服务器上装一个telnet的监听程序（精灵），一般这个监听程序监听的是23号端口。把这个过程简单抽象一下，就是客户端使用telnet工具发送一个命令到服务器端，服务器端监听到了之后就调用系统相关API来执行这些命令，从而达到了客户机远程操作服务器主机的目的。 这里需要注意一点，“把你输入的字符串变成标准格式并送给远程服务器”，指的是接受的字符，要按照一定的协议格式传送到服务器端，而这些字符是通过TCP连接传输的，跟Http有点像。Http是通过TCP连接传输字符，但是数据格式是HTTP协议规定的格式。简单来说，所谓的HTTP协议，FTP协议，SMTP协议，就是各自规定了以什么样的数据包方式在网络上通过TCP管道传输数据。 其实，telnet是以TCP为基础与服务器进行通信，所以它的功能远不止远程登录服务器（远程操纵服务器）。不管是什么协议，如果它基于 tcp/ip，那么你使用 TcpClient（或者 Socket）连接它，然后发点信息，依然能连通。Telnet可以看作是一种TCP的连接工具。 安装telnet在Ubuntu下的telnet服务需要安装xinetd服务和telnetd服务 apt-get install xinetd apt-get install telnetd 配置telnet1.gedit /etc/inetd.conf没有则添加如下注释依次为：服务名称。和xinetd一样，inetd通过查询/etc/service获得该服务的相关信息。套接口类型。TCP用stream，UDP用dgram。该服务使用的通信日志相关参数协议。inetd是否等到守护进程结束才继续接管端口。wait表示等待（相当于xinetd的wait = yes），nowait表示不等待，inetd每次接到一个请求就启动守护进程的新副本（相当于xinetd的wait = no）。运行该守护进程的用户身份。守护进程二进制文件的完整路径及其命令行参数 2.gedit /etc/xinetd.conf注释：instances = 60：表示最大连接进程数为60个。log_type = SYSLOG daemon info：表示使用syslog进行服务登记。log_on_success= HOST PID：表示设置成功后记录客户机的IP地址的进程ID。log_on_failure = HOST：表示设置失败后记录客户机的IP地址。cps = 25 30：表示每秒25个入站连接，如果超过限制，则等待30秒。主要用于对付拒绝服务攻击。 3.gedit /etc/xinetd.d/telnet注释：disable = no：表示启用这个服务。socket_type = stream：表示服务的数据包类型为stream。wait = no：表示不需等待，即服务将以多线程的方式运行。user = root：表示执行此服务进程的用户是root。server = /usr/bin/in.telnetd：启动程序的位置。log_on_failure += USERID：表示设置失败时，在/etc/xinetd.conf中设置的default值基础之上还把UID添加到系统登记表 重启xinetd 查看telnet状态 telnet端口telnet端口默认23，一般不做修改，在/etc/services中查看，如果需要从其他端口启动该服务，则可收到配置 telnet远程登入使用putty进行telnet远程登入，默认端口是23，主机IP是linux下的IP地址，通过ifconfig查看。 备注xinetd 配置参数 日志相关参数]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[linux下SSH服务]]></title>
      <url>%2F2017%2F03%2F30%2Flinux%E4%B8%8BSSH%E6%9C%8D%E5%8A%A1%E8%BF%9C%E7%A8%8B%E7%99%BB%E5%85%A5%2F</url>
      <content type="text"><![CDATA[SSH原理SSH 是目前较可靠，专为远程登录会话和其他网络服务提供安全性的协议。利用SSH 协议可以有效防止远程管理过程中的信息泄露问题。SSH最初是UNIX系统上的一个程序，后来又迅速扩展到其他操作平台。SSH在正确使用时可弥补网络中的漏洞。SSH客户端适用于多种平台。从客户端来看，SSH提供两种级别的安全验证：第一种级别是基于口令的安全验证只要你知道自己帐号和口令，就可以登录到远程主机。所有传输的数据都会被加密， 但是不能保证你正在连接的服务器就是你想连接的服务器。这个过程如下：1）远程主机收到用户的登录请求，把自己的公钥发给用户。2）用户使用这个公钥，将登录密码加密后，发送回来。3）远程主机用自己的私钥，解密登录密码，如果密码正确，就同意用户登录。这种方式可能会有别的服务器在冒充真正的服务器，将公钥发送给客户端，客户端就会将密码加密后发送给冒充的服务器，冒充的服务器就可以拿自己的私钥获取到密码，也就是受到“中间人”这种方式的攻击。当第一次链接远程主机时，会提示您当前主机的“公钥指纹”，询问您是否继续，如果选择继续后就可以输入密码进行登录了，当远程的主机接受以后，该台服务器的公钥就会保存到~/.ssh/known_hosts文件中。第二种级别是基于密匙的安全验证需要依靠密匙，也就是必须为自己创建一对密匙，并把公用密匙放在需要访问的服务器上。如果你要连接到SSH服务器上，客户端软件就会向服务器发出请求，请求用你的密匙进行安全验证。服务器收到请求之后，先在该服务器上你的主目录下寻找你的公用密匙，然后把它和你发送过来的公用密匙进行比较。如果两个密匙一致，服务器就用公用密匙加密“质询”并把它发送给客户端软件。客户端软件收到“质询”之后就可以用你的私人密匙解密再把它发送给服务器。用这种方式，你必须知道自己密匙的口令。 但是，与第一种级别相比，第二种级别不需要在网络上传送口令。第二种级别不仅加密所有传送的数据，而且“中间人”这种攻击方式也是不可能的（因为他没有你的私人密匙）。但是整个登录的过程可能需要10秒，但是相比输入密码的方式来说10秒也不长。 安装SSHsudo apt-get updatesudo apt-get openssh-server openssh-client 配置SSHsudo gedit /etc/ssh/sshd_config”该文件下是SSH的相关配置，包括端口22。如下，允许root用户登入 启动SSHsudo ps -e |grep ssh”–&gt;回车–&gt;有sshd,说明ssh服务已经启动如果没有启动，”sudo service ssh start”–&gt;回车–&gt;ssh服务就会启动 查看SSH状态 SSH远程登入使用putty进行ssh远程登入，默认端口22第一次登录的时候，OpenSSH将会提示用户它不知道这台登录的主机，只要键入“yes”，就会把这台登录主机的“识别标记”加到“~/.ssh/know_hosts”文件中。第二次访问这台主机的时候就不会再显示这条提示信息了。然后，SSH提示用户输入远程主机上用户账号的口令。这样，就建立了SSH连接，这之后就可以象使用telnet那样方便地使用SSH了。 秘钥登入秘钥登入不要每次登入输入密码， 使用通信短语即可。使用的是secureCRT1，快速链接-公钥-属性设置-创建身份文件 2，按照生成向导一步步完成这里选择OpneSSH格式通行短语类似于密码作用，在登入时会用到，如下： 3，完成后，将公钥传入要登入的服务器（linux）,可以采用虚拟机的文件共享方式。本地公钥在公钥文件名下可看到 4，在服务器段，建立要登入用户的.SSH文件mkdir -p ~/.ssh &amp;&amp; chmod -R 700 ~/.sshchmod -R 600 ~/.ssh/ authorized_keys 5，将公钥文件的内容复制到authorized_keys中去（可直接粘贴复制） 6，在secrueCRT下，将公钥放在最前面，输入主机名，用户名接下来会提示输入通信短语，输入确定即可]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[linux命令学习之文件压缩命令-gzip命令]]></title>
      <url>%2F2017%2F03%2F30%2Flinux%E5%91%BD%E4%BB%A4%E5%AD%A6%E4%B9%A0-%E6%96%87%E4%BB%B6%E5%8E%8B%E7%BC%A9%E4%B9%8Bgzip%E5%91%BD%E4%BB%A4%2F</url>
      <content type="text"><![CDATA[gzip简介 减少文件大小有两个明显的好处，一是可以减少存储空间，二是通过网络传输文件时，可以减少传输的时间。gzip是在Linux系统中经常使用的一个对文件进行压缩和解压缩的命令，既方便又好用。gzip不仅可以用来压缩大的、较少使用的文件以节省磁盘空间，还可以和tar命令一起构成Linux操作系统中比较流行的压缩文件格式。据统计，gzip命令对文本文件有60%～70%的压缩率。 命令学习命令格式：gzip[参数][文件或者目录]命令参数：-a或–ascii 使用ASCII文字模式。-c或–stdout或–to-stdout 把压缩后的文件输出到标准输出设备，不去更动原始文件。-d或–decompress或—-uncompress 解开压缩文件。-f或–force 强行压缩文件。不理会文件名称或硬连接是否存在以及该文件是否为符号连接。-h或–help 在线帮助。-l或–list 列出压缩文件的相关信息。-L或–license 显示版本与版权信息。-n或–no-name 压缩文件时，不保存原来的文件名称及时间戳记。-N或–name 压缩文件时，保存原来的文件名称及时间戳记。-q或–quiet 不显示警告信息。-r或–recursive 递归处理，将指定目录下的所有文件及子目录一并处理。-S&lt;压缩字尾字符串&gt;或—-suffix&lt;压缩字尾字符串&gt; 更改压缩字尾字符串。-t或–test 测试压缩文件是否正确无误。-v或–verbose 显示指令执行过程。-V或–version 显示版本信息。-num 用指定的数字num调整压缩的速度，-1或–fast表示最快压缩方法（低压缩比），-9或–best表示最慢压缩方法（高压缩比）。系统缺省值为6。 命令功能：gzip是个使用广泛的压缩程序，文件经它压缩过后，名称后面会多出”.gz”的扩展名。 常用范例例1：把test1目录下的每个文件压缩成.gz文件gzip *原文件会被打包，tar下-c选型会新建打包文件，原文件存在 例2：把每个压缩的文件解压，并列出详细的信息gzip -dv * 例3：详细显示每个压缩的文件的信息，并不解压gzip -l * 例4：压缩一个tar文件，此时压缩文件的扩展名为.tar.gzgzip -r log.tar 例5：递归的压缩目录gzip -rv test1test1下面的文件都变成了.gz，目录依然存在只是目录里面的文件相应变成了.gz. 例6：递归地解压目录gzip -dr test1]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[linux命令学习之文件打包解压命令-tar命令]]></title>
      <url>%2F2017%2F03%2F30%2Flinux%E5%91%BD%E4%BB%A4%E5%AD%A6%E4%B9%A0-%E6%96%87%E4%BB%B6%E6%89%93%E5%8C%85%E8%A7%A3%E5%8E%8B%E4%B9%8Btar%E5%91%BD%E4%BB%A4%2F</url>
      <content type="text"><![CDATA[tar简介tar命令可以为linux的文件和目录创建档案。利用tar，可以为某一特定文件创建档案（备份文件），也可以在档案中改变文件，或者向档案中加入新的文件。tar最初被用来在磁带上创建档案，现在，用户可以在任何设备上创建档案。利用tar命令，可以把一大堆的文件和目录全部打包成一个文件，这对于备份文件或将几个文件组合成为一个文件以便于网络传输是非常有用的。两个概念：打包和压缩。打包是指将一大堆文件或目录变成一个总的文件；压缩则是将一个大的文件通过一些压缩算法变成一个小文件。 Linux中很多压缩程序只能针对一个文件进行压缩，当你想要压缩一大堆文件时，得先将这一大堆文件先打成一个包（tar命令），然后再用压缩程序进行压缩（gzip bzip2命令）。linux下最常用的打包程序就是tar了，使用tar程序打出来的包我们常称为tar包，tar包文件的命令通常都是以.tar结尾的。生成tar包后，就可以用其它的程序来进行压缩。 命令学习命令格式：tar[必要参数][选择参数][文件]命令参数：必要参数有如下：-A 新增压缩文件到已存在的压缩-B 设置区块大小-c 建立新的压缩文件 -d 记录文件的差别-r 添加文件到已经压缩的文件-u 添加改变了和现有的文件到已经存在的压缩文件-x 从压缩的文件中提取文件 -t 显示压缩文件的内容-z 支持gzip解压文件-j 支持bzip2解压文件-Z 支持compress解压文件-v 显示操作过程-l 文件系统边界设置-k 保留原有文件不覆盖-m 保留文件不被覆盖-W 确认压缩文件的正确性 可选参数如下：-b 设置区块数目-C 切换到指定目录-f 指定压缩文件–help 显示帮助信息–version 显示版本信息 命令功能：用来压缩和解压文件。tar本身不具有压缩功能。他是调用压缩功能实现的 常见解压/压缩命令tar解包：tar xvf FileName.tar打包：tar cvf FileName.tar DirName（注：tar是打包，不是压缩！） .gz 解压1：gunzip FileName.gz解压2：gzip -d FileName.gz压缩：gzip FileName .tar.gz 和 .tgz解压：tar zxvf FileName.tar.gz压缩：tar zcvf FileName.tar.gz DirName .bz2解压1：bzip2 -d FileName.bz2解压2：bunzip2 FileName.bz2压缩： bzip2 -z FileName .tar.bz2解压：tar jxvf FileName.tar.bz2压缩：tar jcvf FileName.tar.bz2 DirName .bz解压1：bzip2 -d FileName.bz解压2：bunzip2 FileName.bz压缩：未知 .tar.bz解压：tar jxvf FileName.tar.bz压缩：未知 .Z解压：uncompress FileName.Z压缩：compress FileName .tar.Z解压：tar Zxvf FileName.tar.Z压缩：tar Zcvf FileName.tar.Z DirName .zip解压：unzip FileName.zip压缩：zip FileName.zip DirName .rar解压：rar x FileName.rar压缩：rar a FileName.rar DirName 常用范例例1：将文件全部打包成tar包tar -cvf log.tar log2012.logtar -zcvf log.tar.gz log2012.logtar -jcvf log.tar.bz2 log2012.logtar -cvf log.tar log2012.log 仅打包，不压缩！tar -zcvf log.tar.gz log2012.log 打包后，以 gzip 压缩tar -zcvf log.tar.bz2 log2012.log 打包后，以 bzip2 压缩在参数 f 之后的文件档名是自己取的，习惯上都用 .tar 来作为辨识。 如果加 z 参数，则 以 .tar.gz 或 .tgz 来代表 gzip 压缩过的 tar包； 如果加 j 参数，则以 .tar.bz2 来作为tar包名。 例2：查阅上述 tar包内有哪些文件tar -ztvf log.tar.gz由于使用 gzip 压缩的log.tar.gz，所以要查阅log.tar.gz包内的文件时，就得加上 z 这个参数。 例3：将tar 包解压缩tar -zxvf log.tar.gz 例4：只将 /tar 内的 部分文件解压出来tar -zxvf log.tar.gz 1.log 例5：文件备份下来，并且保存其权限(-p 的属性)tar -zcvpf log.tar.gz 1.log 2.log 3.log 例6：在 文件夹当中，比某个日期新的文件才备份tar -N “2012/11/13” -zcvf log.tar.gz test1 例7：备份文件夹内容是排除部分文件tar –exclude test1 -zcvf Test.tar.gz *除了test1外，其他都打包]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[linux命令学习之文件权限命令-chgrp命令]]></title>
      <url>%2F2017%2F03%2F30%2Flinux%E5%91%BD%E4%BB%A4%E5%AD%A6%E4%B9%A0-%E6%96%87%E4%BB%B6%E6%9D%83%E9%99%90%E4%B9%8Bchgrp%E5%91%BD%E4%BB%A4%2F</url>
      <content type="text"><![CDATA[chgrp简介 在lunix系统里，文件或目录的权限的掌控以拥有者及所属群组来管理。可以使用chgrp指令取变更文件与目录所属群组，这种方式采用群组名称或群组识别码都可以。Chgrp命令就是change group的缩写！要被改变的组名必须要在/etc/group文件内存在才行。 命令学习 命令格式：chgrp [选项] [组] [文件]命令功能：chgrp命令可采用群组名称或群组识别码的方式改变文件或目录的所属群组。使用权限是超级用户。命令参数：必要参数:-c 当发生改变时输出调试信息-f 不显示错误信息-R 处理指定目录以及其子目录下的所有文件-v 运行时显示详细的处理信息–dereference 作用于符号链接的指向，而不是符号链接本身–no-dereference 作用于符号链接本身选择参数:–reference=&lt;文件或者目录&gt;–help 显示帮助信息–version 显示版本信息 常用范例 例1：改变文件的群组属性chgrp -v test 1.log先建立test工作组，将1.log文件群组改为test群组例2：根据指定文件改变文件的群组属性chgrp –reference=1.log 2.log改变文件2.log 的群组属性，使得文件2.log的群组属性和参考文件1.log的群组属性相同例3：改变指定目录以及其子目录下的所有文件的群组属性chgrp -R test test1改变指定目录以及其子目录下的所有文件的群组属性 例4：通过群组识别码改变文件群组属性chgrp -R 1001 1.log通过群组识别码改变文件群组属性，1001为test群组的识别码，具体群组和群组识别码可以cat /etc/group查看]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[linux下FTP配置]]></title>
      <url>%2F2017%2F03%2F30%2Flinux%E4%B8%8Bftp%E9%85%8D%E7%BD%AE%2F</url>
      <content type="text"><![CDATA[FTP原理文件传输协议（FTP）是一种传统的网络协议，主要功能是实现服务器端与客户端直接的文件传送。FTP以TCP封装包的模式进行服务器与客户的连接，当连接建立后，使用者可以通过客户端程序连接服务器端，并进行文件的下载和上传。此外，还可以直接管理用户在服务器上的文件。 FTP功能1）不同等级的使用者。FTP预设情况下提供三种主要的身份：实体账号（real user）访客（guest）匿名登入者（anonymous）分成三种身份可以提高主机管理的便利性。例如，实体用户可以进行的动作比较多，而匿名登入者仅提供一个下载功能。 2）命令记录与登入文件记录。FTP可以利用系统的syslogd进行数据的记录。记录的数据包括了使用者曾经下达的命令与使用者传输的数据的记录 3）限制或解除使用者所在的根目录。为了避免使用者进入到linux系统的其他目录。这有利于提高系统的安全性。 FTP的用户类型匿名用户（anonymous）：常说的匿名登录，ftp服务器支持匿名登录时通常当用户匿名访问可以使用ftp/anoymous这两个用户匿名登录。本地用户(Real user)：这类用户是指在FTP服务上拥有帐号，账号名称，密码信息存放在passwd,shadow文件中。当这类用户登录FTP服务器的时候，其默认的主目录就是其帐号命名的目录。但是，其还可以变更到其他目录中去。虚拟用户(Guest)：使用独立的账号/密码数据文件，只能够访问自己的主目录。服务器通过这种方式来保障FTP服务上其他文件的安全性。 安装VSFTPDsudo apt-get install vsftpd 配置VSFTPD/etc/vsftpd.conf:主要配置文件：关于主机的设置：connect_from_port_20=YES ftp-data启动主动联机的port 20listen_port=20 ftp访问端口dirmessage_enable=YES 当使用者进入某个目录时，会显示该目录需要注意的内容。显示的文件预设是.messagewrite_enable=YES 是否允许使用者具有写入的权限idle_session_timeout=600 空闲会话的超时限制。默认600s.空闲600s后自动断开连接data_connection_timeout=120 数据超时限制，默认120s。 实体用户登入者的配置：local_enable=YES 实体用户允许登入local_umask=022 用户的权限（把本该是777权限的文件夹改为了755）如果注释了该参数，该参数会启用默认权限掩码077，那么上传的文件权限将会变为600，文件夹权限变为700chroot_local_user=YES 是否将使用者限制在自己的主目录中chroot_list_enable=YES 是否启用将某些实体用户限制在主目录chroot_list_fiel=/etc/vsftpd.chroot_list 被限制的实体用户主目录路径 匿名用户登入的配置anonymous_enable=YES 允许匿名用户登入anon_upload_enable=YES 允许匿名用户上传anon_mkdir_write_enable=YES 允许匿名用户创建文件夹deny_email_file=/etc/vsftpd.banned_emails 被拒绝的email地址async_abor_enable=YES 是否认可异步的ABOR命令xferlog_enable=YES 是否记录上传及下载日志xferlog_fiel=/ver/log/vsftpd.log 上传和下载日志路径xferlog_std_format=YES 是否设定为wu ftp相同的登入格式nopriv_user=ftpsecure 以nobody作为此一服务执行者的权限，安全性较高pam_service_name=vsftpd pam模块的名称 /etc/pam.d/vsftpd:pam模块进行身份确认/etc/ftpusers:限制使用的ftp用户列表/usr/shin/vsftpd:vsftpd的主要执行文件 重启VSFTPDudo service vsftpd restart 匿名用户登入在/etc/vsftpd.conf中配置允许匿名用户登入 （一般不允许） 实体用户登入在/etc/vsftpd.conf中配置运行实体用户登入]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[linux命令学习之文件目录命令-chown命令]]></title>
      <url>%2F2017%2F03%2F30%2Flinux%E5%91%BD%E4%BB%A4%E5%AD%A6%E4%B9%A0-%E6%96%87%E4%BB%B6%E6%9D%83%E9%99%90%E4%B9%8Bchown%E5%91%BD%E4%BB%A4%2F</url>
      <content type="text"><![CDATA[chown简介 chown将指定文件的拥有者改为指定的用户或组，用户可以是用户名或者用户ID；组可以是组名或者组ID； 文件是以空格分开的要改变权限的文件列表，支持通配符。系统管理员经常使用chown命令，在将文件拷贝到另一个用户的名录下之后，让用户拥有使用该文件的权限。 命令学习 命令格式： chown [选项] [所有者][:[组]] 文件… 命令功能：通过chown改变文件的拥有者和群组。在更改文件的所有者或所属群组时，可以使用用户名称和用户识别码设置。普通用户不能将自己的文件改变成其他的拥有者。其操作权限一般为管理员。 命令参数：必要参数:-c 显示更改的部分的信息-f 忽略错误信息-h 修复符号链接-R 处理指定目录以及其子目录下的所有文件-v 显示详细的处理信息-deference 作用于符号链接的指向，而不是链接文件本身 选择参数:–reference=&lt;目录或文件&gt; 把指定的目录/文件作为参考，把操作的文件/目录设置成参考文件/目录相同拥有者和群组–from=&lt;当前用户：当前群组&gt; 只有当前用户和群组跟指定的用户和群组相同时才进行改变–help 显示帮助信息–version 显示版本信息 常用范例 例1：改变拥有者和群组 chown root:jiangbiao 1.log当为root: 以及jiangbiao: 形式时，工作组默认与拥有者一样例3：改变文件群组 例4：改变指定目录以及其子目录下的所有文件的拥有者和群组chown -R -v root:test test1]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[linux命令学习之文件查找命令-locate命令]]></title>
      <url>%2F2017%2F03%2F30%2Flinux%E5%91%BD%E4%BB%A4%E5%AD%A6%E4%B9%A0-%E6%96%87%E4%BB%B6%E6%9F%A5%E6%89%BE%E4%B9%8Blocate%E5%91%BD%E4%BB%A4%2F</url>
      <content type="text"><![CDATA[locate简介locate让使用者可以很快速的搜寻档案系统内是否有指定的档案。其方法是先建立一个包括系统内所有档案名称及路径的数据库，之后当寻找时就只需查询这个数据库，而不必实际深入档案系统之中了。在一般的 distribution 之中，数据库的建立都被放在 crontab 中自动执行。 命令学习命令格式：Locate [选择参数] [样式] 命令功能：locate命令可以在搜寻数据库时快速找到档案，数据库由updatedb程序来更新，updatedb是由cron daemon周期性建立的，locate命令在搜寻数据库时比由整个由硬盘资料来搜寻资料来得快，但较差劲的是locate所找到的档案若是最近才建立或 刚更名的，可能会找不到，在内定值中，updatedb每天会跑一次，可以由修改crontab来更新设定值。(etc/crontab)locate指定用在搜寻符合条件的档案，它会去储存档案与目录名称的数据库内，寻找合乎范本样式条件的档案或目录录，可以使用特殊字元（如”” 或”?”等）来指定范本样式，如指定范本为kcpaner, locate会找出所有起始字串为kcpa且结尾为ner的档案或目录locate指令和find找寻档案的功能类似，但locate是透过update程序将硬盘中的所有档案和目录资料先建立一个索引数据库，在 执行loacte时直接找该索引，查询速度会较快，索引数据库一般是由操作系统管理，但也可以直接下达update强迫系统立即修改索引数据库。 命令参数：-e 将排除在寻找的范围之外。-1 如果是 1．则启动安全模式。在安全模式下，使用者不会看到权限无法看到的档案。这会使速度减慢，因为 locate 必须至实际的档案系统中取得档案的 权限资料。-f 将特定的档案系统排除在外，例如我们没有到理要把 proc 档案系统中的档案 放在资料库中。-q 安静模式，不会显示任何错误讯息。-n 至多显示 n个输出。-r 使用正规运算式 做寻找的条件。-o 指定资料库存的名称。-d 指定资料库的路径-h 显示辅助讯息-V 显示程式的版本讯息 常用范例例1:查找和pwd相关的所有文件locate pwd 例2： 搜索etc目录下所有以sh开头的文件locate /etc/sh 例3：搜索etc目录下，所有以m开头的文件locate /etc/m]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[linux命令学习之文件目录命令-tail命令]]></title>
      <url>%2F2017%2F03%2F30%2Flinux%E5%91%BD%E4%BB%A4%E5%AD%A6%E4%B9%A0-%E6%96%87%E4%BB%B6%E7%9B%AE%E5%BD%95%E4%B9%8Btail%E5%91%BD%E4%BB%A4%2F</url>
      <content type="text"><![CDATA[tail简介tail命令从指定点开始将文件写到标准输出。使用tail命令的-f选项可以方便的查阅正在改变的日志文件,tail -f filename会把filename里最尾部的内容显示在屏幕上,并且不但刷新,使你看到最新的文件内容. 命令学习命令格式：tail[必要参数][选择参数][文件]命令功能：用于显示指定文件末尾内容，不指定文件时，作为输入信息进行处理。常用查看日志文件。命令参数：-f 循环读取-q 不显示处理信息-v 显示详细的处理信息-c&lt;数目&gt; 显示的字节数-n&lt;行数&gt; 显示行数–pid=PID 与-f合用,表示在进程ID,PID死掉之后结束.-q, –quiet, –silent 从不输出给出文件名的首部-s, –sleep-interval=S 与-f合用,表示在每次反复的间隔休眠S秒 常用实例例1：显示文件末尾内容tail -n 5 1.log显示文件最后5行内容 例3：从第3行开始显示文件tail -n +5 1.log]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Hexo+github搭建个人博客（一）]]></title>
      <url>%2F2017%2F03%2F29%2Fhexo-github-one%2F</url>
      <content type="text"><![CDATA[简介Hexo 是一个快速、简洁且高效的静态站点生成框架，它基于 Node.js 。 它有以下特点： 超快速度：Node.js 所带来的超快生成速度，让上百个页面在几秒内瞬间完成渲染。 支持Markdown：Hexo 支持 GitHub Flavored Markdown 的所有功能，甚至可以整合 Octopress 的大多数插件。 一件部署：只需一条指令即可部署到Github Pages，或其他网站 丰富的插件：Hexo 拥有强大的插件系统，安装插件可以让 Hexo 支持 Jade,CoffeeScript。 安装准备工作安装 Hexo 相当简单。然而在安装前，您必须检查电脑中是否已安装下列应用程序: Node.jsGit 安装 Git Windows： git下载地址： 官网Download Now 安装：在Git Setup中选择Use Git from the windows Command Prompt,除此之外一路Next完成安装 安装 Node.js Windos:Node.js v0.12.5 x64 :下载地址： 百度云Download Now Node.js官网Download Now 安装：一路NExt即可，等待完成安装 ##软件验证运行窗口CMD,输入一下命令，会显示相应版本信息： git --version node -v npm -v申请GITHUB申请地址：Github方法简述： 申请账号（用户名+密码),并进行邮箱验证 创建repository，名字与用户名一致。例如我的用户名BlueSky-chamo,Repository name为BlueSky-chamo.github.io 在创建的repository中settings中的Github pages中选择theme,启用Github page## 安装 Hexohexo是基于node.js的静态博客，官网也是搭建在GitHub上安装方法： 新建文件夹blog,右键选择Git Bash 安装hexo为了避免出现被“墙”，使用淘宝NPM镜像npm install -g cnpm --registry=https://registry.npm.taobao.org 安装hexo:cnpm install -g hexo-clicnpm install hexo --save 验证：hexo -v 本地运行：初始化命令：hexo init安装生成器：cnpm install浏览器本地访问：hexo s,本地浏览器输入http://localhost:4000/即可本地访问 hexo基本管理目录结构12345678.├── _config.yml├── package.json├── scaffolds├── source| ├── _drafts| └── _posts└── _config.yml：站点配置文件，即博客基本设置source:资源文件，即自定义的页面与推送的博客文件 ###_config.yml文件关键配置： url: 博客地址，与github申请的repository一致 如：http://BlueSky-chamo.github.io theme: 博客主题。默认下为landscape deploy: 发布设置。两种方式如下，可自行选择repository: https://github.com/BlueSky-chamo/BlueSky-chamo.github.io.gitrepository: git@github.com:BlueSky-chamo/BlueSky-chamo.github.io.git source文件资源文件 新建文章hexo new &quot;hello&quot;2.新建页面hexo new page hello Github与hexo创建联系配置SSH KEY 生成SSH KEY：ssh-keygen -t rsa -C &quot;邮件地址@youremail.com&quot; 按提示输入密码后在C:\Documents and Settings\Administrator.ssh\id_rsa.pub文件的内容即为秘钥 登陆github系统，点击右上角的 Account Settings—&gt;SSH Public keys —&gt; add another public keys把你本地生成的密钥复制到里面（key文本框中） 设置git身份信息git config --global user.name &quot;你的用户名&quot;git config --global user.email &quot;你的邮箱&quot; 验证git信息SSH -T git@github.com 发布博客安装hexo git插件cnpm install hexo-deployer-git --save 发布更新博客hexo d -g ##参考零基础免费搭建个人博客]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Hexo+Github搭建个人博客（二）]]></title>
      <url>%2F2017%2F03%2F29%2Fhexo-github-two%2F</url>
      <content type="text"><![CDATA[安装NEXT主题下载主题Hexo 安装主题的方式非常简单，只需要将主题文件拷贝至站点目录的 themes 目录下， 然后修改下配置文件即可。 cd bloggit clone https://github.com/iissnan/hexo-theme-next themes/next 启用next主题在站点配置文件_config.yml中： theme: next 验证主题 hexo shttp://localhost:4000 NEXT主题设置Hexo 中有两份主要的配置文件，其名称都是 _config.yml 。其中，一份位于站点根目录下，主要包含 Hexo 本身的配置；另一份位于主题目录下，主要用于配置主题相关的选项。前者称为 站点配置文件，后者称为 主题配置文件 基本设置关于NEXT主题的基本设置可参考NEXT在线文档，包含NEXT主题的详细使用介绍。 其他设置添加High一下打开博客根目录 \themes\next\layout\_partials\header.swig ，在&lt;ul&gt; ... /ul&gt; 标签之间加入以下代码：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137&lt;li&gt; &lt;a title="把这个链接拖到你的Chrome收藏夹工具栏中" href='javascript:(function() &#123; function c() &#123; var e = document.createElement("link"); e.setAttribute("type", "text/css"); e.setAttribute("rel", "stylesheet"); e.setAttribute("href", f); e.setAttribute("class", l); document.body.appendChild(e) &#125; function h() &#123; var e = document.getElementsByClassName(l); for (var t = 0; t &lt; e.length; t++) &#123; document.body.removeChild(e[t]) &#125; &#125; function p() &#123; var e = document.createElement("div"); e.setAttribute("class", a); document.body.appendChild(e); setTimeout(function() &#123; document.body.removeChild(e) &#125;, 100) &#125; function d(e) &#123; return &#123; height : e.offsetHeight, width : e.offsetWidth &#125; &#125; function v(i) &#123; var s = d(i); return s.height &gt; e &amp;&amp; s.height &lt; n &amp;&amp; s.width &gt; t &amp;&amp; s.width &lt; r &#125; function m(e) &#123; var t = e; var n = 0; while (!!t) &#123; n += t.offsetTop; t = t.offsetParent &#125; return n &#125; function g() &#123; var e = document.documentElement; if (!!window.innerWidth) &#123; return window.innerHeight &#125; else if (e &amp;&amp; !isNaN(e.clientHeight)) &#123; return e.clientHeight &#125; return 0 &#125; function y() &#123; if (window.pageYOffset) &#123; return window.pageYOffset &#125; return Math.max(document.documentElement.scrollTop, document.body.scrollTop) &#125; function E(e) &#123; var t = m(e); return t &gt;= w &amp;&amp; t &lt;= b + w &#125; function S() &#123; var e = document.createElement("audio"); e.setAttribute("class", l); e.src = i; e.loop = false; e.addEventListener("canplay", function() &#123; setTimeout(function() &#123; x(k) &#125;, 500); setTimeout(function() &#123; N(); p(); for (var e = 0; e &lt; O.length; e++) &#123; T(O[e]) &#125; &#125;, 15500) &#125;, true); e.addEventListener("ended", function() &#123; N(); h() &#125;, true); e.innerHTML = " &lt;p&gt;If you are reading this, it is because your browser does not support the audio element. We recommend that you get a new browser.&lt;/p&gt; &lt;p&gt;"; document.body.appendChild(e); e.play() &#125; function x(e) &#123; e.className += " " + s + " " + o &#125; function T(e) &#123; e.className += " " + s + " " + u[Math.floor(Math.random() * u.length)] &#125; function N() &#123; var e = document.getElementsByClassName(s); var t = new RegExp("\\b" + s + "\\b"); for (var n = 0; n &lt; e.length; ) &#123; e[n].className = e[n].className.replace(t, "") &#125; &#125; var e = 30; var t = 30; var n = 350; var r = 350; var i = "//7xuupy.com1.z0.glb.clouddn.com/tongxingSibel%20-%20Im%20Sorry.mp3"; var s = "mw-harlem_shake_me"; var o = "im_first"; var u = ["im_drunk", "im_baked", "im_trippin", "im_blown"]; var a = "mw-strobe_light"; var f = "//s3.amazonaws.com/moovweb-marketing/playground/harlem-shake-style.css"; var l = "mw_added_css"; var b = g(); var w = y(); var C = document.getElementsByTagName("*"); var k = null; for (var L = 0; L &lt; C.length; L++) &#123; var A = C[L]; if (v(A)) &#123; if (E(A)) &#123; k = A; break &#125; &#125; &#125; if (A === null) &#123; console.warn("Could not find a node of the right size. Please try a different page."); return &#125; c(); S(); var O = []; for (var L = 0; L &lt; C.length; L++) &#123; var A = C[L]; if (v(A)) &#123; O.push(A) &#125; &#125; &#125;)() '&gt;High一下&lt;/a&gt; &lt;/li&gt; 添加最近访客 在主题配置文件中menu项添加guestbook菜单 在Hexo的source文件夹下，利用hexo new page guestbook创建guestbook页面,对应的index文件中添加如下代码：12最近访客 &lt;div class=&quot;ds-recent-visitors&quot; data-num-items=&quot;39&quot; data-avatar-size=&quot;40&quot; id=&quot;ds-recent-visitors&quot;&gt;&lt;/div&gt; 修改文章内链接文本样式将链接文本设置为蓝色，鼠标划过时文字颜色加深，并显示下划线。找到文件 themes\next\source\css\_custom\custom.styl ，添加如下 css 样式：12345678.post-body p a &#123; color: #0593d3; border-bottom: none; &amp;:hover &#123; color: #0477ab; text-decoration: underline; &#125;&#125; 给 Github 添加 README默认情况下，Github中每一个项目，我们希望有一份 README.md 的文件来作为项目的说明，但是我们在项目根目录下的 blog\source 目录下创建一份 README.md 文件，写好说明介绍，部署的时候，这个 README.md 会被 hexo 解析掉，而不会被解析到 Github 中去的。正确的解决方法其实很简单： 把 README.md 文件的后缀名改成 “MDOWN” 然后扔到blog/source文件夹下即可，这样 hexo 不会解析，Github 也会将其作为 MD 文件解析。 插入网易云音乐如果只加入单曲，只需要搜索歌曲，点开歌曲名，点击生成外链播放器，复制html代码将html代码无需任何修改放入markdown文章里就OK了。 如果想要加入歌单，就需要自己创建歌单，然后分享歌单，找到自己的分享动态，点进去可以看到有“生成外链播放器”这些字眼，其余操作就和上面一样了。 参考Never_yu’s Blog]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[数据结构之单链表]]></title>
      <url>%2F2017%2F03%2F29%2F%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B9%8B%E5%8D%95%E9%93%BE%E8%A1%A8%2F</url>
      <content type="text"><![CDATA[前言链表由多个结点离散分配，彼此通过指针相连，每个结点只有一个前驱结点和后继结点。首节点无前驱结点，尾结点无后继结点的一种存储结构 链表结构头结点：链表的第一个有效结点前面的结点，头结点并不存放有效数据，也就是数据域为空，加头结点的主要目的是为了方便链表的操作。首节点：链表的第一个有效结点，结点包含数据域和指针域。尾结点：尾结点的指针域为空。头指针：指向头结点的指针变量，它存放了头结点的地址(头指针存放的是头结点的地址)。 定义链表结点/* 定义单链表结点类型 */ typedef struct Node{ int element;//数据域 struct Node *next;//指针域 }Node; 单链表初始化无头结点链表/* 初始化线性表，即置单链表的表头指针为空 */ void initList(Node **pNode) { *pNode=(Node *)malloc( sizeof(Node)); *pNode = NULL; printf(&quot;initList函数执行，初始化成功\n&quot;); } 带头结点链表/* 初始化线性表，即置单链表的首节点指针为空 */ void initHeadList(Node **pNode) { *pNode=(Node *)malloc( sizeof(Node)); (*pNode)-&gt;next= NULL; printf(&quot;initHeadList函数执行，初始化成功\n&quot;); } 单链表创建无头结点链表Node *creatList(Node *pHead) { Node *new_node;//新建结点 Node *cur_node;//当前结点 int data; printf(&quot;输入节点：\n&quot;); scanf(&quot;%d&quot;,&amp;data); while(data &gt; 0) //输入的值大于0则继续，直到输入的值为负 { new_node=(Node *)malloc(sizeof(Node)); //申请新节点 if(NULL==new_node) { printf(&quot;新节点内存分配失败\n&quot;); exit(0); } memset(new_node,0,sizeof(Node)); new_node-&gt;element=data;//输入data存入结点的数据域 if (pHead==NULL) //首结点若为空，新节点为首结点 { pHead=new_node; } else //首结点不为空，已插入结点 { cur_node-&gt;next=new_node;//当前结点的指针指向新节点 } cur_node=new_node; //将当前结点移向新节点 scanf(&quot;%d&quot;,&amp;data); new_node-&gt;next = NULL; //新节点指针域为空 } printf(&quot;creatList函数执行，链表创建成功\n&quot;); return pHead; //返回链表的头指针 } 带头结点链表 /*头节点创建*/ Node *creatHeadList(Node *pHead) { Node *new_node; Node *cur_node; int data; printf(&quot;输入节点：\n&quot;); scanf(&quot;%d&quot;,&amp;data); while(data &gt; 0) //输入的值大于0则继续，直到输入的值为负 { new_node=(Node *)malloc(sizeof(Node)); //申请新节点 if(NULL==new_node) { printf(&quot;新节点内存分配失败\n&quot;); exit(0); } memset(new_node,0,sizeof(Node)); new_node-&gt;element=data; if (pHead-&gt;next==NULL) { pHead-&gt;next=new_node; } else { cur_node-&gt;next=new_node; } cur_node=new_node; scanf(&quot;%d&quot;,&amp;data); new_node-&gt;next = NULL; } printf(&quot;creatHeadList函数执行，链表创建成功\n&quot;); return pHead; //返回链表的头指针 } 打印链表无头结点链表/* 3.打印链表，链表的遍历*/ void printList(Node *pHead) { if(NULL == pHead) //链表为空 { printf(&quot;PrintList函数执行，链表为空\n&quot;); } else { while(NULL != pHead) { printf(&quot;%d &quot;,pHead-&gt;element); pHead = pHead-&gt;next; } printf(&quot;\n&quot;); } } 带头结点链表 /* 3.打印链表，链表的遍历*/ void printHeadList(Node *pHead) { if(NULL == pHead-&gt;next) //链表为空 { printf(&quot;PrintList函数执行，链表为空\n&quot;); } else { while(NULL != pHead-&gt;next) { printf(&quot;%d &quot;,pHead-&gt;next-&gt;element); pHead = pHead-&gt;next; } printf(&quot;\n&quot;); } 链表长度无头结点链表int lengthList(Node *pHead) { int length = 0; while(pHead != NULL) { length++; //遍历链表size大小比链表的实际长度小1 pHead = pHead-&gt;next; } printf(&quot;lengthList函数执行，链表长度 %d \n&quot;,length); return length; //链表的实际长度 } 带头结点链表 /* 返回单链表的长度 */ int lengthHeadList(Node *pHead) { int length = 0; while(NULL != pHead-&gt;next) { length++; //遍历链表size大小比链表的实际长度小1 pHead = pHead-&gt;next; } printf(&quot;lengthList函数执行，链表长度 %d \n&quot;,length); return length; //链表的实际长度 } 链表非空判断无头结点链表/* 检查单链表是否为空，若为空则返回0，否则返回1 */ int isEmptyList(Node *pHead) { int emptyFlag=0; if(pHead == NULL) //链表为空 { printf(&quot;isEmptyList函数执行，链表为空\n&quot;); emptyFlag=0; } else //链表非空 { printf(&quot;isEmptyList函数执行，链表非空\n&quot;); emptyFlag=1; } return emptyFlag; } 带头结点链表 /* 检查单链表是否为空，若为空则返回0，否则返回1 */ int isEmptyHeadList(Node *pHead) { int emptyFlag=0; if(pHead-&gt;next == NULL) { printf(&quot;isEmptyList函数执行，链表为空\n&quot;); emptyFlag=0; } else { printf(&quot;isEmptyList函数执行，链表非空\n&quot;); emptyFlag=1; } return emptyFlag; } 取出链表结点元素无头结点链表/* 返回单链表中第pos个结点中的元素，若pos超出范围，则停止程序运行 */ int getElement(Node *pHead, int pos) { int i=0; if(pos &lt; 1) { printf(&quot;getElement函数执行，pos值非法\n&quot;); return 0; } if(pHead == NULL) { printf(&quot;getElement函数执行，链表为空\n&quot;); return 0; //exit(1); } while(pHead !=NULL) { ++i; if(i == pos) //到达节点。退出 { break; } pHead = pHead-&gt;next; //头结点移到下一结点 } if(i &lt; pos) //链表长度不足则退出 { printf(&quot;getElement函数执行，pos值超出链表长度\n&quot;); return 0; } return pHead-&gt;element; } 带头结点链表 /* 返回单链表中第pos个结点中的元素，若pos超出范围，则停止程序运行 */ int getElementHeadList(Node *pHead, int pos) { int i=0; if(pos &lt; 1) { printf(&quot;getElement函数执行，pos值非法\n&quot;); return 0; } if(pHead-&gt;next == NULL) { printf(&quot;getElement函数执行，链表为空\n&quot;); return 0; //exit(1); } while(pHead-&gt;next !=NULL) { ++i; if(i == pos) //到达节点。退出 { break; } pHead = pHead-&gt;next; //头结点移到下一结点 } if(i &lt; pos) //链表长度不足则退出 { printf(&quot;getElement函数执行，pos值超出链表长度\n&quot;); return 0; } return pHead-&gt;next-&gt;element; } 查找链表元素无头结点链表/*从单链表中查找具有给定值x的第一个元素，若查找成功则返回该结点data域的存储地址，否则返回NULL */ int *getElemAddr(Node *pHead, int x) { if(NULL == pHead) { printf(&quot;getElemAddr函数执行，链表为空\n&quot;); return NULL; } if(x &lt; 0) { printf(&quot;getElemAddr函数执行，给定值X不合法\n&quot;); return NULL; } while((pHead-&gt;element != x) &amp;&amp; (NULL != pHead-&gt;next)) //判断是否到链表末尾，以及是否存在所要找的元素 { pHead = pHead-&gt;next; } if((pHead-&gt;element != x) &amp;&amp; (pHead != NULL)) { printf(&quot;getElemAddr函数执行，在链表中未找到x值\n&quot;); return NULL; } if(pHead-&gt;element == x) { printf(&quot;getElemAddr函数执行，元素 %d 的地址为 0x%x\n&quot;,x,&amp;(pHead-&gt;element)); } return &amp;(pHead-&gt;element);//返回元素的地址 } 带头结点链表/*从单链表中查找具有给定值x的第一个元素，若查找成功则返回该结点data域的存储地址，否则返回NULL */ int *getElemAddrHeadList(Node *pHead, int x) { if(NULL == pHead-&gt;next) { printf(&quot;getElemAddr函数执行，链表为空\n&quot;); return NULL; } if(x &lt; 0) { printf(&quot;getElemAddr函数执行，给定值X不合法\n&quot;); return NULL; } while((pHead-&gt;next-&gt;element != x) &amp;&amp; (NULL != pHead-&gt;next)) //判断是否到链表末尾，以及是否存在所要找的元素 { pHead = pHead-&gt;next; } if((pHead-&gt;next-&gt;element != x) &amp;&amp; (pHead-&gt;next != NULL)) { printf(&quot;getElemAddr函数执行，在链表中未找到x值\n&quot;); return NULL; } if(pHead-&gt;next-&gt;element == x) { printf(&quot;getElemAddr函数执行，元素 %d 的地址为 0x%x\n&quot;,x,&amp;(pHead-&gt;next-&gt;element)); } return &amp;(pHead-&gt;next-&gt;element);//返回元素的地址 } 修改链表元素无头结点链表/* 9.把单链表中第pos个结点的值修改为x的值，若修改成功返回１，否则返回０ */ int modifyElem(Node *pNode,int pos,int x) { int i=0; Node *pHead; pHead = pNode; if(NULL == pHead) { printf(&quot;modifyElem函数执行，链表为空\n&quot;); } if(pos &lt; 1) { printf(&quot;modifyElem函数执行，pos值非法\n&quot;); return 0; } while(pHead !=NULL) { ++i; if(i == pos) { break; } pHead = pHead-&gt;next; //移到下一结点 } if(i &lt; pos) //链表长度不足则退出 { printf(&quot;modifyElem函数执行，pos值超出链表长度\n&quot;); return 0; } pNode = pHead;//要修改结点 pNode-&gt;element = x; //修改为要修改值 printf(&quot;modifyElem函数执行\n&quot;); return 1; } 带头结点链表 /* 把单链表中第pos个结点的值修改为x的值，若修改成功返回１，否则返回０ */ int modifyElemHeadList(Node *pNode,int pos,int x) { int i=0; Node *pHead; pHead = pNode; if(NULL == pHead-&gt;next) { printf(&quot;modifyElemHeadList函数执行，链表为空\n&quot;); } if(pos &lt; 1) { printf(&quot;modifyElemHeadList函数执行，pos值非法\n&quot;); return 0; } while(pHead-&gt;next !=NULL) { ++i; if(i == pos) { break; } pHead = pHead-&gt;next; //移到下一结点 } if(i &lt; pos) //链表长度不足则退出 { printf(&quot;modifyElemHeadList函数执行，pos值超出链表长度\n&quot;); return 0; } pNode = pHead; pNode-&gt;next-&gt;element = x; printf(&quot;modifyElemHeadList函数执行\n&quot;); return 1; } 链表插入表头插入元素无头节点链表/* 10.向单链表的表头插入一个元素 */ int insertHeadList(Node **pNode,int insertElem) { Node *pInsert; pInsert = (Node *)malloc(sizeof(Node)); memset(pInsert,0,sizeof(Node)); pInsert-&gt;element = insertElem; pInsert-&gt;next = *pNode; *pNode = pInsert; printf(&quot;insertHeadList函数执行，向表头插入元素成功\n&quot;); return 1; } 带头结点链表/* 向单链表的表头插入一个元素 */ Node *inserFirsttHeadList(Node *pHead,int insertElem) { Node *pInsert; pInsert = (Node *)malloc(sizeof(Node)); memset(pInsert,0,sizeof(Node)); pInsert-&gt;element = insertElem; pInsert-&gt;next = pHead-&gt;next; pHead-&gt;next = pInsert; printf(&quot;inserFirsttHeadList函数执行，向表头插入元素成功\n&quot;); return pHead; } 表尾插入元素无头节点链表int insertLastList(Node **pNode,elemType insertElem) { Node *pInsert; Node *pHead; Node *pTmp; //定义一个临时链表用来存放第一个节点 pHead = *pNode; pTmp = pHead; pInsert = (Node *)malloc(sizeof(Node)); //申请一个新节点 memset(pInsert,0,sizeof(Node)); pInsert-&gt;element = insertElem; while(pHead-&gt;next != NULL) { pHead = pHead-&gt;next; } pHead-&gt;next = pInsert; //将链表末尾节点的下一结点指向新添加的节点 *pNode = pTmp; printf(&quot;insertLastList函数执行，向表尾插入元素成功\n&quot;); return 1; } 带头结点链表 /* 向单链表的末尾添加一个元素 */ int insertLasHeadtList(Node *pNode,int insertElem) { Node *pInsert; Node *pHead; Node *pTmp; //定义一个临时链表用来存放第一个节点 pHead = pNode; pTmp = pHead; pInsert = (Node *)malloc(sizeof(Node)); //申请一个新节点 memset(pInsert,0,sizeof(Node)); pInsert-&gt;element = insertElem; while(pHead-&gt;next != NULL) { pHead = pHead-&gt;next; } pHead-&gt;next = pInsert; //将链表末尾节点的下一结点指向新添加的节点 pNode = pTmp; printf(&quot;insertLastList函数执行，向表尾插入元素成功\n&quot;); return 1; } 链表删除删除链表指定数据无头节点链表 /* 删除单链表单个元素 */ Node *delElementList(Node *pHead,int delElem) { Node *pre_node;//要删除节点的前一节点 Node *del_node;//删除节点 Node *Head; if(NULL == pHead) { printf(&quot;delElementList函数执行，链表为空\n&quot;); return pHead; } if(delElem &lt; 0) { printf(&quot;delElementList函数执行，给定值X不合法\n&quot;); return pHead; } del_node=pHead; //删除节点从头结点开始 while((del_node-&gt;element != delElem) &amp;&amp; (NULL != del_node-&gt;next)) //判断是否到链表末尾，以及是否存在所要找的元素 { pre_node=del_node; //该节点不是要找节点，设置为前一节点 del_node = del_node-&gt;next;//节点下移 } //到链表尾依然没有要找元素 if((del_node-&gt;element != delElem) &amp;&amp; (del_node != NULL)) { printf(&quot;getElemAddr函数执行，在链表中未找到x值\n&quot;); return NULL; } //找到要删除元素 if(del_node-&gt;element == delElem) { if (del_node==pHead) //若为头结点 { pHead=del_node-&gt;next; } else //不是头结点 { pre_node-&gt;next=del_node-&gt;next; //前一节点的指针指向要删除节点的指针域，即后一节点 } free(del_node); //释放删除节点 printf(&quot;delElementList函数执行，删除元素为 %d \n&quot;,delElem); } Head=pHead; return Head; } 带头结点链表 /* 删除单链表单个元素 */ Node *delElementHeadList(Node *pHead,int delElem) { Node *pre_node;//要删除节点的前一节点 Node *del_node;//删除节点 Node *Head; if(NULL == pHead-&gt;next) { printf(&quot;delElementHeadList函数执行，链表为空\n&quot;); return pHead; } if(delElem &lt; 0) { printf(&quot;delElementHeadList函数执行，给定值X不合法\n&quot;); return pHead; } del_node=pHead-&gt;next; //删除节点从第一个节点开始 while((del_node-&gt;element != delElem) &amp;&amp; (NULL != del_node-&gt;next)) //判断是否到链表末尾，以及是否存在所要找的元素 { pre_node=del_node; //该节点不是要找节点，设置为前一节点 del_node = del_node-&gt;next;//节点下移 } //到链表尾依然没有要找元素 if((del_node-&gt;element != delElem) &amp;&amp; (del_node!= NULL)) { printf(&quot;delElementHeadList函数执行，在链表中未找到x值\n&quot;); return NULL; } //找到要删除元素 if(del_node-&gt;element == delElem) { if (del_node==pHead-&gt;next) //若为第一个结点 { pHead-&gt;next=del_node-&gt;next; } else //不是第一个结点 { pre_node-&gt;next=del_node-&gt;next; //前一节点的指针指向要删除节点的指针域，即后一节点 } free(del_node); //释放删除节点 printf(&quot;delElementList函数执行，删除元素为 %d \n&quot;,delElem); } Head=pHead; return Head; } 删除链表指定结点无头节点链表/* 删除单链表指定节点 */ Node *delPosList(Node *pHead,int pos) { int i=0; Node *pre_node;//要删除节点的前一节点 Node *del_node;//删除节点 if(NULL == pHead) { printf(&quot;delPosLis函数执行，链表为空\n&quot;); return pHead; } if(pos &lt; 0) { printf(&quot;delPosLis函数执行，给定位置pos不合法\n&quot;); return pHead; } del_node=pHead; //删除节点从头结点开始匹配 while(del_node !=NULL) { ++i; if(i == pos) { if (pos==1) //若删除的是头结点 { pHead=del_node-&gt;next; } else //若删除的不是头结点 { pre_node-&gt;next=del_node-&gt;next; } printf(&quot;delPosList函数执行，删除第 %d个元素\n&quot;,pos); break; } pre_node=del_node; //设置前一节点 del_node= del_node-&gt;next; //移到下一结点 } free(del_node); //释放删除节点 return pHead; } 带头结点链表/* 删除单链表指定节点 */ Node *delPosHeadList(Node *pHead,int pos) { int i=0; Node *pre_node;//要删除节点的前一节点 Node *del_node;//删除节点 Node *Head; if(NULL == pHead-&gt;next) { printf(&quot;delPosLis函数执行，链表为空\n&quot;); return pHead; } if(pos &lt; 0) { printf(&quot;delPosLis函数执行，给定位置pos不合法\n&quot;); return pHead; } del_node=pHead-&gt;next; //删除节点从第一个结点开始匹配 while(del_node !=NULL) { ++i; if(i == pos) { if (pos==1) //若删除的是头结点 { pHead-&gt;next=del_node-&gt;next; } else //若删除的不是头结点 { pre_node-&gt;next=del_node-&gt;next; } printf(&quot;delPosList函数执行，删除第 %d个元素\n&quot;,pos); break; } pre_node=del_node; //设置前一节点 del_node= del_node-&gt;next; //移到下一结点 } free(del_node); //释放删除节点 Head=pHead; return Head; } 清除链表无头节点链表 /* 释放单链表L中所有的结点，使之成为一个空表 */ void clearList(Node *pHead) { Node *pNext; //定义一个与pHead相邻节点 if(pHead == NULL) { printf(&quot;clearList函数执行，链表为空\n&quot;); return; } while(pHead-&gt;next != NULL) { pNext = pHead-&gt;next;//保存下一结点的指针 free(pHead); pHead = pNext; //表头下移 } printf(&quot;clearList函数执行，链表已经清除\n&quot;); } 带头节点链表 /* 4.清除线性表L中的所有元素，即释放单链表L中所有的结点，使之成为一个空表 */ void clearHeadList(Node *pHead) { Node *pNext; //定义一个与pHead相邻节点 if(pHead-&gt;next== NULL) { printf(&quot;clearList函数执行，链表为空\n&quot;); return; } while(pHead-&gt;next != NULL) { pNext = pHead-&gt;next;//保存下一结点的指针 free(pHead); pHead = pNext; //表头下移 } printf(&quot;clearList函数执行，链表已经清除\n&quot;); } 主函数无头节点链表int main() { Node *pList=NULL; Node *newHead=NULL; Node *new2Head=NULL; Node *new3Head=NULL; int length = 0; int emptyFlag=0; int posElement=0; initList(&amp;pList); pList=creatList(pList); printList(pList); length=lengthList(pList); emptyFlag=isEmptyList(pList); //判断链表是否为空链表 posElement=getElement(pList,3); printf(&quot;getElement函数执行，位置 3 中的元素为 %d\n&quot;,posElement); getElemAddr(pList,5); //获得元素5的地址 modifyElem(pList,4,1); //将链表中位置4上的元素修改为1 printList(pList); newHead=insertHeadList(pList,5); //表头插入元素5 printList(newHead); insertLastList(newHead,10); //表尾插入元素10 printList(newHead); new2Head=delElementList(newHead,5); //删除第一个元素5 printList(new2Head); new3Head=delPosList(new2Head,2); printList(new3Head); clearList(new3Head); //清空链表 //printList(new3Head); } 带头节点链表 int main() { Node *pList=NULL; Node *newHead=NULL; Node *new2Head=NULL; Node *new3Head=NULL; int length = 0; int emptyFlag=0; int posElement=0; initHeadList(&amp;pList); pList=creatHeadList(pList); printHeadList(pList); length=lengthHeadList(pList); emptyFlag=isEmptyHeadList(pList); //判断链表是否为空链表 posElement=getElementHeadList(pList,3); printf(&quot;getElement函数执行，位置 3 中的元素为 %d\n&quot;,posElement); getElemAddrHeadList(pList,3); //获得元素3的地址 modifyElemHeadList(pList,3,1); //将链表中位置4上的元素修改为1 printHeadList(pList); newHead=inserFirsttHeadList(pList,5); //表头插入元素5 printHeadList(newHead); insertLasHeadtList(newHead,10); //表尾插入元素10 printHeadList(newHead); new2Head=delElementHeadList(newHead,5); //删除第一个元素5 printHeadList(new2Head); new3Head=delPosHeadList(new2Head,2); printHeadList(new3Head); clearHeadList(new3Head); //清空链表 } 实验验证环境：VC6.0 无头节点链表 带头节点链表]]></content>
    </entry>

    
  
  
</search>
