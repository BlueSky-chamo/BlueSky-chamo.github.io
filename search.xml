<?xml version="1.0" encoding="utf-8"?>
<search>
  
    
    <entry>
      <title><![CDATA[回顾51单片机之定时器简介]]></title>
      <url>%2F2017%2F04%2F21%2F%E5%9B%9E%E9%A1%BE%E5%8D%95%E7%89%87%E6%9C%BA%E4%B9%8B%E5%AE%9A%E6%97%B6%E5%99%A8%E7%AE%80%E4%BB%8B%2F</url>
      <content type="text"><![CDATA[时钟周期单片机外接晶振的振荡周期就是时钟周期。80C51单片机外接了一个11.0592M的晶体振荡器，单片机系统的时钟周期是1/11.0592M，周期是频率的倒数。51单片机时钟频率范围是1.MHZ-12MHZ，把一个时钟周期定义为一个节拍（P）,二个节拍定义为一个状态周期（S）。 机器周期单片机执行指令所消耗的最小时间单位。51单片机采用的CISC(复杂指令指令集)，各条指令执行的时间可能不一样，但是它们执行的时间必须是机器周期的整数倍。51系列单片机将一个机器周期划分为6个状态周期，即S1-S6，每个状态周期又由两个节拍组成，P1和P2，而P1=P2=时钟周期。因此，51单片机的机器周期=6个状态周期=12个时钟周期。这也就是经常说的51单片机的的时钟频率是晶振频率的12分频，或者是1/12。 指令周期指令周期执行某一条指令所消耗的时间，它等于机器周期的整数倍。指令不同，所需的机器周期数也不同。简单的单字节指令。在取指令周期中，指令取出到指令寄存器后立即译码执行；复杂的指令如转移指令，乘法指令，则需要两个或以上的机器周期。 定时器C51单片机内部设有两个16位的可编程定时器/计数器，分别由两个8位专用寄存器组成，即：T0由TH0和TL0构成；T1由TH1和TL1构成，其访问地址依次为8AH-8DH。此外，其内部还有一个8位的定时器方式寄存器TMOD和一个8位的定时控制寄存器TCON，TMOD主要是用于选定定时器的工作方式；TCON主要是用于控制定时器的启动停止，此外TCON还可以保存T0、T1的溢出和中断标志。当定时器工作在计数方式时，外部事件通过引脚T0（P3.4）和T1（P3.5）输入。 定时计数原理16位的定时器/计数器实质上就是一个加1计数器,当定时器/计数器为定时工作方式时，计数器的加1信号由振荡器的12分频信号产生，即每过一个机器周期，计数器加1，直至计满溢出为止。显然，定时器的定时时间与系统的振荡频率有关。因一个机器周期等于12个振荡周期，所以计数频率fcount=1/12osc。如果晶振为12MHz，则计数周期为： T=1/（12×106）Hz×1/12=1μs 当定时器/计数器为计数工作方式时，通过引脚T0和T1对外部信号计数，外部脉冲的下降沿将触发计数。计数器在每个机器周期的S5P2期间采样引脚输入电平。若一个机器周期采样值为1，下一个机器周期采样值为0，则计数器加1。此后的机器周期S3P1期间，新的计数值装入计数器。所以检测一个由1至0的跳变需要两个机器周期，故外部事件的最高计数频率为振荡频率的1/24。例如，如果选用12MHz晶振，则最高计数频率为0.5MHz。为了确保某给定电平在变化前至少被采样一次，外部计数脉冲的高电平与低电平保持时间均需在一个机器周期以上。 定时器/计数器方式寄存器TMOD定时器方式控制寄存器TMOD在特殊功能寄存器中，字节地址为89H，无位地址。 C／T：定时器／计数器选择位。C/T＝1，为计数器方式；C／T＝0，为定时器方式。 M1M0：工作方式选择位，定时器／计数器的4种工作方式由M1M0设定。 0 0 工作方式0 13位计数器 0 1 工作方式1 16位计数器 1 0 工作方式2 自动再装入8位计数器 1 1 工作方式3 定时器0：分成两个8位计数器，定时器1：停止计数 定时器/计数器控制寄存器TCON TCON在特殊功能寄存器中，字节地址为88H，位地址(由低位到高位)为88H一8FH TF1：定时器1溢出标志位。当字时器1计满溢出时，由硬件使TF1置“1”，并且申请中断。进入中断服务程序后，由硬件自动清“0”，在查询方式下用软件清“0”。 TR1：定时器1运行控制位。由软件清“0”关闭定时器1。当GATE=1，且INT1为高电平时，TR1置“1”启动定时器1；当GATE=0，TR1置“1”启动定时器1。 TF0：定时器0溢出标志。其功能及操作情况同TF1。 TR0：定时器0运行控制位。其功能及操作情况同TR1。 IE1：外部中断1请求标志。 IT1：外部中断1触发方式选择位。 IE0：外部中断0请求标志。 IT0：外部中断0触发方式选择位。 定时器初始化确定工作方式方式0：13位定时计数方式，最大计数值为2^13=8192,定时8192个机器周期。 方式1：16位定时计数方式，最大计数值为2^16=65536,定时65536个机器周期。此方式可实现最大的定时时间和最大计数次数。是最常用方式之一。 方式2：8位自动重装计数方式，最大计数值为2^8=256,定时256个机器周期。此方式工作时定时或计数到了不用重装初值，精度较高。另外在串口通讯时常用此方式。是最常用方式之一。 方式3：特殊工作方式。将定时器0分成两个8位功能不全的定时计数器，要占用T1部分功能。 定时器初值定时时间=（最大计数值-初值）X 晶振周期 X 12或 定时时间=（最大计数值-初值）X 机器周期 定时器寄存器为16为，分高8位TH0和低8位TL0,以8位为单位进行封装，将TH0装入初值N/256,低8位TL0装入初值N%256。即定时器初值计算公式为：TH0=(最大计数值M-初值N)/256TL0=(最大计数值M-初值N)%256 机器周期=12时钟周期，12MHZ晶振下，机器周期=1us,定时1s=1000000机器周期，初值=最大机器周期-初值机器周期 例如：10MS定时器初值的计算：1.晶振12M12MHz除12为1MHz，也就是说一秒=1000000次机器周期。10ms=10000次 机器周期。65536-10000=55536(d8f0)TH0=0xd8，TL0=0xf0 2.晶振11.0592M11.0592MHz除12为921600Hz，就是一秒921600次机器周期，10ms=9216次机器周期。65536-9216=56320(dc00)TH0=0xdc，TL0=0x00 启动定时器根据需要打开定时器中断，启动定时器。 EA = 1; //打开总中断 ET0 = 1; //定时器0中断 TR0 = 1; //打开定时器0]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[回顾51单片机之enum用法]]></title>
      <url>%2F2017%2F04%2F21%2F%E5%9B%9E%E9%A1%BE%E5%8D%95%E7%89%87%E6%9C%BA%E4%B9%8Benum%E7%94%A8%E6%B3%95%2F</url>
      <content type="text"><![CDATA[前言在单片机工程中使用enum来替代define，增加代码的可读性 enum简介enum定义enum DAY { MON=1, TUE, WED, THU, FRI, SAT, SUN }; (1) 枚举型是一个集合，集合中的元素(枚举成员)是一些命名的整型常量，元素之间用逗号隔开。(2) DAY是一个标识符，可以看成这个集合的名字，是一个可选项，即是可有可无的项。(3) 第一个枚举成员的默认值为整型的0，后续枚举成员的值在前一个成员上加1。(4) 可以人为设定枚举成员的值，从而自定义某个范围内的整数。(5) 枚举型是预处理指令#define的替代。(6) 类型定义以分号结束。在实际使用中，更倾向于利用Typedef进行定义，定以后Day=enum DAY，方便枚举对象的声明与赋值 typedef enum DAY { MON=1, TUE, WED, THU, FRI, SAT, SUN }Day; enum变量声明与赋值以typedef为例: Day day=MON; 单片机应用实例在单片机工程中的Led.h头文件中，定义以下结构体表面led灯号 /************************************************************ ***结构体名称：Led_Num ***简述：led灯号结构体，表面属于哪个led *************************************************************/ typedef enum LedNum { LED_ALL=0, LED1=1, LED2=2, LED3=3, LED4=4, LED5=5, LED6=6, LED7=7, LED8=8 }Led_Num; /************************************************************ ***结构体名称：Led_Status ***简述：led灯状态，亮或熄灭 *************************************************************/ typedef enum LedStatus { OFF=0, ON=1 }Led_Status; 在Led.c源文件中，Led_ON_OFF()用来点亮或熄灭指定led灯，如下： /************************************************************** // 作者:chamo // 日期:2017-4-20 // 函数名:Led_ON_OFF // 功能:指定led灯亮熄 // 输入参数 // 参数1:led等号LedNum // 参数2:led状态 // 参数3:LedStatus，ON or OFF // 参数4: // 返回值:无 **************************************************************/ void Led_ON_OFF(int LedNum,int LedStatus) { switch(LedNum) { case LED_ALL: if(LedStatus) { GPIO_LED=GPIO_LED&amp;0x00; } else { GPIO_LED=GPIO_LED|0xFF; } break; case LED1: if(LedStatus) { GPIO_LED=GPIO_LED&amp;0xFE; } else { GPIO_LED=GPIO_LED|0x01; } break; case LED2: if(LedStatus) { GPIO_LED=GPIO_LED&amp;0xFD; } else { GPIO_LED=GPIO_LED|0x02; } break; case LED3: if(LedStatus) { GPIO_LED=GPIO_LED&amp;0xFB; } else { GPIO_LED=GPIO_LED|0x04; } break; case LED4: if(LedStatus) { GPIO_LED=GPIO_LED&amp;0xF7; } else { GPIO_LED=GPIO_LED|0x08; } break; case LED5: if(LedStatus) { GPIO_LED=GPIO_LED&amp;0xEF; } else { GPIO_LED=GPIO_LED|0x10; } break; case LED6: if(LedStatus) { GPIO_LED=GPIO_LED&amp;0xDF; } else { GPIO_LED=GPIO_LED|0x20; } break; case LED7: if(LedStatus) { GPIO_LED=GPIO_LED&amp;0xBF; } else { GPIO_LED=GPIO_LED|0x40; } break; case LED8: if(LedStatus) { GPIO_LED=GPIO_LED&amp;0x7F; } else { GPIO_LED=GPIO_LED|0x80; } break; } 在main.c中，调用led接口函数即可实现指定led的亮熄 #include &lt;stdio.h&gt; #include &quot;common.h&quot; #include &quot;Led.h&quot; int main() { Led_Num LedNum=LED1;//1号灯 Led_Status LedStatus=ON;//亮 Initial_Peripheral();//初始化外设 while(1) { Led_ON_OFF(LedNum,LedStatus); } return 0; } 总结enum与define比较enum:缺点：只能为整型值，不仅占用空间，还消耗cpu资源优点：多个相关值一组，程序更容易维护，代码更加清晰，范围内有效，不会和其他定义冲突 define:缺点：没有范围限制，全局有效，容易产生冲突优点：可为多种类型之，如字符串，整型，浮点型 在一般情况下尽量选择enum,增加代码的可读性和维护性。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[linux命令学习之文件目录命令-nl命令]]></title>
      <url>%2F2017%2F03%2F30%2Flinux%E5%91%BD%E4%BB%A4%E5%AD%A6%E4%B9%A0-%E6%96%87%E4%BB%B6%E7%9B%AE%E5%BD%95%E4%B9%8Bnl%E5%91%BD%E4%BB%A4%2F</url>
      <content type="text"><![CDATA[nl简介nl命令在linux系统中用来计算文件中行号。nl 可以将输出的文件内容自动的加上行号。其默认的结果与 cat -n 有点不太一样， nl可以将行号做比较多的显示设计，包括位数与是否自动补齐 0 等的功能。 命令学习命令格式：nl [选项] [文件]命令功能：nl 命令读取 File 参数（缺省情况下标准输入），计算输入中的行号，将计算过的行号写入标准输出。 在输出中，nl 命令根据您在命令行中指定的标志来计算左边的行。 输入文本必须写在逻辑页中。每个逻辑页有头、主体和页脚节（可以有空节）。 除非使用 -p 标志，nl 命令在每个逻辑页开始的地方重新设置行号。 可以单独为头、主体和页脚节设置行计算标志（例如，头和页脚行可以被计算然而文本行不能）。命令参数：-b ：行号指定的方式，主要有两种：-b a ：表示不论是否为空行，也同样列出行号(类似 cat -n)；-b t ：如果有空行，空的那一行不要列出行号(默认值)； -n ：列出行号表示的方法，主要有三种：-n ln ：行号在萤幕的最左方显示；-n rn ：行号在自己栏位的最右方显示，且不加 0 ；-n rz ：行号在自己栏位的最右方显示，且加 0 ； -w ：行号栏位的占用的位数。-p 在逻辑定界符处不重新开始计算。 常用范例例一：用 nl 列出 1.log的内容nl 1.log文件中的空白行，nl 不会加上行号 例二：用 nl 列出 1.log 的内容，空本行也加上行号nl -b a 1.log 例3：让行号前面自动补上0,统一输出格式nl -b a -n rz 1.lognl -b a -n rz -w 3 1.log]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[linux下FTP配置]]></title>
      <url>%2F2017%2F03%2F30%2Flinux%E4%B8%8Bftp%E9%85%8D%E7%BD%AE%2F</url>
      <content type="text"><![CDATA[FTP原理文件传输协议（FTP）是一种传统的网络协议，主要功能是实现服务器端与客户端直接的文件传送。FTP以TCP封装包的模式进行服务器与客户的连接，当连接建立后，使用者可以通过客户端程序连接服务器端，并进行文件的下载和上传。此外，还可以直接管理用户在服务器上的文件。 FTP功能1）不同等级的使用者。FTP预设情况下提供三种主要的身份：实体账号（real user）访客（guest）匿名登入者（anonymous）分成三种身份可以提高主机管理的便利性。例如，实体用户可以进行的动作比较多，而匿名登入者仅提供一个下载功能。 2）命令记录与登入文件记录。FTP可以利用系统的syslogd进行数据的记录。记录的数据包括了使用者曾经下达的命令与使用者传输的数据的记录 3）限制或解除使用者所在的根目录。为了避免使用者进入到linux系统的其他目录。这有利于提高系统的安全性。 FTP的用户类型匿名用户（anonymous）：常说的匿名登录，ftp服务器支持匿名登录时通常当用户匿名访问可以使用ftp/anoymous这两个用户匿名登录。本地用户(Real user)：这类用户是指在FTP服务上拥有帐号，账号名称，密码信息存放在passwd,shadow文件中。当这类用户登录FTP服务器的时候，其默认的主目录就是其帐号命名的目录。但是，其还可以变更到其他目录中去。虚拟用户(Guest)：使用独立的账号/密码数据文件，只能够访问自己的主目录。服务器通过这种方式来保障FTP服务上其他文件的安全性。 安装VSFTPDsudo apt-get install vsftpd 配置VSFTPD/etc/vsftpd.conf:主要配置文件：关于主机的设置：connect_from_port_20=YES ftp-data启动主动联机的port 20listen_port=20 ftp访问端口dirmessage_enable=YES 当使用者进入某个目录时，会显示该目录需要注意的内容。显示的文件预设是.messagewrite_enable=YES 是否允许使用者具有写入的权限idle_session_timeout=600 空闲会话的超时限制。默认600s.空闲600s后自动断开连接data_connection_timeout=120 数据超时限制，默认120s。 实体用户登入者的配置：local_enable=YES 实体用户允许登入local_umask=022 用户的权限（把本该是777权限的文件夹改为了755）如果注释了该参数，该参数会启用默认权限掩码077，那么上传的文件权限将会变为600，文件夹权限变为700chroot_local_user=YES 是否将使用者限制在自己的主目录中chroot_list_enable=YES 是否启用将某些实体用户限制在主目录chroot_list_fiel=/etc/vsftpd.chroot_list 被限制的实体用户主目录路径 匿名用户登入的配置anonymous_enable=YES 允许匿名用户登入anon_upload_enable=YES 允许匿名用户上传anon_mkdir_write_enable=YES 允许匿名用户创建文件夹deny_email_file=/etc/vsftpd.banned_emails 被拒绝的email地址async_abor_enable=YES 是否认可异步的ABOR命令xferlog_enable=YES 是否记录上传及下载日志xferlog_fiel=/ver/log/vsftpd.log 上传和下载日志路径xferlog_std_format=YES 是否设定为wu ftp相同的登入格式nopriv_user=ftpsecure 以nobody作为此一服务执行者的权限，安全性较高pam_service_name=vsftpd pam模块的名称 /etc/pam.d/vsftpd:pam模块进行身份确认/etc/ftpusers:限制使用的ftp用户列表/usr/shin/vsftpd:vsftpd的主要执行文件 重启VSFTPDudo service vsftpd restart 匿名用户登入在/etc/vsftpd.conf中配置允许匿名用户登入 （一般不允许） 实体用户登入在/etc/vsftpd.conf中配置运行实体用户登入]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[linux下VNC远程访问]]></title>
      <url>%2F2017%2F03%2F30%2Flinux%E4%B8%8Bvnc%E8%BF%9C%E7%A8%8B%E6%A1%8C%E9%9D%A2%E8%AE%BF%E9%97%AE%2F</url>
      <content type="text"><![CDATA[VNC远程桌面原理 vnc访问流程如下：1，vnc客户端通过浏览器或者vnc viewer 连接至vnc server2,vnc server 传送一个对话框至客户端，要求输入连接密码，以及存取的vnc server显示装置3，在客户端输入联机密码后，vnc server验证客户端是否具有存取权限。4，若是客户端通过vnc server的验证，客户端即要求vnc server显示桌面环境5，vnc server通过x xprotocol协议要求x server将画面显示控制权交给vnc server6，vnc server将来自x server的桌面环境利用vnc通信协议送至客户端，并且允许客户端控制vnc server的桌面环境及输入装置。 安装vncsudo apt-get install vnc4server 启动vncvncserver第一次启动时会提示输入密码注：创建一个指定会话号的vnc桌面vncserver :2 创建一个指定会话号为2的桌面 编辑启动脚本sudo gedit ~/.vnc/xstartup若有twm,则注释掉，添加如下 重启vnc结束之前的vnc线程vncserver -kill :1然后再启动vnc服务输入vncserver vnc viewer登入ifconfig查询linux的ip地址，ok后填入vncserver启动时设置的密码登入后发现只出现控制台界面，无法显示桌面将脚本中改为如下，关闭vncservervncserver -kill :1再重启vncserver]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[linux命令学习之文件压缩命令-gzip命令]]></title>
      <url>%2F2017%2F03%2F30%2Flinux%E5%91%BD%E4%BB%A4%E5%AD%A6%E4%B9%A0-%E6%96%87%E4%BB%B6%E5%8E%8B%E7%BC%A9%E4%B9%8Bgzip%E5%91%BD%E4%BB%A4%2F</url>
      <content type="text"><![CDATA[gzip简介 减少文件大小有两个明显的好处，一是可以减少存储空间，二是通过网络传输文件时，可以减少传输的时间。gzip是在Linux系统中经常使用的一个对文件进行压缩和解压缩的命令，既方便又好用。gzip不仅可以用来压缩大的、较少使用的文件以节省磁盘空间，还可以和tar命令一起构成Linux操作系统中比较流行的压缩文件格式。据统计，gzip命令对文本文件有60%～70%的压缩率。 命令学习命令格式：gzip[参数][文件或者目录]命令参数：-a或–ascii 使用ASCII文字模式。-c或–stdout或–to-stdout 把压缩后的文件输出到标准输出设备，不去更动原始文件。-d或–decompress或—-uncompress 解开压缩文件。-f或–force 强行压缩文件。不理会文件名称或硬连接是否存在以及该文件是否为符号连接。-h或–help 在线帮助。-l或–list 列出压缩文件的相关信息。-L或–license 显示版本与版权信息。-n或–no-name 压缩文件时，不保存原来的文件名称及时间戳记。-N或–name 压缩文件时，保存原来的文件名称及时间戳记。-q或–quiet 不显示警告信息。-r或–recursive 递归处理，将指定目录下的所有文件及子目录一并处理。-S&lt;压缩字尾字符串&gt;或—-suffix&lt;压缩字尾字符串&gt; 更改压缩字尾字符串。-t或–test 测试压缩文件是否正确无误。-v或–verbose 显示指令执行过程。-V或–version 显示版本信息。-num 用指定的数字num调整压缩的速度，-1或–fast表示最快压缩方法（低压缩比），-9或–best表示最慢压缩方法（高压缩比）。系统缺省值为6。 命令功能：gzip是个使用广泛的压缩程序，文件经它压缩过后，名称后面会多出”.gz”的扩展名。 常用范例例1：把test1目录下的每个文件压缩成.gz文件gzip *原文件会被打包，tar下-c选型会新建打包文件，原文件存在 例2：把每个压缩的文件解压，并列出详细的信息gzip -dv * 例3：详细显示每个压缩的文件的信息，并不解压gzip -l * 例4：压缩一个tar文件，此时压缩文件的扩展名为.tar.gzgzip -r log.tar 例5：递归的压缩目录gzip -rv test1test1下面的文件都变成了.gz，目录依然存在只是目录里面的文件相应变成了.gz. 例6：递归地解压目录gzip -dr test1]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[linux命令学习之文件打包解压命令-tar命令]]></title>
      <url>%2F2017%2F03%2F30%2Flinux%E5%91%BD%E4%BB%A4%E5%AD%A6%E4%B9%A0-%E6%96%87%E4%BB%B6%E6%89%93%E5%8C%85%E8%A7%A3%E5%8E%8B%E4%B9%8Btar%E5%91%BD%E4%BB%A4%2F</url>
      <content type="text"><![CDATA[tar简介tar命令可以为linux的文件和目录创建档案。利用tar，可以为某一特定文件创建档案（备份文件），也可以在档案中改变文件，或者向档案中加入新的文件。tar最初被用来在磁带上创建档案，现在，用户可以在任何设备上创建档案。利用tar命令，可以把一大堆的文件和目录全部打包成一个文件，这对于备份文件或将几个文件组合成为一个文件以便于网络传输是非常有用的。两个概念：打包和压缩。打包是指将一大堆文件或目录变成一个总的文件；压缩则是将一个大的文件通过一些压缩算法变成一个小文件。 Linux中很多压缩程序只能针对一个文件进行压缩，当你想要压缩一大堆文件时，得先将这一大堆文件先打成一个包（tar命令），然后再用压缩程序进行压缩（gzip bzip2命令）。linux下最常用的打包程序就是tar了，使用tar程序打出来的包我们常称为tar包，tar包文件的命令通常都是以.tar结尾的。生成tar包后，就可以用其它的程序来进行压缩。 命令学习命令格式：tar[必要参数][选择参数][文件]命令参数：必要参数有如下：-A 新增压缩文件到已存在的压缩-B 设置区块大小-c 建立新的压缩文件 -d 记录文件的差别-r 添加文件到已经压缩的文件-u 添加改变了和现有的文件到已经存在的压缩文件-x 从压缩的文件中提取文件 -t 显示压缩文件的内容-z 支持gzip解压文件-j 支持bzip2解压文件-Z 支持compress解压文件-v 显示操作过程-l 文件系统边界设置-k 保留原有文件不覆盖-m 保留文件不被覆盖-W 确认压缩文件的正确性 可选参数如下：-b 设置区块数目-C 切换到指定目录-f 指定压缩文件–help 显示帮助信息–version 显示版本信息 命令功能：用来压缩和解压文件。tar本身不具有压缩功能。他是调用压缩功能实现的 常见解压/压缩命令tar解包：tar xvf FileName.tar打包：tar cvf FileName.tar DirName（注：tar是打包，不是压缩！） .gz 解压1：gunzip FileName.gz解压2：gzip -d FileName.gz压缩：gzip FileName .tar.gz 和 .tgz解压：tar zxvf FileName.tar.gz压缩：tar zcvf FileName.tar.gz DirName .bz2解压1：bzip2 -d FileName.bz2解压2：bunzip2 FileName.bz2压缩： bzip2 -z FileName .tar.bz2解压：tar jxvf FileName.tar.bz2压缩：tar jcvf FileName.tar.bz2 DirName .bz解压1：bzip2 -d FileName.bz解压2：bunzip2 FileName.bz压缩：未知 .tar.bz解压：tar jxvf FileName.tar.bz压缩：未知 .Z解压：uncompress FileName.Z压缩：compress FileName .tar.Z解压：tar Zxvf FileName.tar.Z压缩：tar Zcvf FileName.tar.Z DirName .zip解压：unzip FileName.zip压缩：zip FileName.zip DirName .rar解压：rar x FileName.rar压缩：rar a FileName.rar DirName 常用范例例1：将文件全部打包成tar包tar -cvf log.tar log2012.logtar -zcvf log.tar.gz log2012.logtar -jcvf log.tar.bz2 log2012.logtar -cvf log.tar log2012.log 仅打包，不压缩！tar -zcvf log.tar.gz log2012.log 打包后，以 gzip 压缩tar -zcvf log.tar.bz2 log2012.log 打包后，以 bzip2 压缩在参数 f 之后的文件档名是自己取的，习惯上都用 .tar 来作为辨识。 如果加 z 参数，则 以 .tar.gz 或 .tgz 来代表 gzip 压缩过的 tar包； 如果加 j 参数，则以 .tar.bz2 来作为tar包名。 例2：查阅上述 tar包内有哪些文件tar -ztvf log.tar.gz由于使用 gzip 压缩的log.tar.gz，所以要查阅log.tar.gz包内的文件时，就得加上 z 这个参数。 例3：将tar 包解压缩tar -zxvf log.tar.gz 例4：只将 /tar 内的 部分文件解压出来tar -zxvf log.tar.gz 1.log 例5：文件备份下来，并且保存其权限(-p 的属性)tar -zcvpf log.tar.gz 1.log 2.log 3.log 例6：在 文件夹当中，比某个日期新的文件才备份tar -N “2012/11/13” -zcvf log.tar.gz test1 例7：备份文件夹内容是排除部分文件tar –exclude test1 -zcvf Test.tar.gz *除了test1外，其他都打包]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[linux命令学习之文件权限命令-chgrp命令]]></title>
      <url>%2F2017%2F03%2F30%2Flinux%E5%91%BD%E4%BB%A4%E5%AD%A6%E4%B9%A0-%E6%96%87%E4%BB%B6%E6%9D%83%E9%99%90%E4%B9%8Bchgrp%E5%91%BD%E4%BB%A4%2F</url>
      <content type="text"><![CDATA[chgrp简介 在lunix系统里，文件或目录的权限的掌控以拥有者及所属群组来管理。可以使用chgrp指令取变更文件与目录所属群组，这种方式采用群组名称或群组识别码都可以。Chgrp命令就是change group的缩写！要被改变的组名必须要在/etc/group文件内存在才行。 命令学习 命令格式：chgrp [选项] [组] [文件]命令功能：chgrp命令可采用群组名称或群组识别码的方式改变文件或目录的所属群组。使用权限是超级用户。命令参数：必要参数:-c 当发生改变时输出调试信息-f 不显示错误信息-R 处理指定目录以及其子目录下的所有文件-v 运行时显示详细的处理信息–dereference 作用于符号链接的指向，而不是符号链接本身–no-dereference 作用于符号链接本身选择参数:–reference=&lt;文件或者目录&gt;–help 显示帮助信息–version 显示版本信息 常用范例 例1：改变文件的群组属性chgrp -v test 1.log先建立test工作组，将1.log文件群组改为test群组例2：根据指定文件改变文件的群组属性chgrp –reference=1.log 2.log改变文件2.log 的群组属性，使得文件2.log的群组属性和参考文件1.log的群组属性相同例3：改变指定目录以及其子目录下的所有文件的群组属性chgrp -R test test1改变指定目录以及其子目录下的所有文件的群组属性 例4：通过群组识别码改变文件群组属性chgrp -R 1001 1.log通过群组识别码改变文件群组属性，1001为test群组的识别码，具体群组和群组识别码可以cat /etc/group查看]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[linux命令学习之文件目录命令-chmod命令]]></title>
      <url>%2F2017%2F03%2F30%2Flinux%E5%91%BD%E4%BB%A4%E5%AD%A6%E4%B9%A0-%E6%96%87%E4%BB%B6%E6%9D%83%E9%99%90%E4%B9%8Bchmod%E5%91%BD%E4%BB%A4%20-%20%E5%89%AF%E6%9C%AC%2F</url>
      <content type="text"><![CDATA[chmod简介chmod命令用于改变linux系统文件或目录的访问权限。用它控制文件或目录的访问权限。该命令有两种用法。一种是包含字母和操作符表达式的文字设定法；另一种是包含数字的数字设定法。Linux系统中的每个文件和目录都有访问许可权限，用它来确定谁可以通过何种方式对文件和目录进行访问和操作。 文件或目录的访问权限分为只读，只写和可执行三种。以文件为例，只读权限表示只允许读其内容，而禁止对其做任何的更改操作。可执行权限表示允许将该文件作为一个程序执行。文件被创建时，文件所有者自动拥有对该文件的读、写和可执行权限，以便于对文件的阅读和修改。用户也可根据需要把访问权限设置为需要的任何组合。 有三种不同类型的用户可对文件或目录进行访问：文件所有者，同组用户、其他用户。所有者一般是文件的创建者。所有者可以允许同组用户有权访问文件，还可以将文件的访问权限赋予系统中的其他用户。在这种情况下，系统中每一位用户都能访问该用户拥有的文件或目录。 每一文件或目录的访问权限都有三组，每组用三位表示，分别为文件属主的读、写和执行权限；与属主同组的用户的读、写和执行权限；系统中其他用户的读、写和执行权限。当用ls -l命令显示文件或目录的详细信息时，最左边的一列为文件的访问权限列表的列定义如下：[权限属性信息] [连接数] [拥有者] [拥有者所属用户组] [大小] [最后修改时间] [文件名] 权限属性列表为10个字符：第一个字符表示文件类型，d为目录 -为普通文件 l为连接 b为可存储的接口设备 c为键盘鼠标等输入设备2、3、4个字符表示所有者权限，5、6、7个字符表示所有者同组用户权限，8、9、10为其他用户权限第二个字符表示所有者读权限，如果有权限则为r，没有权限则为-第三个字符表示所有者写权限，如果有权限则为w，没有权限则为-第四个字符表示所有者执行权限，如果有权限则为x，没有权限则为-第五个字符表示所有者同组用户读权限，如果有权限则为r，没有权限则为-第六个字符表示所有者同组用户写权限，如果有权限则为w，没有权限则为-第七个字符表示所有者同组用户执行权限，如果有权限则为x，没有权限则为-第八个字符表示其他非同组读权限，如果有权限则为r，没有权限则为-第九个字符表示其他非同组写权限，如果有权限则为w，没有权限则为-第十个字符表示其他非同组执行权限，如果有权限则为x，没有权限则为- 命令学习命令格式:chmod [-cfvR] [–help] [–version] mode file命令功能：用于改变文件或目录的访问权限，用它控制文件或目录的访问权限。命令参数：必要参数：-c 当发生改变时，报告处理信息-f 错误信息不输出-R 处理指定目录以及其子目录下的所有文件-v 运行时显示详细处理信息 选择参数：–reference=&lt;目录或者文件&gt; 设置成具有指定目录或者文件具有相同的权限–version 显示版本信息 &lt;权限范围&gt;+&lt;权限设置&gt; 使权限范围内的目录或者文件具有指定的权限&lt;权限范围&gt;-&lt;权限设置&gt; 删除权限范围的目录或者文件的指定权限 &lt;权限范围&gt;=&lt;权限设置&gt; 设置权限范围内的目录或者文件的权限为指定的值 权限范围：u ：目录或者文件的当前的用户g ：目录或者文件的当前的群组o ：除了目录或者文件的当前用户或群组之外的用户或者群组a ：所有的用户及群组 权限设置：r ：读权限，用数字4表示w ：写权限，用数字2表示x ：执行权限，用数字1表示- ：删除权限，用数字0表示s ：特殊权限 Linux 文件的基本属性有9个，分别是 owner/group/others组别的read/write/excute属性。该命令有两种用法。一种是包含字母和操作符表达式的文字设定法；另一种是包含数字的数字设定法。1）文字设定法:如果想把一个文件属性设置为 -rwxr-xr–，可以这样： chmod u=rwx,g=rx,o=r filename如果不知道文件的原先属性，但想增加其的每人均可写入的权限，可以这样：chmod a+w filename去掉所有人的x属性：chmod a-x filename2）数字设定法 数字表示：r:4 w:2 x:1例子：将同一组(owner/group/others)的3个属性(r/w/x)累加，如当前属性为[-rwxrwx—]，则是：owner=rwx=4+2+1=7group=rwx=4+2+1=7others= — =0+0+0=0该属性为770.chmod 777 filename 常用范例例1：增加文件所有用户组可执行权限chmod a+x 1.loga ：所有的用户及群组即：文件属主（u） 增加执行权限；与文件属主同组用户（g） 增加执行权限；其他用户（o） 增加执行权限 例2：同时修改不同用户权限chmod ug+r,o-w 2.log文件属主（u） 增加读权限;与文件属主同组用户（g） 增加读权限;其他用户（o） 删除写权限 例3：删除文件权限chmod a-r 2.log删除所有用户的读权限 例4：使用“=”设置权限chmod u=rwx,g=rwx,o=rwz 2.log撤销原来所有的权限，然后使其具有新的权限 例5：对一个目录及其子目录所有文件添加权限chmod -R u+x test1]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[linux命令学习之文件目录命令-chmod命令]]></title>
      <url>%2F2017%2F03%2F30%2Flinux%E5%91%BD%E4%BB%A4%E5%AD%A6%E4%B9%A0-%E6%96%87%E4%BB%B6%E6%9D%83%E9%99%90%E4%B9%8Bchmod%E5%91%BD%E4%BB%A4%2F</url>
      <content type="text"><![CDATA[chmod简介chmod命令用于改变linux系统文件或目录的访问权限。用它控制文件或目录的访问权限。该命令有两种用法。一种是包含字母和操作符表达式的文字设定法；另一种是包含数字的数字设定法。Linux系统中的每个文件和目录都有访问许可权限，用它来确定谁可以通过何种方式对文件和目录进行访问和操作。 文件或目录的访问权限分为只读，只写和可执行三种。以文件为例，只读权限表示只允许读其内容，而禁止对其做任何的更改操作。可执行权限表示允许将该文件作为一个程序执行。文件被创建时，文件所有者自动拥有对该文件的读、写和可执行权限，以便于对文件的阅读和修改。用户也可根据需要把访问权限设置为需要的任何组合。 有三种不同类型的用户可对文件或目录进行访问：文件所有者，同组用户、其他用户。所有者一般是文件的创建者。所有者可以允许同组用户有权访问文件，还可以将文件的访问权限赋予系统中的其他用户。在这种情况下，系统中每一位用户都能访问该用户拥有的文件或目录。 每一文件或目录的访问权限都有三组，每组用三位表示，分别为文件属主的读、写和执行权限；与属主同组的用户的读、写和执行权限；系统中其他用户的读、写和执行权限。当用ls -l命令显示文件或目录的详细信息时，最左边的一列为文件的访问权限列表的列定义如下：[权限属性信息] [连接数] [拥有者] [拥有者所属用户组] [大小] [最后修改时间] [文件名] 权限属性列表为10个字符：第一个字符表示文件类型，d为目录 -为普通文件 l为连接 b为可存储的接口设备 c为键盘鼠标等输入设备2、3、4个字符表示所有者权限，5、6、7个字符表示所有者同组用户权限，8、9、10为其他用户权限第二个字符表示所有者读权限，如果有权限则为r，没有权限则为-第三个字符表示所有者写权限，如果有权限则为w，没有权限则为-第四个字符表示所有者执行权限，如果有权限则为x，没有权限则为-第五个字符表示所有者同组用户读权限，如果有权限则为r，没有权限则为-第六个字符表示所有者同组用户写权限，如果有权限则为w，没有权限则为-第七个字符表示所有者同组用户执行权限，如果有权限则为x，没有权限则为-第八个字符表示其他非同组读权限，如果有权限则为r，没有权限则为-第九个字符表示其他非同组写权限，如果有权限则为w，没有权限则为-第十个字符表示其他非同组执行权限，如果有权限则为x，没有权限则为- 命令学习命令格式:chmod [-cfvR] [–help] [–version] mode file命令功能：用于改变文件或目录的访问权限，用它控制文件或目录的访问权限。命令参数：必要参数：-c 当发生改变时，报告处理信息-f 错误信息不输出-R 处理指定目录以及其子目录下的所有文件-v 运行时显示详细处理信息 选择参数：–reference=&lt;目录或者文件&gt; 设置成具有指定目录或者文件具有相同的权限–version 显示版本信息 &lt;权限范围&gt;+&lt;权限设置&gt; 使权限范围内的目录或者文件具有指定的权限&lt;权限范围&gt;-&lt;权限设置&gt; 删除权限范围的目录或者文件的指定权限 &lt;权限范围&gt;=&lt;权限设置&gt; 设置权限范围内的目录或者文件的权限为指定的值 权限范围：u ：目录或者文件的当前的用户g ：目录或者文件的当前的群组o ：除了目录或者文件的当前用户或群组之外的用户或者群组a ：所有的用户及群组 权限设置：r ：读权限，用数字4表示w ：写权限，用数字2表示x ：执行权限，用数字1表示- ：删除权限，用数字0表示s ：特殊权限 Linux 文件的基本属性有9个，分别是 owner/group/others组别的read/write/excute属性。该命令有两种用法。一种是包含字母和操作符表达式的文字设定法；另一种是包含数字的数字设定法。1）文字设定法:如果想把一个文件属性设置为 -rwxr-xr–，可以这样： chmod u=rwx,g=rx,o=r filename如果不知道文件的原先属性，但想增加其的每人均可写入的权限，可以这样：chmod a+w filename去掉所有人的x属性：chmod a-x filename2）数字设定法 数字表示：r:4 w:2 x:1例子：将同一组(owner/group/others)的3个属性(r/w/x)累加，如当前属性为[-rwxrwx—]，则是：owner=rwx=4+2+1=7group=rwx=4+2+1=7others= — =0+0+0=0该属性为770.chmod 777 filename 常用范例例1：增加文件所有用户组可执行权限chmod a+x 1.loga ：所有的用户及群组即：文件属主（u） 增加执行权限；与文件属主同组用户（g） 增加执行权限；其他用户（o） 增加执行权限 例2：同时修改不同用户权限chmod ug+r,o-w 2.log文件属主（u） 增加读权限;与文件属主同组用户（g） 增加读权限;其他用户（o） 删除写权限 例3：删除文件权限chmod a-r 2.log删除所有用户的读权限 例4：使用“=”设置权限chmod u=rwx,g=rwx,o=rwz 2.log撤销原来所有的权限，然后使其具有新的权限 例5：对一个目录及其子目录所有文件添加权限chmod -R u+x test1]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[linux命令学习之文件目录命令-chown命令]]></title>
      <url>%2F2017%2F03%2F30%2Flinux%E5%91%BD%E4%BB%A4%E5%AD%A6%E4%B9%A0-%E6%96%87%E4%BB%B6%E6%9D%83%E9%99%90%E4%B9%8Bchown%E5%91%BD%E4%BB%A4%2F</url>
      <content type="text"><![CDATA[chown简介 chown将指定文件的拥有者改为指定的用户或组，用户可以是用户名或者用户ID；组可以是组名或者组ID； 文件是以空格分开的要改变权限的文件列表，支持通配符。系统管理员经常使用chown命令，在将文件拷贝到另一个用户的名录下之后，让用户拥有使用该文件的权限。 命令学习 命令格式： chown [选项] [所有者][:[组]] 文件… 命令功能：通过chown改变文件的拥有者和群组。在更改文件的所有者或所属群组时，可以使用用户名称和用户识别码设置。普通用户不能将自己的文件改变成其他的拥有者。其操作权限一般为管理员。 命令参数：必要参数:-c 显示更改的部分的信息-f 忽略错误信息-h 修复符号链接-R 处理指定目录以及其子目录下的所有文件-v 显示详细的处理信息-deference 作用于符号链接的指向，而不是链接文件本身 选择参数:–reference=&lt;目录或文件&gt; 把指定的目录/文件作为参考，把操作的文件/目录设置成参考文件/目录相同拥有者和群组–from=&lt;当前用户：当前群组&gt; 只有当前用户和群组跟指定的用户和群组相同时才进行改变–help 显示帮助信息–version 显示版本信息 常用范例 例1：改变拥有者和群组 chown root:jiangbiao 1.log当为root: 以及jiangbiao: 形式时，工作组默认与拥有者一样例3：改变文件群组 例4：改变指定目录以及其子目录下的所有文件的拥有者和群组chown -R -v root:test test1]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[linux命令学习之文件查找命令-locate命令]]></title>
      <url>%2F2017%2F03%2F30%2Flinux%E5%91%BD%E4%BB%A4%E5%AD%A6%E4%B9%A0-%E6%96%87%E4%BB%B6%E6%9F%A5%E6%89%BE%E4%B9%8Blocate%E5%91%BD%E4%BB%A4%2F</url>
      <content type="text"><![CDATA[locate简介locate让使用者可以很快速的搜寻档案系统内是否有指定的档案。其方法是先建立一个包括系统内所有档案名称及路径的数据库，之后当寻找时就只需查询这个数据库，而不必实际深入档案系统之中了。在一般的 distribution 之中，数据库的建立都被放在 crontab 中自动执行。 命令学习命令格式：Locate [选择参数] [样式] 命令功能：locate命令可以在搜寻数据库时快速找到档案，数据库由updatedb程序来更新，updatedb是由cron daemon周期性建立的，locate命令在搜寻数据库时比由整个由硬盘资料来搜寻资料来得快，但较差劲的是locate所找到的档案若是最近才建立或 刚更名的，可能会找不到，在内定值中，updatedb每天会跑一次，可以由修改crontab来更新设定值。(etc/crontab)locate指定用在搜寻符合条件的档案，它会去储存档案与目录名称的数据库内，寻找合乎范本样式条件的档案或目录录，可以使用特殊字元（如”” 或”?”等）来指定范本样式，如指定范本为kcpaner, locate会找出所有起始字串为kcpa且结尾为ner的档案或目录locate指令和find找寻档案的功能类似，但locate是透过update程序将硬盘中的所有档案和目录资料先建立一个索引数据库，在 执行loacte时直接找该索引，查询速度会较快，索引数据库一般是由操作系统管理，但也可以直接下达update强迫系统立即修改索引数据库。 命令参数：-e 将排除在寻找的范围之外。-1 如果是 1．则启动安全模式。在安全模式下，使用者不会看到权限无法看到的档案。这会使速度减慢，因为 locate 必须至实际的档案系统中取得档案的 权限资料。-f 将特定的档案系统排除在外，例如我们没有到理要把 proc 档案系统中的档案 放在资料库中。-q 安静模式，不会显示任何错误讯息。-n 至多显示 n个输出。-r 使用正规运算式 做寻找的条件。-o 指定资料库存的名称。-d 指定资料库的路径-h 显示辅助讯息-V 显示程式的版本讯息 常用范例例1:查找和pwd相关的所有文件locate pwd 例2： 搜索etc目录下所有以sh开头的文件locate /etc/sh 例3：搜索etc目录下，所有以m开头的文件locate /etc/m]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[linux命令学习之文件查找命令-whereis命令]]></title>
      <url>%2F2017%2F03%2F30%2Flinux%E5%91%BD%E4%BB%A4%E5%AD%A6%E4%B9%A0-%E6%96%87%E4%BB%B6%E6%9F%A5%E6%89%BE%E4%B9%8Bwhereis%E5%91%BD%E4%BB%A4%2F</url>
      <content type="text"><![CDATA[whereis简介whereis命令只能用于程序名的搜索，而且只搜索二进制文件（参数-b）、说明文件（参数-m）和源代码文件（参数-s）。如果省略参数，则返回所有信息。和find相比，whereis查找的速度非常快，这是因为linux系统会将 系统内的所有文件都记录在一个数据库文件中，当使用whereis和locate时，会从数据库中查找数据，而不是像find命令那样，通过遍历硬盘来查找，效率自然会很高。但是该数据库文件并不是实时更新，默认情况下时一星期更新一次，因此，我们在用whereis和locate 查找文件时，有时会找到已经被删除的数据，或者刚刚建立文件，却无法查找到，原因就是因为数据库文件没有被更新。 命令学习命令格式：whereis [-bmsu] [BMS 目录名 -f ] 文件名命令功能：whereis命令是定位可执行文件、源代码文件、帮助文件在文件系统中的位置。这些文件的属性应属于原始代码，二进制文件，或是帮助文件。whereis 程序还具有搜索源代码、指定备用搜索路径和搜索不寻常项的能力。命令参数：-b 定位可执行文件。-m 定位帮助文件。-s 定位源代码文件。-u 搜索默认路径下除可执行文件、源代码文件、帮助文件以外的其它文件-B 指定搜索可执行文件的路径。-M 指定搜索帮助文件的路径。-S 指定搜索源代码文件的路径。 常用范例例1:指令”whereis”查看指令”bash”的位置]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[linux命令学习之文件查找命令-which命令]]></title>
      <url>%2F2017%2F03%2F30%2Flinux%E5%91%BD%E4%BB%A4%E5%AD%A6%E4%B9%A0-%E6%96%87%E4%BB%B6%E6%9F%A5%E6%89%BE%E4%B9%8Bwhich%E5%91%BD%E4%BB%A4%2F</url>
      <content type="text"><![CDATA[which简介经常在linux要查找某个文件，但不知道放在哪里了，可以使用下面的一些命令来搜索： which 查看可执行文件的位置。 whereis 查看文件的位置。 locate 配合数据库查看文件位置。 find 实际搜寻硬盘查询文件名称。which命令在PATH变量指定的路径中，搜索某个系统命令的位置，并且返回第一个搜索结果。也就是说，使用which命令，就可以看到某个系统命令是否存在，以及执行的到底是哪一个位置的命令。 命令学习命令格式：which 可执行文件名称命令功能：which指令会在PATH变量指定的路径中，搜索某个系统命令的位置，并且返回第一个搜索结果。命令参数：-n 指定文件名长度，指定的长度必须大于或等于所有文件中最长的文件名。-p 与-n参数相同，但此处的包括了文件的路径。-w 指定输出时栏位的宽度。-V 显示版本信息 常用范例例1：查找文件、显示命令路径cd 是bash 内建的命令，但是 which 默认是找 PATH 内所规范的目录，所以找不到 查找有别名的命令时会列出具体的别名信息]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[linux命令学习之文件目录命令-cat命令]]></title>
      <url>%2F2017%2F03%2F30%2Flinux%E5%91%BD%E4%BB%A4%E5%AD%A6%E4%B9%A0-%E6%96%87%E4%BB%B6%E7%9B%AE%E5%BD%95%E4%B9%8Bcat%E5%91%BD%E4%BB%A4%2F</url>
      <content type="text"><![CDATA[cat简介cat命令的用途是连接文件或标准输入并打印。常用来显示文件内容，或者将几个文件连接起来显示，或者从标准输入读取内容并显示，它常与重定向符号配合使用。 命令学习命令格式：cat [选项] [文件]命令功能：1.一次显示整个文件:cat filename2.从键盘创建一个文件:cat &gt; filename 只能创建新文件,不能编辑已有文件.3.将几个文件合并为一个文件:cat file1 file2 &gt; file命令参数：-b, –number-nonblank 对非空输出行编号-E, –show-ends 在每行结束处显示 $-n, –number 对输出的所有行编号,由1开始对所有输出的行数编号-s, –squeeze-blank 有连续两行以上的空白行，就代换为一行的空白行-T, –show-tabs 将跳格字符显示为 ^I-v, –show-nonprinting 显示非打印字符 常用范例例一：把 1.log 的文件内容加上行号后附加到2.log 文件里cat -n 1.log 2.log 例二：把1.log 的文件内容加上行号后覆盖2.log 文件（2.log存在）cat -n 1.log &gt; 2.log 2.log不存在时会先创建2.log这里&gt;与》的区别：》是追加，不会覆盖 例三：使用标准输入来创建文件 cat &gt;log.txt &lt;&lt;EOFtac (反向列示)tac log.txt]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[linux命令学习之文件目录命令-cd命令]]></title>
      <url>%2F2017%2F03%2F30%2Flinux%E5%91%BD%E4%BB%A4%E5%AD%A6%E4%B9%A0-%E6%96%87%E4%BB%B6%E7%9B%AE%E5%BD%95%E4%B9%8Bcd%E5%91%BD%E4%BB%A4%2F</url>
      <content type="text"><![CDATA[cd 命令学习命令格式：cd [dirname] 命令功能：切换当前目录至dirName 常用范例例一：进入系统根目录cd / 例一：进入用户主目录cd 或 cd ~ 例三：返回上层目录cd ..cd ../.. （返回上两级目录） 例四：返回进入此目录之前所在的目录cd - 例五：把上个命令的参数作为cd参数使用cd !$（相当于仍然执行上次操作，如果上次cd -,这次也cd -）]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[linux命令学习之文件目录命令-cp命令]]></title>
      <url>%2F2017%2F03%2F30%2Flinux%E5%91%BD%E4%BB%A4%E5%AD%A6%E4%B9%A0-%E6%96%87%E4%BB%B6%E7%9B%AE%E5%BD%95%E4%B9%8Bcp%E5%91%BD%E4%BB%A4%2F</url>
      <content type="text"><![CDATA[cp简介cp命令用来复制文件或者目录，一般情况下，shell会设置一个别名，在命令行下复制文件时，如果目标文件已经存在，就会询问是否覆盖，不管你是否使用-i参数。但是如果是在shell脚本中执行cp时，没有-i参数时不会询问是否覆盖。这说明命令行和shell脚本的执行方式有些不同。 命令学习命令格式：cp [选项] [-T] 源 目的或：cp [选项] 源 目录cp [选项]… -t 目录 源命令功能：将源文件复制至目标文件，或将多个源文件复制至目标目录。命令参数：-a, 为每个已存在的目标文件创建备份-b，类似–backup 但不接受参数，在递归处理是复制特殊文件内容-f, 如果目标文件无法打开则将其移除并重试(当-n选项存在时则不需再选此项)-i, 覆盖前询问(使前面的 -n 选项失效)-H，跟随源文件中的命令行符号链接-l, 链接文件而不复制-L, 总是跟随符号链接-n, 不要覆盖已存在的文件(使前面的 -i 选项失效)-P, 跟随源文件中的符号链接-p，等于–preserve=模式,所有权,时间戳，保持指定的属性(默认：模式,所有权,时间 戳)，如果可能保持附加属性：环境、链接、xattr 等-R, -r, 复制目录及目录内的所有项目 常用范例例一：复制单个文件到目标目录，文件在目标文件中不存在cp l.log test 例二：目标文件存在时，会询问是否覆盖cp 1.log test 例三：复制整个目录目标目录存在时： 整个源目录被复制到目标目录里面cp -a test3 test5目标目录不存在： 类似改名cp -a test3 test4 例四：复制的 log.log 建立一个连结档 log_link.logcp -s log.log log_link.log]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[linux命令学习之文件目录命令-head命令]]></title>
      <url>%2F2017%2F03%2F30%2Flinux%E5%91%BD%E4%BB%A4%E5%AD%A6%E4%B9%A0-%E6%96%87%E4%BB%B6%E7%9B%AE%E5%BD%95%E4%B9%8Bhead%E5%91%BD%E4%BB%A4%2F</url>
      <content type="text"><![CDATA[head简介head是用来显示开头某个数量的文字区块，显示档案的开头至标准输出中，与tai是查看档案的结尾 命令学习命令格式：head [参数] [文件]命令功能：显示档案的开头至标准输出中，默认head命令打印其相应文件的开头10行。命令参数：-q 隐藏文件名-v 显示文件名-c&lt;字节&gt; 显示字节数-n&lt;行数&gt; 显示的行数 常用范例例1：显示文件的前n行head -n 5 1.log 例2：显示文件前n个字节head -c 20 1.log 例3：文件的除了最后n个字节以外的内容head -c -32 1.log 例4：输出文件除了最后n行的全部内容head -n -6 log2014.log]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[linux命令学习之文件目录命令-find命令]]></title>
      <url>%2F2017%2F03%2F30%2Flinux%E5%91%BD%E4%BB%A4%E5%AD%A6%E4%B9%A0-%E6%96%87%E4%BB%B6%E7%9B%AE%E5%BD%95%E4%B9%8Bfind%E5%91%BD%E4%BB%A4%2F</url>
      <content type="text"><![CDATA[find简介Linux下find命令在目录结构中搜索文件，并执行指定的操作。find命令提供了相当多的查找条件，功能很强大。即使系统中含有网络文件系统( NFS)，find命令在该文件系统中同样有效，只你具有相应的权限。 在运行一个非常消耗资源的find命令时，很多人都倾向于把它放在后台执行，因为遍历一个大的文件系统可能会花费很长的时间(这里是指30G字节以上的文件系统)。 命令学习命令格式：find pathname -options [-print -exec -ok …] 命令功能：用于在文件树种查找文件，并作出相应的处理 命令参数：pathname: find命令所查找的目录路径。例如用.来表示当前目录，用/来表示系统根目录。-print： find命令将匹配的文件输出到标准输出。-exec： find命令对匹配的文件执行该参数所给出的shell命令。相应命令的形式为’command’ { } \;，注意{ }和\；之间的空格。-ok： 和-exec的作用相同，只不过以一种更为安全的模式来执行该参数所给出的shell命令，在执行每一个命令之前，都会给出提示，让用户来确定是否执行。 命令选项：-name 按照文件名查找文件。-perm 按照文件权限来查找文件。-prune 使用这一选项可以使find命令不在当前指定的目录中查找，如果同时使用-depth选项，那么-prune将被find命令忽略。-user 按照文件属主来查找文件。-group 按照文件所属的组来查找文件。-mtime -n +n 按照文件的更改时间来查找文件， - n表示文件更改时间距现在n天以内，+ n表示文件更改时间距现在n天以前。find命令还有-atime和-ctime 选项，但它们都和-m time选项。-nogroup 查找无有效所属组的文件，即该文件所属的组在/etc/groups中不存在。-nouser 查找无有效属主的文件，即该文件的属主在/etc/passwd中不存在。-newer file1 ! file2 查找更改时间比文件file1新但比文件file2旧的文件。-type 查找某一类型的文件，诸如：b - 块设备文件。d - 目录。c - 字符设备文件。p - 管道文件。l - 符号链接文件。f - 普通文件。-size n：[c] 查找文件长度为n块的文件，带有c时表示文件长度以字节计。-depth：在查找文件时，首先查找当前目录中的文件，然后再在其子目录中查找。-fstype：查找位于某一类型文件系统中的文件，这些文件系统类型通常可以在配置文件/etc/fstab中找到，该配置文件中包含了本系统中有关文件系统的信息。-mount：在查找文件时不跨越文件系统mount点。-follow：如果find命令遇到符号链接文件，就跟踪至链接所指向的文件。-cpio：对匹配的文件使用cpio命令，将这些文件备份到磁带设备中。另外,下面三个的区别:-amin n 查找系统中最后N分钟访问的文件-atime n 查找系统中最后n24小时访问的文件-cmin n 查找系统中最后N分钟被改变文件状态的文件-ctime n 查找系统中最后n24小时被改变文件状态的文件-mmin n 查找系统中最后N分钟被改变文件数据的文件-mtime n 查找系统中最后n*24小时被改变文件数据的文件 常用范例例1：查找指定时间内修改过的文件find -atime -2查找48小时内修改过的文件 例2：根据关键字查找find . -name “*.log”当前目录查找 以.log结尾的文件。 “. “代表当前目录 例3：按照目录或文件的权限来查找文件find ~/Test/ -perm 777 例4：按类型查找find . -type f -name “*.log”查找当前目录，以.log结尾的普通文件 例5：查找当前所有目录并排序find . -type d | sort 例6：按大小查找文件find . -size +1000c -print查找当前目录大于1K的文件]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[linux命令学习之文件目录命令-less命令]]></title>
      <url>%2F2017%2F03%2F30%2Flinux%E5%91%BD%E4%BB%A4%E5%AD%A6%E4%B9%A0-%E6%96%87%E4%BB%B6%E7%9B%AE%E5%BD%95%E4%B9%8Bless%E5%91%BD%E4%BB%A4%2F</url>
      <content type="text"><![CDATA[less简介less工具也是对文件或其它输出进行分页显示的工具，功能极其强大。less 的用法比起 more 更加的有弹性。在more的时候，没有办法向前面翻，只能往后面看，但若使用了 less 时，就可以使用 [pageup] [pagedown] 等按键的功能来往前往后翻看文件，更容易用来查看一个文件的内容！除此之外，在 less 里头可以拥有更多的搜索功能，不止可以向下搜，也可以向上搜。 命令简介命令格式：less [参数] 文件命令功能：less 与 more 类似，但使用 less 可以随意浏览文件，而 more 仅能向前移动，却不能向后移动，less在查看之前不会加载整个文件命令参数：-b &lt;缓冲区大小&gt; 设置缓冲区的大小-e 当文件显示结束后，自动离开-f 强迫打开特殊文件，例如外围设备代号、目录和二进制文件-g 只标志最后搜索的关键词-i 忽略搜索时的大小写-m 显示类似more命令的百分比-N 显示每行的行号-o &lt;文件名&gt; 将less 输出的内容在指定文件中保存起来-Q 不使用警告音-s 显示连续空行为一行-S 行过长时间将超出部分舍弃-x &lt;数字&gt; 将“tab”键显示为规定的数字空格/字符串：向下搜索“字符串”的功能?字符串：向上搜索“字符串”的功能n：重复前一个搜索（与 / 或 ? 有关）N：反向重复前一个搜索（与 / 或 ? 有关）b 向后翻一页d 向后翻半页h 显示帮助界面Q 退出less 命令u 向前滚动半页y 向前滚动一行空格键 滚动一行回车键 滚动一页[pagedown]： 向下翻动一页[pageup]： 向上翻动一页 常用范例例1：查看文件less 1.log 例2：ps查看进程信息并通过less分页显示ps -ef |less 例3：查看命令历史使用记录并通过less分页显示history | less 例4：浏览多个文件Less 1.log 2.log输入 ：n后，切换到 2.log输入 ：p后, 切换到 1.log 附加备注全屏导航ctrl + F - 向前移动一屏ctrl + B - 向后移动一屏ctrl + D - 向前移动半屏ctrl + U - 向后移动半屏 单行导航j - 向前移动一行k - 向后移动一行 其它导航G - 移动到最后一行g - 移动到第一行q / ZZ - 退出 less 命令 其它有用的命令v - 使用配置的编辑器编辑当前文件h - 显示 less 的帮助文档&amp;pattern - 仅显示匹配模式的行，而不是整个文件 标记导航当使用 less 查看大文件时，可以在任何一个位置作标记，可以通过命令导航到标有特定标记的文本位置：ma - 使用 a 标记文本的当前位置‘a - 导航到标记 a 处]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[linux命令学习之文件目录命令-ls命令]]></title>
      <url>%2F2017%2F03%2F30%2Flinux%E5%91%BD%E4%BB%A4%E5%AD%A6%E4%B9%A0-%E6%96%87%E4%BB%B6%E7%9B%AE%E5%BD%95%E4%B9%8Bls%E5%91%BD%E4%BB%A4%2F</url>
      <content type="text"><![CDATA[ls简介&nbsp;ls用来打印出当前目录的清单，如果ls指定目录那么就会显示指定目录里的文件及文件夹清单。 通过ls 命令不仅可以查看linux文件夹包含的文件，而且可以查看文件权限(包括目录、文件夹、文件权限)，目录信息等等。 命令学习命令格式：ls [选项] [目录名]命令功能：列出目标目录中所有的子目录和文件常用参数：-a 列出目录下的所有文件，包括以 . 开头的隐含文件-b 把文件名中不可输出的字符用反斜杠加字符编号的形式列出。-c 输出文件的 i 节点的修改时间，并以此排序。-d 将目录象文件一样显示，而不是显示其下的文件。-e 输出时间的全部信息，而不是输出简略信息。-i 输出文件的 i 节点的索引信息。-k 以 k 字节的形式表示文件的大小。-l 列出文件的详细信息。-m 横向输出文件名，并以“，”作分格符。-n 用数字的 UID,GID 代替名称。-o 显示文件的除组信息外的详细信息。-p -F 在每个文件名后附上一个字符以说明该文件的类型，“”表示可执行的普通文件；“/”表示目录；“@”表示符号链接；“|”表示FIFOs；“=”表示套接字(sockets)-q 用?代替不可输出的字符。-r 对目录反向排序。-s 在每个文件名后输出该文件的大小。-t 以时间排序。-u 以文件上次被访问的时间排序。-x 按列输出，横向排序。-A 显示除 “.”和“..”外的所有文件。-B 不输出以 “~”结尾的备份文件。-C 按列输出，纵向排序。-G 输出文件的组的信息。-L 列出链接文件名而不是链接到的文件。-N 不限制文件长度。-Q 把输出的文件名用双引号括起来。-R 列出所有子目录下的文件。*-S 以文件大小排序。-X 以文件的扩展名(最后一个 . 后的字符)排序。-1 一行只输出一个文件。–color=no 不显示彩色文件名–help 在标准输出上显示帮助信息。–version 在标准输出上输出版本信息并退出。 常用范例例一：列出/home/文件夹下的所有文件和目录的详细资料ls -l -R /home/Testls -lR /home/peidachang(参数可以一起) 例二：列出当前目录中所有以“t”开头的目录的详细内容ls -l t* 例三：只列出文件下的子目录ls -F /opt/soft |grep /$ 列出 /opt/soft 文件下面的子目录ls -l /opt/soft | grep “^d” 列出 /opt/soft 文件下面的子目录详细情况例四：列出目前工作目录下所有名称是s 开头的档案，愈新的排愈后面命令：ls -ltr s例五：计算当前目录下的文件数和目录数ls -l |grep “^-“|wc -l —文件个数ls -l * |grep “^d”|wc -l —目录个数例七: 在ls中列出文件的绝对路径ls | sed “s:^:pwd/:”例九：列出当前目录下的所有文件（包括隐藏文件）的绝对路径， 对目录不做递归命令：find $PWD -maxdepth 1 | xargs ls -ld例十：递归列出当前目录下的所有文件（包括隐藏文件）的绝对路径find $PWD | xargs ls -ld例十一：指定文件时间输出格式ls -tl –time-style=full-iso扩展： 显示彩色目录列表 打开/etc/bashrc, 加入如下一行: alias ls=”ls –color”下次启动bash时就可以像在Slackware里那样显示彩色的目录列表了, 其中颜色的含义如下: 蓝色–&gt;目录 绿色–&gt;可执行文件 红色–&gt;压缩文件 浅蓝色–&gt;链接文件 灰色–&gt;其他文件]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[linux命令学习之文件目录命令-mkdir命令]]></title>
      <url>%2F2017%2F03%2F30%2Flinux%E5%91%BD%E4%BB%A4%E5%AD%A6%E4%B9%A0-%E6%96%87%E4%BB%B6%E7%9B%AE%E5%BD%95%E4%B9%8Bmkdir%E5%91%BD%E4%BB%A4%2F</url>
      <content type="text"><![CDATA[mkdir简介mkdir命令用来创建指定的名称的目录，要求创建目录的用户在当前目录中具有写权限，并且指定的目录名不能是当前目录中已有的目录。 mkdi学习命令格式：mkdir [选项] 目录…命令功能：mkdir 命令可以实现在指定位置创建以 DirName(指定的文件名)命名的文件夹或目录。要创建文件夹或目录的用户必须对所创建的文件夹的父文件夹具有写权限。并且，所创建的文件夹(目录)不能与其父目录(即父文件夹)中的文件名重名，即同一个目录下不能有同名的(区分大小写)。命令参数：-m,设定权限&lt;模式&gt; (类似 chmod)-p,可以是一个路径名称。此时若路径中的某些目录尚不存在,加上此选项 后,系统将自动建立好那些尚不存在的目录,即一次可以建立多个目录-v, –verbose 每次创建新目录都显示信息–help 显示此帮助信息并退出–version 输出版本信息并退出 常用范例例1：创建一个空目录mkdir test1 例2:递归创建多个目录mkdir -p test2/test22创建test2目录，且在test2目录下创建子目录test22 例3：创建权限为777的目录mkdir -m 777 test3 例4：创建新目录都显示信息mkdir -v test4 例五：一个命令创建项目的目录结构mkdir -vp test2/{test22/,test23/,test24/{test31,test32},test25/test33/{test34,test35}}]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[linux命令学习之文件目录命令-more命令]]></title>
      <url>%2F2017%2F03%2F30%2Flinux%E5%91%BD%E4%BB%A4%E5%AD%A6%E4%B9%A0-%E6%96%87%E4%BB%B6%E7%9B%AE%E5%BD%95%E4%B9%8Bmore%E5%91%BD%E4%BB%A4%2F</url>
      <content type="text"><![CDATA[more简介more命令，功能类似 cat ，cat命令是整个文件的内容从上到下显示在屏幕上。 more会以一页一页的显示方便使用者逐页阅读，而最基本的指令就是按空白键（space）就往下一页显示，按 b 键就会往回（back）一页显示，而且还有搜寻字串的功能 。more命令从前向后读取文件，因此在启动时就加载整个文件。 命令学习命令格式：more [-dlfpcsu ] [-num ] [+/ pattern] [+ linenum] [file … ]命令功能： more命令和cat的功能一样都是查看文件里的内容，但有所不同的是more可以按页来查看文件的内容，还支持直接跳转行等功能。命令参数：+n 从笫n行开始显示-n 定义屏幕大小为n行+/pattern 在每个档案显示前搜寻该字串（pattern），然后从该字串前两行之后开始显示-c 从顶部清屏，然后显示-d 提示“Press space to continue，’q’ to quit（按空格键继续，按q键退出）”，禁用响铃功能-l 忽略Ctrl+l（换页）字符-p 通过清除窗口而不是滚屏来对文件进行换页，与-c选项相似-s 把连续的多个空行显示为一行-u 把文件内容中的下画线去掉 操作命令Enter 向下n行，需要定义。默认为1行Ctrl+F 向下滚动一屏空格键 向下滚动一屏Ctrl+B 返回上一屏= 输出当前行的行号：f 输出文件名和当前行的行号 V 调用vi编辑器!命令 调用Shell，并执行命令q 退出more 常用范例例1：显示文件中从第3行起的内容more +3 1.log 例2：从文件中查找第一个出现”b”字符串的行，并从该处前两行开始显示输出more +/b 1.log 例3：设定每屏显示行数more -5 1.log 例4：列一个目录下的文件，由于内容太多，会用more来分页显示(和管道 | 结合起来 )ls -l | more -3每页显示3个文件信息，按 Ctrl+F 或者 空格键 将会显示下3条文件信息]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[linux命令学习之文件目录命令-mv命令]]></title>
      <url>%2F2017%2F03%2F30%2Flinux%E5%91%BD%E4%BB%A4%E5%AD%A6%E4%B9%A0-%E6%96%87%E4%BB%B6%E7%9B%AE%E5%BD%95%E4%B9%8Bmv%E5%91%BD%E4%BB%A4%2F</url>
      <content type="text"><![CDATA[mv简介mv命令可以用来移动文件或者将文件改名（move (rename) files），经常用来备份文件或者目录 命令学习命令格式：mv [选项] 源文件或目录 目标文件或目录命令功能：根据mv命令中第二个参数类型（是目标文件还是目标目录），mv命令将文件重命名或将其移至一个新的目录中。当第二个参数类型是文件时，mv命令完成文件重命名，此时，源文件只能有一个（也可以是源目录名），它将所给的源文件或目录重命名为给定的目标文件名。当第二个参数是已存在的目录名称时，源文件或目录参数可以有多个，mv命令将各参数指定的源文件均移至目标目录中。在跨文件系统移动文件时，mv先拷贝，再将原有文件删除，而链至该文件的链接也将丢失。命令参数：-b ：若需覆盖文件，则覆盖前先行备份。-f ：force 强制的意思，如果目标文件已经存在，不会询问而直接覆盖-i ：若目标文件 (destination) 已经存在时，就会询问是否覆盖-u ：若目标文件已经存在，且 source 比较新，才会更新(update)-t ：指定mv的目标目录，该选项适用于移动多个源文件到一个目录的情况，此时目标目录在前，源文件在后。 常用范例例一：文件改名mv test.log test1.txttest.log 改为test1.txt 例二：移动文件mv test1.txt test3将test1.txt文件移到目录test3中 例三：将文件log1.txt,log2.txt,log3.txt移动到目录test3中。mv log1.txt log2.txt log3.txt test3将log1.txt ，log2.txt， log3.txt 三个文件移到 test3目录mv -t /opt/soft/test/test4/ log1.txt log2.txt log3.txt将三个文件移动到test4目录 例五：将文件file1改名为file2，即使file2存在，也是直接覆盖掉。mv -f log3.txt log2.txt 例六：目录的移动mv dir1 dir2如果目录dir2不存在，将目录dir1改名为dir2；否则，将dir1移动到dir2中 例7：移动当前文件夹下的所有文件到上一级目录mv * ../ 例8：把当前目录的一个子目录里的文件移动到另一个子目录里mv test3/*.txt test5]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[linux下SSH服务]]></title>
      <url>%2F2017%2F03%2F30%2Flinux%E4%B8%8BSSH%E6%9C%8D%E5%8A%A1%E8%BF%9C%E7%A8%8B%E7%99%BB%E5%85%A5%2F</url>
      <content type="text"><![CDATA[SSH原理SSH 是目前较可靠，专为远程登录会话和其他网络服务提供安全性的协议。利用SSH 协议可以有效防止远程管理过程中的信息泄露问题。SSH最初是UNIX系统上的一个程序，后来又迅速扩展到其他操作平台。SSH在正确使用时可弥补网络中的漏洞。SSH客户端适用于多种平台。从客户端来看，SSH提供两种级别的安全验证：第一种级别是基于口令的安全验证只要你知道自己帐号和口令，就可以登录到远程主机。所有传输的数据都会被加密， 但是不能保证你正在连接的服务器就是你想连接的服务器。这个过程如下：1）远程主机收到用户的登录请求，把自己的公钥发给用户。2）用户使用这个公钥，将登录密码加密后，发送回来。3）远程主机用自己的私钥，解密登录密码，如果密码正确，就同意用户登录。这种方式可能会有别的服务器在冒充真正的服务器，将公钥发送给客户端，客户端就会将密码加密后发送给冒充的服务器，冒充的服务器就可以拿自己的私钥获取到密码，也就是受到“中间人”这种方式的攻击。当第一次链接远程主机时，会提示您当前主机的“公钥指纹”，询问您是否继续，如果选择继续后就可以输入密码进行登录了，当远程的主机接受以后，该台服务器的公钥就会保存到~/.ssh/known_hosts文件中。第二种级别是基于密匙的安全验证需要依靠密匙，也就是必须为自己创建一对密匙，并把公用密匙放在需要访问的服务器上。如果你要连接到SSH服务器上，客户端软件就会向服务器发出请求，请求用你的密匙进行安全验证。服务器收到请求之后，先在该服务器上你的主目录下寻找你的公用密匙，然后把它和你发送过来的公用密匙进行比较。如果两个密匙一致，服务器就用公用密匙加密“质询”并把它发送给客户端软件。客户端软件收到“质询”之后就可以用你的私人密匙解密再把它发送给服务器。用这种方式，你必须知道自己密匙的口令。 但是，与第一种级别相比，第二种级别不需要在网络上传送口令。第二种级别不仅加密所有传送的数据，而且“中间人”这种攻击方式也是不可能的（因为他没有你的私人密匙）。但是整个登录的过程可能需要10秒，但是相比输入密码的方式来说10秒也不长。 安装SSHsudo apt-get updatesudo apt-get openssh-server openssh-client 配置SSHsudo gedit /etc/ssh/sshd_config”该文件下是SSH的相关配置，包括端口22。如下，允许root用户登入 启动SSHsudo ps -e |grep ssh”–&gt;回车–&gt;有sshd,说明ssh服务已经启动如果没有启动，”sudo service ssh start”–&gt;回车–&gt;ssh服务就会启动 查看SSH状态 SSH远程登入使用putty进行ssh远程登入，默认端口22第一次登录的时候，OpenSSH将会提示用户它不知道这台登录的主机，只要键入“yes”，就会把这台登录主机的“识别标记”加到“~/.ssh/know_hosts”文件中。第二次访问这台主机的时候就不会再显示这条提示信息了。然后，SSH提示用户输入远程主机上用户账号的口令。这样，就建立了SSH连接，这之后就可以象使用telnet那样方便地使用SSH了。 秘钥登入秘钥登入不要每次登入输入密码， 使用通信短语即可。使用的是secureCRT1，快速链接-公钥-属性设置-创建身份文件 2，按照生成向导一步步完成这里选择OpneSSH格式通行短语类似于密码作用，在登入时会用到，如下： 3，完成后，将公钥传入要登入的服务器（linux）,可以采用虚拟机的文件共享方式。本地公钥在公钥文件名下可看到 4，在服务器段，建立要登入用户的.SSH文件mkdir -p ~/.ssh &amp;&amp; chmod -R 700 ~/.sshchmod -R 600 ~/.ssh/ authorized_keys 5，将公钥文件的内容复制到authorized_keys中去（可直接粘贴复制） 6，在secrueCRT下，将公钥放在最前面，输入主机名，用户名接下来会提示输入通信短语，输入确定即可]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[linux命令学习之文件目录命令-rm命令]]></title>
      <url>%2F2017%2F03%2F30%2Flinux%E5%91%BD%E4%BB%A4%E5%AD%A6%E4%B9%A0-%E6%96%87%E4%BB%B6%E7%9B%AE%E5%BD%95%E4%B9%8Brm%E5%91%BD%E4%BB%A4%2F</url>
      <content type="text"><![CDATA[rm简介rm命令为删除一个目录中的一个或多个文件或目录，也可以某个目录及其下的所有文件及子目录均删除。对于链接文件，只是删除了链接，原有文件均保持不变rm是一个危险的命令，使用的时候要特别当心，否则整个系统就会毁在这个命令（比如在/（根目录）下执行rm * -rf）。所以，在执行rm之前最好先确认一下在哪个目录，到底要删除什么东西。 命令学习命令格式：rm [选项] 文件命令功能：删除一个目录中的一个或多个文件或目录，如果没有使用- r选项，则rm不会删除目录。如果使用 rm 来删除文件，通常仍可以将该文件恢复原状。命令参数：-f,忽略不存在的文件，从不给出提示。-i,进行交互式删除-r, -R,指示rm将参数中列出的全部目录和子目录均递归地删除。-v, –verbose 详细显示进行的步骤–help 显示此帮助信息并退出–version 输出版本信息并退出 常用范例例一：删除文件file，系统会先询问是否删除。rm filename 例二：强行删除file，系统不再提示rm -f filename 例三：删除任何.log文件；删除前逐一询问确认rm -i *.log 例四：将 test1子目录及子目录中所有档案删除rm -r test1 例七：自定义回收站功能myrm(){D=/tmp/$(date +%Y%m%d%H%M%S);//在/tmp文件夹中创建名为“当前日期”的文件//其中“date+%Y%m%d%H%M%S”是规定了日期的输出格式mkdir -p $D;//以变量D中的路径创建文件夹mv “$@” $D &amp;&amp; echo “moved to $D ok”;//将所要删除的文件移入变量D中的文件夹内，移入成功后，输出移动成功}]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[linux命令学习之文件目录命令-pwd命令]]></title>
      <url>%2F2017%2F03%2F30%2Flinux%E5%91%BD%E4%BB%A4%E5%AD%A6%E4%B9%A0-%E6%96%87%E4%BB%B6%E7%9B%AE%E5%BD%95%E4%B9%8Bpwd%E5%91%BD%E4%BB%A4%2F</url>
      <content type="text"><![CDATA[pwd简介pwd 命令查看”当前工作目录“的完整路径。每当在终端进行操作时，都会有一个当前工作目录。在不太确定当前位置时，使用pwd来判定当前目录在文件系统内的确切位置。 命令学习命令格式：pwd [选项] 目录命令功能：查看”当前工作目录“的完整路径常用参数：一般情况下不带任何参数如果目录是链接时：pwd -P 显示出实际路径，而连接（link）路径。pwd -L：与pwd -P完全相反，显示链接路径 环境变量PWD：显示当前工作路径的环境变量echo $PWD环境变量OLDPWD：显示上一次的工作路径echo $PWD注意：由于是环境变量，使用的时候需要加上$变量标志 内建命令pwd和外部命令/bin/pwd,二者的基本功能是一致的，但是在显示当前目录时，/bin/pwd显示得更准确些，而pwd容易被操作者糊弄常用范例例1：用 pwd 命令查看当前工作目录的完整路径pwd 例2：目录连接链接时，pwd -P 显示出实际路径，而非使用连接（link）路径pwd -p 例3：当前目录被删除了，而pwd命令仍然显示那个目录实例4：/bin/pwd/bin/pwd [选项]选项：-L 目录连接链接时，输出连接路径-P 输出物理路径]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[linux命令学习之文件目录命令-tail命令]]></title>
      <url>%2F2017%2F03%2F30%2Flinux%E5%91%BD%E4%BB%A4%E5%AD%A6%E4%B9%A0-%E6%96%87%E4%BB%B6%E7%9B%AE%E5%BD%95%E4%B9%8Btail%E5%91%BD%E4%BB%A4%2F</url>
      <content type="text"><![CDATA[tail简介tail命令从指定点开始将文件写到标准输出。使用tail命令的-f选项可以方便的查阅正在改变的日志文件,tail -f filename会把filename里最尾部的内容显示在屏幕上,并且不但刷新,使你看到最新的文件内容. 命令学习命令格式：tail[必要参数][选择参数][文件]命令功能：用于显示指定文件末尾内容，不指定文件时，作为输入信息进行处理。常用查看日志文件。命令参数：-f 循环读取-q 不显示处理信息-v 显示详细的处理信息-c&lt;数目&gt; 显示的字节数-n&lt;行数&gt; 显示行数–pid=PID 与-f合用,表示在进程ID,PID死掉之后结束.-q, –quiet, –silent 从不输出给出文件名的首部-s, –sleep-interval=S 与-f合用,表示在每次反复的间隔休眠S秒 常用实例例1：显示文件末尾内容tail -n 5 1.log显示文件最后5行内容 例3：从第3行开始显示文件tail -n +5 1.log]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[linux命令学习之文件目录命令-touch命令]]></title>
      <url>%2F2017%2F03%2F30%2Flinux%E5%91%BD%E4%BB%A4%E5%AD%A6%E4%B9%A0-%E6%96%87%E4%BB%B6%E7%9B%AE%E5%BD%95%E4%B9%8Btouch%E5%91%BD%E4%BB%A4%2F</url>
      <content type="text"><![CDATA[touch简介linux的touch命令不常用，一般在使用make的时候可能会用到，用来修改文件时间戳，或者新建一个不存在的文件 命令学习命令格式：touch [选项] 文件命令功能：可更改文档或目录的日期时间，包括存取时间和更改时间。命令参数：-a 只更改存取时间。-c 不建立任何文档。-d 使用指定的日期时间，而非现在的时间。参数是年月日-f 此参数将忽略不予处理，仅负责解决BSD版本touch指令的兼容性问题。-m 只更改变动时间。-r 把指定文档或目录的日期时间，统统设成和参考文档或目录的日期时间相同。-t 使用指定的日期时间，而非现在的时间。参数是年月日时分秒 常用范例例一：创建不存在的文件touch 1.log 2.log 例二：更改时间戳touch -r 1.log 2.log将2.log文件的时间改为与1.log相同 例二：修改为当前时间touch filename系统自动将文件修改时间更新为当前时间 例三：设定文件的时间戳touch -t 201211142234.50 1.log测试后发现不管是否为当月时间都是显示形式为年月日]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[linux命令学习之磁盘命令-du命令]]></title>
      <url>%2F2017%2F03%2F30%2Flinux%E5%91%BD%E4%BB%A4%E5%AD%A6%E4%B9%A0-%E7%A3%81%E7%9B%98%E5%91%BD%E4%BB%A4%E4%B9%8Bdu%E5%91%BD%E4%BB%A4%2F</url>
      <content type="text"><![CDATA[du简介 du命令也是查看使用空间的，但是与df命令不同的是du命令是对文件和目录磁盘使用的空间的查看。 命令学习 命令格式：du [选项][文件] 命令功能：显示每个文件和目录的磁盘使用空间。 命令参数：-a或-all 显示目录中个别文件的大小。-b或-bytes 显示目录或文件大小时，以byte为单位。-c或–total 除了显示个别目录或文件的大小外，同时也显示所有目录或文件的总和。-k或–kilobytes 以KB(1024bytes)为单位输出。-m或–megabytes 以MB为单位输出。-s或–summarize 仅显示总计，只列出最后加总的值。-h或–human-readable 以K，M，G为单位，提高信息的可读性。-x或–one-file-xystem 以一开始处理时的文件系统为准，若遇上其它不同的文件系统目录则略过。-L&lt;符号链接&gt;或–dereference&lt;符号链接&gt; 显示选项中所指定符号链接的源文件大小。-S或–separate-dirs 显示个别目录的大小时，并不含其子目录的大小。-X&lt;文件&gt;或–exclude-from=&lt;文件&gt; 在&lt;文件&gt;指定目录或文件。–exclude=&lt;目录或文件&gt; 略过指定的目录或文件。–max-depth=&lt;目录层数&gt; 超过指定层数的目录后，予以忽略。-D或–dereference-args 显示指定符号链接的源文件大小。-H或–si 与-h参数相同，但是K，M，G是以1000为换算单位。 -l或–count-links 重复计算硬件链接的文件。 常用范例 例1：显示目录或者文件所占空间du只显示当前目录下面的子目录的目录大小和当前目录的总的大小，最下面的当前目录的总大小 例2：显示指定文件所占空间du 1.log 例3：查看指定目录的所占空间du test1 例4：显示多个文件所占空间du 1.log 2.log 例5：只显示总和的大小 例6：方便阅读的格式显示 例7：文件和目录都显示du -h test1 例8：显示几个文件或目录各自占用磁盘空间的大小，还统计它们的总和du -c 1.log 2.log 例9：按照空间大小排序 du|sort -nr|more 例10：输出当前目录下各个子目录所使用的空间 du -h –max-depth=1表示深入的目录层数，为0则不深入子目录，1则进入第一层子目录]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[linux命令学习之ifconfig命令]]></title>
      <url>%2F2017%2F03%2F30%2Flinux%E5%91%BD%E4%BB%A4%E5%AD%A6%E4%B9%A0-%E7%BD%91%E7%BB%9C%E5%91%BD%E4%BB%A4%E4%B9%8Bifconfig%E5%91%BD%E4%BB%A4%2F</url>
      <content type="text"><![CDATA[ifconfig简介 通常需要以root身份登录或使用sudo以便在Linux机器上使用ifconfig工具。依赖于ifconfig命令中使用一些选项属性，ifconfig工具不仅可以被用来简单地获取网络接口配置信息，还可以修改这些配置。 用ifconfig命令配置的网卡信息，在网卡重启后机器重启后，配置就不存在。要想配置信息永远的存的电脑里，那就要修改网卡的配置文件了。 命令学习 命令格式：ifconfig [网络设备] [参数] 命令功能：ifconfig 命令用来查看和配置网络设备。当网络环境发生改变时可通过此命令对网络进行相应的配置。 命令参数：up 启动指定网络设备/网卡。down 关闭指定网络设备/网卡。该参数可以有效地阻止通过指定接口的IP信息流，如果想永久地关闭一个接口，我们还需要从核心路由表中将该接口的路由信息全部删除。arp 设置指定网卡是否支持ARP协议。-promisc 设置是否支持网卡的promiscuous模式，如果选择此参数，网卡将接收网络中发给它所有的数据包-allmulti 设置是否支持多播模式，如果选择此参数，网卡将接收网络中所有的多播数据包-a 显示全部接口信息-s 显示摘要信息（类似于 netstat -i）add 给指定网卡配置IPv6地址del 删除指定网卡的IPv6地址&lt;硬件地址&gt; 配置网卡最大的传输单元mtu&lt;字节数&gt; 设置网卡的最大传输单元 (bytes)netmask&lt;子网掩码&gt; 设置网卡的子网掩码。掩码可以是有前缀0x的32位十六进制数，也可以是用点分开的4个十进制数。如果不打算将网络分成子网，可以不管这一选项；如果要使用子网，那么请记住，网络中每一个系统必须有相同子网掩码。tunel 建立隧道dstaddr 设定一个远端地址，建立点对点通信-broadcast&lt;地址&gt; 为指定网卡设置广播协议-pointtopoint&lt;地址&gt; 为网卡设置点对点通讯协议multicast 为网卡设置组播标志address 为网卡设置IPv4地址txqueuelen&lt;长度&gt; 为网卡设置传输列队的长度 常用范例 例1：显示网络设备信息（激活状态的） eth0 表示第一块网卡， 其中硬件地址表示网卡的物理地址，可以看到目前这个网卡的物理地址(MAC地址）是 00:50:56:BF:26:20inet addr 用来表示网卡的IP地址，此网卡的 IP地址是 192.168.120.204广播地址 Bcast:192.168.120.255，掩码地址Mask:255.255.255.0lo 是表示主机的回坏地址，这个一般是用来测试一个网络程序，但又不想让局域网或外网的用户能够查看，只能在此台主机上运行和查看所用的网络接口。比如把 HTTPD服务器的指定到回坏地址，在浏览器输入 127.0.0.1 就能看到你所架WEB网站了。但只是您能看得到，局域网的其它主机或用户无从知道。第一行：连接类型：Ethernet（以太网）HWaddr（硬件mac地址）第二行：网卡的IP地址、子网、掩码第三行：UP（代表网卡开启状态）RUNNING（代表网卡的网线被接上）MULTICAST（支持组播） MTU:1500（最大传输单元）：1500字节第四、五行：接收、发送数据包情况统计第七行：接收、发送数据字节数统计信息。 例2：启动关闭指定网卡ifconfig eth0 upifconfig eth0 downifconfig eth0 up 为启动网卡eth0 ；ifconfig eth0 down 为关闭网卡eth0。ssh登陆linux服务器操作要小心，关闭了就不能开启了，除非你有多网卡。 例4：用ifconfig修改MAC地址 ifconfig eth0 down //关闭网卡ifconfig eth0 hw ether 00:AA:BB:CC:DD:EEifconfig eth0 up //启动网卡 例5：配置IP地址ifconfig eth0 192.168.120.56给eth0网卡配置IP地：192.168.120.56 ifconfig eth0 192.168.120.56 netmask 255.255.255.0给eth0网卡配置IP地址：192.168.120.56 ，并加上子掩码：255.255.255.0ifconfig eth0 192.168.120.56 netmask 255.255.255.0 broadcast 192.168.120.255给eth0网卡配置IP地址：192.168.120.56，加上子掩码：255.255.255.0，加上个广播地址： 192.168.120.255 例6：启用和关闭ARP协议ifconfig eth0 arp 开启网卡eth0 的arp协议ifconfig eth0 -arp 关闭网卡eth0 的arp协议； 例7：设置最大传输单元ifconfig eth0 mtu 1500设置能通过的最大数据包大小为 1500 bytes]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[linux命令学习之磁盘命令-df命令]]></title>
      <url>%2F2017%2F03%2F30%2Flinux%E5%91%BD%E4%BB%A4%E5%AD%A6%E4%B9%A0-%E7%A3%81%E7%9B%98%E5%91%BD%E4%BB%A4%E4%B9%8Bdf%E5%91%BD%E4%BB%A4%2F</url>
      <content type="text"><![CDATA[df命令简介 df命令的功能是用来检查linux服务器的文件系统的磁盘空间占用情况。可以利用该命令来获取硬盘被占用了多少空间，目前还剩下多少空间等信息。 命令学习命令格式：df [选项] [文件] 命令功能：显示指定磁盘文件的可用空间。如果没有文件名被指定，则所有当前被挂载的文件系统的可用空间将被显示。默认情况下，磁盘空间将以 1KB 为单位进行显示，除非环境变量 POSIXLY_CORRECT 被指定，那样将以512字节为单位进行显示 命令参数：必要参数：-a 全部文件系统列表-h 方便阅读方式显示-H 等于“-h”，但是计算式，1K=1000，而不是1K=1024-i 显示inode信息-k 区块为1024字节-l 只显示本地文件系统-m 区块为1048576字节–no-sync 忽略 sync 命令-P 输出格式为POSIX–sync 在取得磁盘信息前，先执行sync命令-T 文件系统类型 选择参数：–block-size=&lt;区块大小&gt; 指定区块大小-t&lt;文件系统类型&gt; 只显示选定文件系统的磁盘信息-x&lt;文件系统类型&gt; 不显示选定文件系统的磁盘信息–help 显示帮助信息–version 显示版本信息 常用范例例1：显示磁盘使用情况dflinux中df命令的输出清单的第1列是代表文件系统对应的设备文件的路径名（一般是硬盘上的分区）；第2列给出分区包含的数据块（1024字节）的数目；第3，4列分别表示已用的和可用的数据块数目。用户也许会感到奇怪的是，第3，4列块数之和不等于第2列中的块数。这是因为缺省的每个分区都留了少量空间供系统管理员使用。即使遇到普通用户空间已满的情况，管理员仍能登录和留有解决问题所需的工作空间。第5列已用% 列表示普通用户空间使用的百分比，即使这一数字达到100％，分区仍然留有系统管理员使用的空间。第6列挂载点列表示文件系统的挂载点。 例2：以inode模式来显示磁盘使用情况 df -i 例3：列出各文件系统的i节点使用情况 例5：列出文件系统的类型df -T 例6：以更易读的方式显示目前磁盘空间和使用情况 例7：显示所有的信息df –total]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[linux命令学习之网络命令-netstat命令]]></title>
      <url>%2F2017%2F03%2F30%2Flinux%E5%91%BD%E4%BB%A4%E5%AD%A6%E4%B9%A0-%E7%BD%91%E7%BB%9C%E5%91%BD%E4%BB%A4%E4%B9%8Bnetstat%E5%91%BD%E4%BB%A4%2F</url>
      <content type="text"><![CDATA[netstat简介netstat命令用于显示与IP、TCP、UDP和ICMP协议相关的统计数据，一般用于检验本机各端口的网络连接情况。netstat是在内核中访问网络及相关信息的程序，它能提供TCP连接，TCP和UDP监听，进程内存管理的相关报告。如果你的计算机有时候接收到的数据报导致出错数据或故障，你不必感到奇怪，TCP/IP可以容许这些类型的错误，并能够自动重发数据报。但如果累计的出错情况数目占到所接收的IP数据报相当大的百分比，或者它的数目正迅速增加，那么你就应该使用netstat查一查为什么会出现这些情况了。 命令学习命令格式：netstat [-acCeFghilMnNoprstuvVwx][-A&lt;网络类型&gt;][–ip] 命令功能：netstat用于显示与IP、TCP、UDP和ICMP协议相关的统计数据，一般用于检验本机各端口的网络连接情况。 命令参数：-a或–all 显示所有连线中的Socket。-A&lt;网络类型&gt;或–&lt;网络类型&gt; 列出该网络类型连线中的相关地址。-c或–continuous 持续列出网络状态。-C或–cache 显示路由器配置的快取信息。-e或–extend 显示网络其他相关信息。-F或–fib 显示FIB。-g或–groups 显示多重广播功能群组组员名单。-h或–help 在线帮助。-i或–interfaces 显示网络界面信息表单。-l或–listening 显示监控中的服务器的Socket。-M或–masquerade 显示伪装的网络连线。-n或–numeric 直接使用IP地址，而不通过域名服务器。-N或–netlink或–symbolic 显示网络硬件外围设备的符号连接名称。-o或–timers 显示计时器。-p或–programs 显示正在使用Socket的程序识别码和程序名称。-r或–route 显示Routing Table。-s或–statistice 显示网络工作信息统计表。-t或–tcp 显示TCP传输协议的连线状况。-u或–udp 显示UDP传输协议的连线状况。-v或–verbose 显示指令执行过程。-V或–version 显示版本信息。-w或–raw 显示RAW传输协议的连线状况。-x或–unix 此参数的效果和指定”-A unix”参数相同。–ip或–inet 此参数的效果和指定”-A inet”参数相同。 常用范例例1：无参数使用netstat 从整体上看，netstat的输出结果可以分为两个部分：一个是Active Internet connections，称为有源TCP连接，其中”Recv-Q”和”Send-Q”指的是接收队列和发送队列。这些数字一般都应该是0。如果不是则表示软件包正在队列中堆积。这种情况只能在非常少的情况见到。另一个是Active UNIX domain sockets，称为有源Unix域套接口(和网络套接字一样，但是只能用于本机通信，性能可以提高一倍)。Proto显示连接使用的协议,RefCnt表示连接到本套接口上的进程号,Types显示套接口的类型,State显示套接口当前的状态,Path表示连接到套接口的其它进程使用的路径名。套接口类型：-t ：TCP-u ：UDP-raw ：RAW类型–unix ：UNIX域类型–ax25 ：AX25类型–ipx ：ipx类型–netrom ：netrom类型状态说明：LISTEN：侦听来自远方的TCP端口的连接请求SYN-SENT：再发送连接请求后等待匹配的连接请求（如果有大量这样的状态包，检查是否中招了）SYN-RECEIVED：再收到和发送一个连接请求后等待对方对连接请求的确认（如有大量此状态，估计被flood攻击了）ESTABLISHED：代表一个打开的连接FIN-WAIT-1：等待远程TCP连接中断请求，或先前的连接中断请求的确认FIN-WAIT-2：从远程TCP等待连接中断请求CLOSE-WAIT：等待从本地用户发来的连接中断请求CLOSING：等待远程TCP对连接中断的确认LAST-ACK：等待原来的发向远程TCP的连接中断请求的确认（不是什么好东西，此项出现，检查是否被攻击）TIME-WAIT：等待足够的时间以确保远程TCP接收到连接中断请求的确认CLOSED：没有任何连接状态 例2：列出所有端口netstat -a 显示一个所有的有效连接信息列表，包括已建立的连接（ESTABLISHED），也包括监听连接请（LISTENING）的那些连接。 例3：显示当前UDP连接状况netstat -nu 例4：显示UDP端口号的使用情况netstat -apu 例5：显示网卡列表netstat -i 例6：显示组播组的关系netstat -g 例7：显示网络统计信息netstat -s 例8：显示监听的套接口netstat -l 例9：显示所有已建立的有效连接netstat -n 例10：显示关于以太网的统计数据netstat -e 用于显示关于以太网的统计数据。它列出的项目包括传送的数据报的总字节数、错误数、删除数、数据报的数量和广播的数量。这些统计数据既有发送的数据报数量，也有接收的数据报数量。这个选项可以用来统计一些基本的网络流量） 例11：显示关于路由表的信息netstat -r 例12：列出所有 tcp 端口netstat -at 例13：统计机器中网络连接各个状态个数netstat -a | awk ‘/^tcp/ {++S[$NF]} END {for(a in S) print a, S[a]}’ 例14：把状态全都取出来后使用uniq -c统计后再进行排序netstat -nat |awk ‘{print $6}’|sort|uniq -c 例15：查看连接某服务端口最多的的IP地址netstat -nat | grep “192.168.120.20:16067” |awk ‘{print $5}’|awk -F: ‘{print $4}’|sort|uniq -c|sort -nr|head -20 例16：找出程序运行的端口 netstat -ap | grep ssh 例17：在 netstat 输出中显示 PID 和进程名称netstat -pt 例18：找出运行在指定端口的进程netstat -anpt | grep ‘:16064’运行在端口16064的进程id为24596，再通过ps命令就可以找到具体的应用程序了。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[linux命令学习之网络命令-ping命令]]></title>
      <url>%2F2017%2F03%2F30%2Flinux%E5%91%BD%E4%BB%A4%E5%AD%A6%E4%B9%A0-%E7%BD%91%E7%BB%9C%E5%91%BD%E4%BB%A4%E4%B9%8Bping%E5%91%BD%E4%BB%A4%2F</url>
      <content type="text"><![CDATA[ping简介Linux系统的ping命令是常用的网络命令，它通常用来测试与目标主机的连通性。我们经常会说“ping一下某机器，看是不是开着”、不能打开网页时会说“你先ping网关地址192.168.1.1试试”。它通过发送ICMP ECHO_REQUEST数据包到网络主机（send ICMP ECHO_REQUEST to network hosts），并显示响应情况，这样我们就可以根据它输出的信息来确定目标主机是否可访问（但这不是绝对的）。有些服务器为了防止通过ping探测到，通过防火墙设置了禁止ping或者在内核参数中禁止ping，这样就不能通过ping确定该主机是否还处于开启状态。linux下的ping和windows下的ping稍有区别,linux下ping不会自动终止,需要按ctrl+c终止或者用参数-c指定要求完成的回应次数。 命令学习命令格式：ping [参数] [主机名或IP地址] 命令功能：ping命令用于：确定网络和各外部主机的状态；跟踪和隔离硬件和软件问题；测试、评估和管理网络。如果主机正在运行并连在网上，它就对回送信号进行响应。每个回送信号请求包含一个网际协议（IP）和 ICMP 头，后面紧跟一个 tim 结构，以及来填写这个信息包的足够的字节。缺省情况是连续发送回送信号请求直到接收到中断信号（Ctrl-C）。ping 命令每秒发送一个数据报并且为每个接收到的响应打印一行输出。ping 命令计算信号往返时间和(信息)包丢失情况的统计信息，并且在完成之后显示一个简要总结。ping 命令在程序超时或当接收到 SIGINT 信号时结束。Host 参数或者是一个有效的主机名或者是因特网地址。 命令参数：-d 使用Socket的SO_DEBUG功能。-f 极限检测。大量且快速地送网络封包给一台机器，看它的回应。-n 只输出数值。-q 不显示任何传送封包的信息，只显示最后的结果。-r 忽略普通的Routing Table，直接将数据包送到远端主机上。通常是查看本机的网络接口是否有问题。-v 详细显示指令的执行过程。 -c 数目：在发送指定数目的包后停止。-i 秒数：设定间隔几秒送一个网络封包给一台机器，预设值是一秒送一次。-I 网络界面：使用指定的网络界面送出数据包。-l 前置载入：设置在送出要求信息之前，先行发出的数据包。-p 范本样式：设置填满数据包的范本样式。-s 字节数：指定发送的数据字节数，预设值是56，加上8字节的ICMP头，一共是64ICMP数据字节。-t 存活数值：设置存活数值TTL的大小。 常用范例例1：ping的通的情况ping 192.168.120.205 例2：ping不通的情况ping 192.168.120.202 例3：ping网关ping -b 192.168.120.1 例4：ping指定次数ping -c 10 192.168.120.206 例5：时间间隔和次数限制的pingping -c 10 -i 0.5 192.168.120.206 例6：通过域名ping公网上的站点ping -c 5 www.58.com 例7：多参数使用ping -i 3 -s 1024 -t 255 192.168.120.206-i 3 发送周期为 3秒 -s 设置发送包的大小为1024 -t 设置TTL值为 255]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[linux命令学习之route命令]]></title>
      <url>%2F2017%2F03%2F30%2Flinux%E5%91%BD%E4%BB%A4%E5%AD%A6%E4%B9%A0-%E7%BD%91%E7%BB%9C%E5%91%BD%E4%BB%A4%E4%B9%8Broute%E5%91%BD%E4%BB%A4%2F</url>
      <content type="text"><![CDATA[route简介route命令用于显示和操作IP路由表。要实现两个不同的子网之间的通信，需要一台连接两个网络的路由器，或者同时位于两个网络的网关来实现。在Linux系统中，设置路由通常是为了解决以下问题：该Linux系统在一个局域网中，局域网中有一个网关，能够让机器访问Internet，那么就需要将这台机器的IP地址设置为Linux机器的默认路由。直接在命令行下执行route命令来添加路由，不会永久保存，当网卡重启或者机器重启之后，该路由就失效了。可以在/etc/rc.local中添加route命令来保证该路由设置永久有效。 命令学习命令格式：route [-f] [-p] [Command [Destination] [mask Netmask] [Gateway] [metric Metric]] [if Interface]] 命令功能：Route命令是用于操作基于内核ip路由表，它的主要作用是创建一个静态路由让指定一个主机或者一个网络通过一个网络接口，如eth0。当使用”add”或者”del”参数时，路由表被修改，如果没有参数，则显示路由表当前的内容。 命令参数：-c 显示更多信息-n 不解析名字-v 显示详细的处理信息-F 显示发送信息-C 显示路由缓存-f 清除所有网关入口的路由表。-p 与 add 命令一起使用时使路由具有永久性。 add:添加一条新路由。del:删除一条路由。-net:目标地址是一个网络。-host:目标地址是一个主机。netmask:当添加一个网络路由时，需要使用网络掩码。gw:路由数据包通过网关。注意，你指定的网关必须能够达到。metric：设置路由跳数。 Command 指定您想运行的命令 (Add/Change/Delete/Print)。Destination 指定该路由的网络目标。mask Netmask 指定与网络目标相关的网络掩码（也被称作子网掩码）。Gateway 指定网络目标定义的地址集和子网掩码可以到达的前进或下一跃点 IP 地址。metric Metric 为路由指定一个整数成本值标（从 1 至 9999），当在路由表(与转发的数据包目标地址最匹配)的多个路由中进行选择时可以使用。if Interface 为可以访问目标的接口指定接口索引。若要获得一个接口列表和它们相应的接口索引，使用 route print 命令的显示功能。可以使用十进制或十六进制值进行接口索引。 常用范例例1：显示当前路由routeroute -n route -n (-n 表示不解析名字,列出速度会比route 快) 第一行表示主机所在网络的地址为192.168.120.0，若数据传送目标是在本局域网内通信，则可直接通过eth0转发数据包;第四行表示数据传送目的是访问Internet，则由接口eth0，将数据包发送到网关192.168.120.240其中Flags为路由标志，标记当前网络节点的状态。Flags标志说明：U Up表示此路由当前为启动状态H Host，表示此网关为一主机G Gateway，表示此网关为一路由器R Reinstate Route，使用动态路由重新初始化的路由D Dynamically,此路由是动态性地写入M Modified，此路由是由路由守护程序或导向器动态修改! 表示此路由当前为关闭状态 例2：添加网关/设置网关route add -net 224.0.0.0 netmask 240.0.0.0 dev eth0增加一条 到达244.0.0.0的路由 例3：屏蔽一条路由route add -net 224.0.0.0 netmask 240.0.0.0 reject 例4：删除路由记录route del -net 224.0.0.0 netmask 240.0.0.0route del -net 224.0.0.0 netmask 240.0.0.0 reject 例5：删除和添加设置默认网关 route del default gw 192.168.120.240route add default gw 192.168.120.240]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[linux命令学习之网络命令-traceroute命令]]></title>
      <url>%2F2017%2F03%2F30%2Flinux%E5%91%BD%E4%BB%A4%E5%AD%A6%E4%B9%A0-%E7%BD%91%E7%BB%9C%E5%91%BD%E4%BB%A4%E4%B9%8Btraceroute%E5%91%BD%E4%BB%A4%2F</url>
      <content type="text"><![CDATA[traceroute简介通过traceroute可以知道信息从你的计算机到互联网另一端的主机是走的什么路径。每次数据包由某一同样的出发点（source）到达某一同样的目的地(destination)走的路径可能会不一样，但基本上来说大部分时候所走的路由是相同的。linux系统中，我们称之为traceroute,在MS Windows中为tracert。 traceroute通过发送小的数据包到目的设备直到其返回，来测量其需要多长时间。一条路径上的每个设备traceroute要测3次。输出结果中包括每次测试的时间(ms)和设备的名称（如有的话）及其IP地址。在大多数情况下，在linux主机系统下，直接执行命令行：traceroute hostname而在Windows系统下是执行tracert的命令：tracert hostname traceroute工作原理Traceroute程序的设计是利用ICMP及IP header的TTL（Time To Live）栏位（field）。 首先，traceroute送出一个TTL是1的IP datagram（其实，每次送出的为3个40字节的包，包括源地址，目的地址和包发出的时间标签）到目的地，当路径上的第一个路由器（router）收到这个datagram时，它将TTL减1。此时，TTL变为0了，所以该路由器会将此datagram丢掉，并送回一个「ICMP time exceeded」消息（包括发IP包的源地址，IP包的所有内容及路由器的IP地址），traceroute 收到这个消息后，便知道这个路由器存在于这个路径上，接着traceroute 再送出另一个TTL是2 的datagram，发现第2 个路由器。 traceroute 每次将送出的datagram的TTL 加1来发现另一个路由器，这个重复的动作一直持续到某个datagram 抵达目的地。当datagram到达目的地后，该主机并不会送回ICMP time exceeded消息，因为它已是目的地了，那么traceroute如何得知目的地到达了呢？ Traceroute在送出UDP datagrams到目的地时，它所选择送达的port number 是一个一般应用程序都不会用的号码（30000 以上），所以当此UDP datagram 到达目的地后该主机会送回一个「ICMP port unreachable」的消息，而当traceroute 收到这个消息时，便知道目的地已经到达了。所以traceroute 在Server端也是没有所谓的Daemon 程式。 Traceroute提取发 ICMP TTL到期消息设备的IP地址并作域名解析。每次 ，Traceroute都打印出一系列数据,包括所经过的路由设备的域名及 IP地址,三个包每次来回所花时间。 命令学习命令格式：traceroute[参数][主机] 命令功能：traceroute指令让你追踪网络数据包的路由途径，预设数据包大小是40Bytes，用户可另行设置。具体参数格式：traceroute [-dFlnrvx][-f&lt;存活数值&gt;][-g&lt;网关&gt;…][-i&lt;网络界面&gt;][-m&lt;存活数值&gt;][-p&lt;通信端口&gt;][-s&lt;来源地址&gt;][-t&lt;服务类型&gt;][-w&lt;超时秒数&gt;][主机名称或IP地址][数据包大小] 命令参数：-d 使用Socket层级的排错功能。-f 设置第一个检测数据包的存活数值TTL的大小。-F 设置勿离断位。-g 设置来源路由网关，最多可设置8个。-i 使用指定的网络界面送出数据包。-I 使用ICMP回应取代UDP资料信息。-m 设置检测数据包的最大存活数值TTL的大小。-n 直接使用IP地址而非主机名称。-p 设置UDP传输协议的通信端口。-r 忽略普通的Routing Table，直接将数据包送到远端主机上。-s 设置本地主机送出数据包的IP地址。-t 设置检测数据包的TOS数值。-v 详细显示指令的执行过程。-w 设置等待远端主机回报的时间。-x 开启或关闭数据包的正确性检验。 常用范例例1：traceroute 用法简单、最常用的用法traceroute www.baidu.com 记录按序列号从1开始，每个纪录就是一跳 ，每跳表示一个网关，我们看到每行有三个时间，单位是 ms，其实就是-q的默认参数。探测数据包向每个网关发送三个数据包后，网关响应后返回的时间；如果您用 traceroute -q 4 www.58.com ，表示向每个网关发送4个数据包。有时我们traceroute 一台主机时，会看到有一些行是以星号表示的。出现这样的情况，可能是防火墙封掉了ICMP的返回信息，所以我们得不到什么相关的数据包返回数据。有时我们在某一网关处延时比较长，有可能是某台网关比较阻塞，也可能是物理设备本身的原因。当然如果某台DNS出现问题时，不能解析主机名、域名时，也会 有延时长的现象；您可以加-n 参数来避免DNS解析，以IP格式输出数据。如果在局域网中的不同网段之间，我们可以通过traceroute 来排查问题所在，是主机的问题还是网关的问题。如果我们通过远程来访问某台服务器遇到问题时，我们用到traceroute 追踪数据包所经过的网关，提交IDC服务商，也有助于解决问题；但目前看来在国内解决这样的问题是比较困难的，就是我们发现问题所在，IDC服务商也不可能帮助我们解决。 例2：跳数设置traceroute -m 10 www.baidu.com 例3：显示IP地址，不查主机名traceroute -n www.baidu.com 例4：探测包使用的基本UDP端口设置6888traceroute -p 6888 www.baidu.com 例5：把探测包的个数设置为值4traceroute -q 4 www.baidu.com 例6：绕过正常的路由表，直接发送到网络相连的主机 traceroute -r www.baidu.com 例7：把对外发探测包的等待响应时间设置为3秒traceroute -w 3 www.baidu.com]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[linux命令学习之网络命令-ss命令]]></title>
      <url>%2F2017%2F03%2F30%2Flinux%E5%91%BD%E4%BB%A4%E5%AD%A6%E4%B9%A0-%E7%BD%91%E7%BB%9C%E5%91%BD%E4%BB%A4%E4%B9%8Bss%E5%91%BD%E4%BB%A4%2F</url>
      <content type="text"><![CDATA[ss简介ss是Socket Statistics的缩写。ss命令可以用来获取socket统计信息，它可以显示和netstat类似的内容。但ss的优势在于它能够显示更多更详细的有关TCP和连接状态的信息，而且比netstat更快速更高效。当服务器的socket连接数量变得非常大时，无论是使用netstat命令还是直接cat /proc/net/tcp，执行速度都会很慢。当服务器维持的连接达到上万个的时候，使用netstat等于浪费 生命，而用ss才是节省时间。 ss快的秘诀在于，它利用到了TCP协议栈中tcp_diag。tcp_diag是一个用于分析统计的模块，可以获得Linux 内核中第一手的信息，这就确保了ss的快捷高效。当然，如果你的系统中没有tcp_diag，ss也可以正常运行，只是效率会变得稍慢。（但仍然比 netstat要快。） 命令学习命令格式:ss [参数]ss [参数] [过滤] 命令功能：ss(Socket Statistics的缩写)命令可以用来获取 socket统计信息，此命令输出的结果类似于 netstat输出的内容，但它能显示更多更详细的 TCP连接状态的信息，且比 netstat 更快速高效。它使用了 TCP协议栈中 tcp_diag（是一个用于分析统计的模块），能直接从获得第一手内核信息，这就使得 ss命令快捷高效。在没有 tcp_diag，ss也可以正常运行。 命令参数：-h, –help 帮助信息-V, –version 程序版本信息-n, –numeric 不解析服务名称-r, –resolve 解析主机名-a, –all 显示所有套接字（sockets）-l, –listening 显示监听状态的套接字（sockets）-o, –options 显示计时器信息-e, –extended 显示详细的套接字（sockets）信息-m, –memory 显示套接字（socket）的内存使用情况-p, –processes 显示使用套接字（socket）的进程-i, –info 显示 TCP内部信息-s, –summary 显示套接字（socket）使用概况-4, –ipv4 仅显示IPv4的套接字（sockets）-6, –ipv6 仅显示IPv6的套接字（sockets）-0, –packet 显示 PACKET 套接字（socket）-t, –tcp 仅显示 TCP套接字（sockets）-u, –udp 仅显示 UCP套接字（sockets）-d, –dccp 仅显示 DCCP套接字（sockets）-w, –raw 仅显示 RAW套接字（sockets）-x, –unix 仅显示 Unix套接字（sockets）-f, –family=FAMILY 显示 FAMILY类型的套接字（sockets），FAMILY可选，支持 unix, inet, inet6, link, netlink-A, –query=QUERY, –socket=QUERY QUERY := {all|inet|tcp|udp|raw|unix|packet|netlink}[,QUERY]-D, –diag=FILE 将原始TCP套接字（sockets）信息转储到文件 -F, –filter=FILE 从文件中都去过滤器信息 FILTER : = [ state TCP-STATE ] [ EXPRESSION ] 常用范例例1：显示TCP连接ss -t -a 例2：显示 Sockets 摘要ss -s 列出当前的established, closed, orphaned and waiting TCP sockets 例3：列出所有打开的网络连接端口ss -l 例4：查看进程使用的socketss -pl 例5：找出打开套接字/端口应用程序ss -lp | grep 3306 例6：显示所有UDP Socketsss -u -a 例7：显示所有状态为established的SMTP连接ss -o state established ‘( dport = :smtp or sport = :smtp )’ 例8：显示所有状态为Established的HTTP连接ss -o state established ‘( dport = :http or sport = :http )’ 例9：列举出处于 FIN-WAIT-1状态的源端口为 80或者 443，目标网络为 193.233.7/24所有 tcp套接字ss -o state fin-wait-1 ‘( sport = :http or sport = :https )’ dst 193.233.7/24 例10：用TCP 状态过滤Sockets:ss -4 state FILTER-NAME-HEREss -6 state FILTER-NAME-HERE FILTER-NAME-HERE 可以代表以下任何一个：establishedsyn-sentsyn-recvfin-wait-1fin-wait-2time-waitclosedclose-waitlast-acklistenclosing all : 所有以上状态connected : 除了listen and closed的所有状态synchronized :所有已连接的状态除了syn-sentbucket : 显示状态为maintained as minisockets,如：time-wait和syn-recv.big : 和bucket相反. 例11：匹配远程地址和端口号ss dst ADDRESS_PATTERNss dst 192.168.1.5ss dst 192.168.119.113:httpss dst 192.168.119.113:smtpss dst 192.168.119.113:443 例12：匹配本地地址和端口号ss src ADDRESS_PATTERNss src 192.168.119.103ss src 192.168.119.103:httpss src 192.168.119.103:80ss src 192.168.119.103:smtpss src 192.168.119.103:25 例13：将本地或者远程端口和一个数比较ss dport OP PORTss sport OP PORT ss dport OP PORT 远程端口和一个数比较；ss sport OP PORT 本地端口和一个数比较。OP 可以代表以下任意一个:&lt;= or le : 小于或等于端口号&gt;= or ge : 大于或等于端口号&gt;== or eq : 等于端口号!= or ne : 不等于端口号&lt; or gt : 小于端口号&gt; or lt : 大于端口号 例14：ss 和 netstat 效率对比time netstat -attime ss 用time 命令分别获取通过netstat和ss命令获取程序和概要占用资源所使用的时间。在服务器连接数比较多的时候，netstat的效率完全没法和ss比。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[linux目录结构]]></title>
      <url>%2F2017%2F03%2F30%2Flinux%E7%9B%AE%E5%BD%95%E7%BB%93%E6%9E%84%2F</url>
      <content type="text"><![CDATA[linux目录结构简介当在使用Linux的时候，如果通过ls –l / 就会发现，在/下包含很多的目录，比如etc、usr、var、bin … … 等目录，而在这些目录中，我们进去看看，发现也有很多的目录或文件。文件系统在Linux下看上去就象树形结构，所以可以把文件系统的结构形象的称为 树形结构。文件系统的是用来组织和排列文件存取的，所以是可见的，在Linux中，可以通过ls等工具来查看其结构，在Linux系统中，我们见到的都是树形结构；比如操作系统安装在一个文件系统中，他表现为由/ 起始的树形结构。linux文件系统的最顶端是/，我们称/为Linux的root，也就是 Linux操作系统的文件系统。 Linux的文件系统的入口就是/，所有的目录、文件、设备都在/之下，/就是Linux文件系统的组织者，也是最上级的领导者。 目录结构学习目录定义成为四种交互作用的形态 ：四中类型:1. 可分享的：可以分享给其他系统挂载使用的目录，所以包括执行文件与用户的邮件等数据， 是能够分享给网络上其他主机挂载用的目录；2. 不可分享的：自己机器上面运作的装置文件或者是与程序有关的socket文件等， 由于仅与自身机器有关，所以当然就不适合分享给其他主机了。3. 不变的：有些数据是不会经常变动的，跟随着distribution而不变动。 例如函式库、文件说明文件、系统管理员所管理的主机服务配置文件等等；4. 可变动的：经常改变的数据，例如登录文件、一般用户可自行收受的新闻组等。 FHS针对目录树架构仅定义出三层目录底下应该放置什么数据而已，分别是底下这三个目录的定义：/ (root, 根目录)：与开机系统有关；/usr (unix software resource)：与软件安装/执行有关；/var (variable)：与系统运作过程有关。 一. 根目录 (/) 的意义与内容：根目录是整个系统最重要的一个目录，因为不但所有的目录都是由根目录衍生出来的， 同时根目录也与开机/还原/系统修复等动作有关。 由于系统开机时需要特定的开机软件、核心文件、开机所需程序、 函式库等等文件数据，若系统出现错误时，根目录也必须要包含有能够修复文件系统的程序才行。 因为根目录是这么的重要，所以在FHS的要求方面，他希望根目录不要放在非常大的分区， 因为越大的分区内你会放入越多的数据，如此一来根目录所在分区就可能会有较多发生错误的机会。因此FHS标准建议：根目录(/)所在分区应该越小越好， 且应用程序所安装的软件最好不要与根目录放在同一个分区内，保持根目录越小越好。 如此不但效能较佳，根目录所在的文件系统也较不容易发生问题。（根目录和Windows的C盘一个样）根据以上原因，FHS认为根目录(/)下应该包含如下子目录：事实上FHS针对根目录所定义的标准就仅限于上表，不过仍旧有些目录也需要了解一下，具体如下： 除了这些目录的内容之外，另外要注意的是，因为根目录与开机有关，开机过程中仅有根目录会被挂载， 其他分区则是在开机完成之后才会持续的进行挂载的行为。就是因为如此，因此根目录下与开机过程有关的目录， 就不能够与根目录放到不同的分区去。有底下这些：/etc：配置文件/bin：重要执行档/dev：所需要的装置文件/lib：执行档所需的函式库与核心所需的模块/sbin：重要的系统执行文件五个目录千万不可与根目录分开在不同的分区。 二. /usr 的意义与内容：依据FHS的基本定义，/usr里面放置的数据属于可分享的与不可变动的，如果你知道如何透过网络进行分区的挂载(例如在服务器篇会谈到的NFS服务器)，那么/usr确实可以分享给局域网络内的其他主机来使用。/usr不是user的缩写，其实usr是Unix Software Resource的缩写， 也就是Unix操作系统软件资源所放置的目录，而不是用户的数据。 FHS建议所有软件开发者，应该将他们的数据合理的分别放置到这个目录下的次目录，而不要自行建立该软件自己独立的目录。因为是所有系统默认的软件(distribution发布者提供的软件)都会放置到/usr底下，因此这个目录有点类似Windows 系统的C:\Windows\ + C:\Program files\这两个目录的综合体，系统刚安装完毕时，这个目录会占用最多的硬盘容量。 一般来说，/usr的次目录建议有底下这些： 三. /var 的意义与内容如果/usr是安装时会占用较大硬盘容量的目录，那么/var就是在系统运作后才会渐渐占用硬盘容量的目录。 因为/var目录主要针对常态性变动的文件，包括缓存(cache)、登录档(log file)以及某些软件运作所产生的文件， 包括程序文件(lock file, run file)，或者例如MySQL数据库的文件等等。常见的次目录有：由于FHS仅是定义出最上层(/)及次层(/usr, /var)的目录内容应该要放置的文件或目录数据， 因此，在其他次目录层级内，就可以随开发者自行来配置了。 四. 目录树(directory tree)在Linux底下，所有的文件与目录都是由根目录开始的。那是所有目录与文件的源头, 然后再一个一个的分支下来，因此，我们也称这种目录配置方式为：目录树(directory tree), 这个目录树的主要特性有：目录树的启始点为根目录 (/, root)；每一个目录不止能使用本地端的 partition 的文件系统，也可以使用网络上的 filesystem 。举例来说， 可以利用 Network File System (NFS) 服务器挂载某特定目录等。每一个文件在此目录树中的文件名(包含完整路径)都是独一无二的。如果我们将整个目录树以图的方法来显示，并且将较为重要的文件数据列出来的话，那么目录树架构就如下图 五. 绝对路径与相对路径除了需要特别注意的FHS目录配置外，在文件名部分也要特别注意。因为根据档名写法的不同，也可将所谓的路径(path)定义为绝对路径(absolute)与相对路径(relative)。 这两种文件名/路径的写法依据是这样的：绝对路径：由根目录(/)开始写起的文件名或目录名称， 例如 /home/dmtsai/.bashrc；相对路径：相对于目前路径的文件名写法。 例如 ./home/dmtsai 或 http://www.cnblogs.com/home/dmtsai/ 等等。反正开头不是 / 就属于相对路径的写法必须要了解，相对路径是以你当前所在路径的相对位置来表示的。举例来说，你目前在 /home 这个目录下， 如果想要进入 /var/log 这个目录时，可以怎么写呢？cd /var/log (absolute)cd ../var/log (relative)因为你在 /home 底下，所以要回到上一层 (../) 之后，才能继续往 /var 来移动的，特别注意这两个特殊的目录：. ：代表当前的目录，也可以使用 ./ 来表示；.. ：代表上一层目录，也可以 ../ 来代表。这个 . 与 .. 目录概念是很重要的，你常常会看到 cd .. 或 ./command 之类的指令下达方式， 就是代表上一层与目前所在目录的工作状态。实例1：如何先进入/var/spool/mail/目录，再进入到/var/spool/cron/目录内？命令：cd /var/spool/mailcd ../cron说明：由于/var/spool/mail与/var/spool/cron是同样在/var/spool/目录中。如此就不需要在由根目录开始写起了。实例2：网络文件常常提到类似./run.sh之类的数据，这个指令的意义为何？说明：由于指令的执行需要变量的支持，若你的执行文件放置在本目录，并且本目录并非正规的执行文件目录(/bin, /usr/bin等为正规)，此时要执行指令就得要严格指定该执行档。./代表本目录的意思，所以./run.sh代表执行本目录下， 名为run.sh的文件。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[linux文件类型与扩展名]]></title>
      <url>%2F2017%2F03%2F30%2Flinux%E6%96%87%E4%BB%B6%E7%B1%BB%E5%9E%8B%E4%B8%8E%E6%89%A9%E5%B1%95%E5%90%8D%2F</url>
      <content type="text"><![CDATA[linux文件类型与扩展名文件类型Linux文件类型常见的有：普通文件、目录文件、字符设备文件和块设备文件、符号链接文件等。1. 普通文件我们用 ls -lh 来查看某个文件的属性，可以看到有类似-rwxrwxrwx，值得注意的是第一个符号是 - ，这样的文件在Linux中就是普通文件。这些文件一般是用一些相关的应用程序创建，比如图像工具、文档工具、归档工具或 cp工具等。这类文件的删除方式是用rm 命令。 另外，依照文件的内容，又大略可以分为：1&gt;. 纯文本档(ASCII)：Linux系统中最多的一种文件类型，称为纯文本档是因为内容为我们可以直接读到的数据，例如数字、字母等等。 几乎只要我们可以用来做为设定的文件都属于这一种文件类型。举例来说，你可以用命令： cat ~/.bashrc 来看到该文件的内容。 (cat 是将一个文件内容读出来的指令).2&gt;. 二进制文件(binary)：Linux系统其实仅认识且可以执行二进制文件(binary file)。Linux当中的可执行文件(scripts, 文字型批处理文件不算)就是这种格式的文件。 使用的命令cat就是一个binary file。3&gt;. 数据格式文件(data)：有些程序在运作的过程当中会读取某些特定格式的文件，那些特定格式的文件可以被称为数据文件 (data file)。举例来说，我们的Linux在使用者登录时，都会将登录的数据记录在 /var/log/wtmp那个文件内，该文件是一个data file，能够透过last这个指令读出来！ 但是使用cat时，会读出乱码～因为他是属于一种特殊格式的文件 2. 目录文件当我们在某个目录下执行，看到有类似 drwxr-xr-x ，这样的文件就是目录，目录在Linux是一个比较特殊的文件。注意它的第一个字符是d。创建目录的命令可以用 mkdir 命令，或cp命令，cp可以把一个目录复制为另一个目录。删除用rm 或rmdir命令。 3. 字符设备或块设备文件如时您进入/dev目录，列一下文件，会看到类似如下的:[root@localhost ~]# ls -al /dev/ttycrw-rw-rw- 1 root tty 5, 0 11-03 15:11 /dev/tty[root@localhost ~]# ls -la /dev/sda1brw-r—– 1 root disk 8, 1 11-03 07:11 /dev/sda1我们看到/dev/tty的属性是 crw-rw-rw- ，前面第一个字符是 c ，表示字符设备文件。比如猫等串口设备。我们看到 /dev/sda1 的属性是 brw-r—– ，注意前面的第一个字符是b，这表示块设备，比如硬盘，光驱等设备。这个种类的文件，是用mknode来创建，用rm来删除。目前在最新的Linux发行版本中，我们一般不用自己来创建设备文件。因为这些文件是和内核相关联的。与系统周边及储存等相关的一些文件， 通常都集中在/dev这个目录之下！通常又分为两种：区块(block)设备档 ：就是一些储存数据， 以提供系统随机存取的接口设备。举例来说，硬盘与软盘等就是！ 可以随机的在硬盘的不同区块读写。可以自行查一下/dev/sda看看， 会发现第一个属性为[ b ]！字符(character)设备文件：一些串行端口的接口设备， 例如键盘、鼠标等等！这些设备的特色就是一次性读取，不能够截断输出。 举例来说，你不可能让鼠标跳到另一个画面，而是滑动到另一个地方！第一个属性为 [ c ]。 4. 数据接口文件(sockets)：数据接口文件（套接口文件），这种类型的文件通常被用在网络上的数据承接了。我们可以启动一个程序来监听客户端的要求， 而客户端就可以透过这个socket来进行数据的沟通了。第一个属性为 [ s ]， 最常在/var/run这个目录中看到这种文件类型了。例如：当我们启动MySQL服务器时，会产生一个mysql.sock的文件。[root@localhost ~]# ls -lh /var/lib/mysql/mysql.socksrwxrwxrwx 1 mysql mysql 0 04-19 11:12 /var/lib/mysql/mysql.sock注意这个文件的属性的第一个字符是 s。 5. 符号链接文件：当我们查看文件属性时，会看到有类似 lrwxrwxrwx,注意第一个字符是l，这类文件是链接文件。通过ln -s 源文件名 新文件名 。和Windows操作系统中的快捷方式有点相似。 6. 数据输送文件（FIFO,pipe）FIFO也是一种特殊的文件类型，他主要的目的在解决多个程序同时存取一个文件所造成的错误问题。 FIFO是first-in-first-out的缩写。第一个属性为[p] 。 文件扩展名1. 扩展名类型Linux的文件是没有所谓的扩展名的，一个Linux文件能不能被执行，与他的第一栏的十个属性有关，与文档名根本一点关系也没有。这个观念跟Windows的情况不相同！在Windows底下，能被执行的文件扩展名通常是 .com .exe .bat等等，而在Linux底下，只要你的权限当中具有x的话，例如[ -rwx-r-xr-x ] 即代表这个文件可以被执行。不过，可以被执行跟可以执行成功是不一样的举例来说，在root家目录下的install.log 是一个纯文本档，如果经由修改权限成为 -rwxrwxrwx 后，这个文件能够真的执行成功吗？ 当然不行。因为他的内容根本就没有可以执行的数据。所以说，这个x代表这个文件具有可执行的能力， 但是能不能执行成功，当然就得要看该文件的内容。所以，通常我们还是会以适当的扩展名来表示该文件是什么种类的。底下有数种常用的扩展名：.sh ： 脚本或批处理文件 (scripts)，因为批处理文件为使用shell写成的，所以扩展名就编成 .sh Z, .tar, .tar.gz, .zip, .tgz： 经过打包的压缩文件。这是因为压缩软件分别为 gunzip, tar 等等的，由于不同的压缩软件，而取其相关的扩展名！.html, .php：网页相关文件，分别代表 HTML 语法与 PHP 语法的网页文件。 .html 的文件可使用网页浏览器来直接开启，至于 .php 的文件， 则可以透过 client 端的浏览器来 server 端浏览，以得到运算后的网页结果。基本上，Linux系统上的文件名真的只是让你了解该文件可能的用途而已，真正的执行与否仍然需要权限的规范才行。例如虽然有一个文件为可执行文件，如常见的/bin/ls这个显示文件属性的指令，不过，如果这个文件的权限被修改成无法执行时，那么ls就变成不能执行。上述的这种问题最常发生在文件传送的过程中。例如你在网络上下载一个可执行文件，但是偏偏在你的 Linux系统中就是无法执行！那么就是可能文件的属性被改变了。从网络上传送到你的 Linux系统中，文件的属性与权限确实是会被改变的。 2. Linux文件名长度限制在Linux底下，使用预设的Ext2/Ext3文件系统时，针对文件名长度限制为：单一文件或目录的最大容许文件名为 255 个字符包含完整路径名称及目录 (/) 之完整档名为 4096 个字符 3. Linux文件名的字符的限制由于Linux在文字接口下的一些指令操作关系，一般来说，在设定Linux底下的文件名时， 最好可以避免一些特殊字符比较好！例如这些： ? &gt; &lt; ; &amp; ! [ ] | \ ‘ “ ` ( ) { } 因为这些符号在文字接口下，是有特殊意义的。另外，文件名的开头为小数点“.”时， 代表这个文件为隐藏文件！同时，由于指令下达当中，常常会使用到 -option 之类的选项， 所以最好也避免将文件档名的开头以 - 或 + 来命名。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[linux终端设备-基本类型]]></title>
      <url>%2F2017%2F03%2F30%2Flinux%E7%BB%88%E7%AB%AF%E8%AE%BE%E5%A4%87%E5%AD%A6%E4%B9%A0%E2%80%94%E5%9F%BA%E6%9C%AC%E7%B1%BB%E5%9E%8B%2F</url>
      <content type="text"><![CDATA[linux终端设备类型linux下有多种终端设备类型，包括当前终端，前台控制终断，串口以及虚拟终端主设备。可在linux的/proc/tty下查看各设备的基本信息。将这些终端设备统一由TTY管理，从而屏蔽硬件实现。同时，将所有的设备分别映射成一个文件（设备文件）。因此，可由文件管理函数IO函数操作这些文件，达到控制终端设备的目的。 实际的物理串口串口终端/dev/ttyS[n],ttyS系列指物理串行接口，即ttyS0为COM1,ttyS1为COM2。在/sys下的主次设备号如下：即物理串口设备主设备好为4，次设备号从64开始。相关的资源信息： 可通过如下命令想串口发送数据：echo ttyS1&gt;/dev/ttyS1echo hello world &gt;/dev/ttys1虚拟机下：采用windows的文件来代替串口，然后在window下查看该文件内容。设置：虚拟机下的setting中设置add一个串口设备号（没有要再关机情况下添加）,添加后在底部图标可看到添加的串口号以及window下的文件。 控制台终端tty1-tty6为控制台终端，即非图像界面下的命令行输入模式。控制台终端设备主设备号为4，次设备号从1开始 虚拟终端当下多数使用linux都是通过网络连接到服务器的方式，如telent和ssh工具。如果是在服务器的图像界面下，运行命令一般会打开一个虚拟终端窗口。这两类情况在服务器上显示的是虚拟网络终端。虚拟网络终端有两个虚拟设备：/dev/ptmx和/dev/pts /dev/ptmx虚拟设备/dev/ptmx是一个字符文件，用于创建虚拟网络终端设备master/slave配对设备。要打开一个未使用的虚拟终端，通过调用posix_openpt()函数，来打开/dev/ptmx设备。每次open打开这个文件，返回一个独立的master设备的文件描述符，可通过这个描述符找到关联的slave设备，且slave设备会在/dev/pts/目录下创建。 /dev/pts虚拟终端通过网络telent到linux主机或者windows环境下打开一个终端，将在/dev/pts目录下依次创建一个虚拟终端设备，相应地退出一个虚拟终端，将自动减少一个设备文件。 当前终端当前控制台终端/dev/console/dev/console代表当前系统使用的实际控制台终端（tty1-tty6）。/dev/console设备号信息如下：其主设备号为5，次设备号为1.它始终代表当前主机打开的实际控制台终端 当前终端/dev/tty/dev/tty代表当前终端，无论是通过控制台终端还是虚拟终端，/dev/tty都代表自己。该设备信息如下：在任意终端下。如telent下连接终端执行，即向/dev/tty发送消息，会直接回显]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[linux终端设备-终端属性termios]]></title>
      <url>%2F2017%2F03%2F30%2Flinux%E7%BB%88%E7%AB%AF%E8%AE%BE%E5%A4%87%E5%AD%A6%E4%B9%A0%E2%80%94%E7%BB%88%E7%AB%AF%E5%B1%9E%E6%80%A7termios%E7%BB%93%E6%9E%84%E4%BD%93%2F</url>
      <content type="text"><![CDATA[termios结构体简介 为便于用户层统一管理终端属性，linux使用termios结构体来统一管理struct termios{ unsigned short c_iflag; / 输入模式标志/ unsigned short c_oflag; / 输出模式标志/ unsigned short c_cflag; / 控制模式标志/ unsigned short c_lflag; /区域模式标志或本地模式标志或局部模式/ unsigned char c_line; /行控制line discipline / unsigned char c_cc[NCC]; / 控制字符特性/};可以调用函数tcgetattr来初始化一个终端对应的termios结构，该函数的原型如下： #include&lt;termios.h&gt; int tcgetattr(int fd, struct termios *termios_p); 这个函数调用获取fd所指向的当前终端对象fd的相关属性，并写入termios_p参数指向的结构。 通过调用函数tcsetattr来重新配置某个终端的属性，函数原型如下： #include&lt;termios.h&gt; int tcsetattr(int fd , int actions , const struct termios *termios_h); 函数根据actions所指示的行为来设置与fp所指向的终端设备的属性参数actions控制修改方式，共有三种修改方式，如下所示。1.TCSANOW：立刻对值进行修改2.TCSADRAIN：等当前的输出完成后再对值进行修改。3.TCSAFLUSH：等当前的输出完成之后，再对值进行修改，但丢弃还未从read调用返回的当前的可用的任何输入。 五种模式标志 输入模式标志c_iflag输入模式控制输入数据在传递给程序之前的处理方式。通过设置termios结构中的c_iflag成员的标志对它们进行控制。所有的标志都被定义为宏,并可通过按位或的方式结合起来。可用于c_iflag成员的宏如下所示：BRKINT：当在输入行中检测到一个终止状态时，产生一个中断。TGNBRK：忽略输入行中的终止状态。TCRNL：将接受到的回车符转换为新行符。TGNCR：忽略接受到的新行符。INLCR：将接受到的新行符转换为回车符。IGNPAR：忽略奇偶校检错误的字符。INPCK：对接收到的字符执行奇偶校检。PARMRK：对奇偶校检错误作出标记。ISTRIP：将所有接收的字符裁减为7比特。IXOFF：对输入启用软件流控。IXON：对输出启用软件流控。 注意：如果BRKINT和TGNBRK标志都未被设置，则输入行中的终止状态就被读取为NULL（0X00）字符。对于PARKMRK如果没有设置IGNPAR,在有奇偶校验错误的字符前插入\337\0如果没有设置IGNPAR也没有设置PARMRK，将有奇偶校验错误或帧错误的字符视为/0对于BRKINT,如果设置了IGNBRK,将忽略BREAK,如果没有设置，但是设置了BRKINT,那么BREAK将使得输入和输出队列被刷新。如果终端是一个前台进程组的控制终端，这个进程组所有进程将收到SIGINT信号。如果既未设置IGNBRK也为设置BRKINT,BRKINT将视为与NUL字符同意。除非设置了PARMRK，这种情况下被视为序列/337/0/0 输出模式标志c_oflag输出模式控制输出字符的处理方式,即由程序发出的字符在传递到串行口或屏幕之前如何处理.通过设置c_oflag成员的标识对输出模式进行控制.可用于c_iflag成员的宏如下所示（部分）：OPSOT:打开输出处理功能OLCUC:将输出的小写字母映射为大写字母ONLCR:将输出中的换行符转换为回车符OCRNL:将回车符转换为换行符ONOCR:第０行不输出回车符ONLRET:不输出回车符NLDLY:换行符延时选择CRDLY:回车符延时TABDLY:制表符延时 控制模式标志c_cflag控制模式控制终端的硬件特性,通过c_cflag成员标识配置. 包括：波特率，数据位长度，停止位长度，奇偶校验位等CBAUD ：(不属于 POSIX) 波特率掩码 (4+1 位)。CSIZE：字符长度掩码（传送或接收字元时用的位数）。 取值为CS5（传送或接收字元时用5bits）, CS6, CS7, 或 CS8。CSTOPB ：设置两个停止位，而不是一个。CREAD ：打开接受者。PARENB ：允许输出产生奇偶信息以及输入的奇偶校验（启用同位产生与侦测）。PARODD ：输入和输出是奇校验（使用奇同位而非偶同位）。HUPCL ：在最后一个进程关闭设备后，降低 modem 控制线 (挂断)。CLOCAL ：忽略 modem 控制线。LOBLK :(不属于 POSIX) 从非当前 shell 层阻塞输出。CIBAUD :(不属于 POSIX) 输入速度的掩码。CIBAUD 各位的值与CBAUD 各位相同，左移了 IBSHIFT 位。CRTSCTS :(不属于 POSIX) 启用 RTS/CTS (硬件) 流控制 设置波特率波特率即调制速率，指信号被调制以后在单位时间内的变化。即单位时间内载波参数变化的次数。为了减少用户编程负担，函数cfgetospeed()将获取存储于struct stermios结构中的输出波特率属性函数cfgetispeed()将获取存储于struct stermios结构中的输入波特率属性，不需要自己进行位操作。函数cfsetospeed()和cfsetispeed分别设置存储于termios结构的输出和输入波特率。cfsetspeed()可以同时设置termios结构的输入和输出波特率。例子：struct termios options;tcgetattr(fd,&amp;options);cfsetispeed(&amp;options,B19200); //输入波特率19200cfsetospeed(&amp;options,B19200); //输出波特率19200options.c_cflag | =(CLOCAL | CREAD ); //允许接收，本地模式tcsetattr(fd,TCSANOW,&amp;options); //生效时间立即生效 设置帧数据位宽度终端可以设置为每帧数据位为5，6，7,8bit。修改数据位宽度如下：options.c_cflag &amp;=~CSIZE; //清除现在数据位宽度options.c_cflag ｜＝CS8; //设置为每帧8bit 设置奇偶校验奇偶校验是串行通信所采用的简单的差错检测方式。例子：设置为8N1，即每帧数据位8bit，无奇偶校验，一位停止位options.c_cflag &amp; =~PARENG;options.c_cflag &amp; =~CSTOPB;options.c_cflag &amp; =~CSIZE;options.c_cflag &amp; =~CS8； 本地模式标志c_lflag本地模式标志用来管理用何种方式输入字符，一般设置为标准模式或者原始模式。标准模式：回显由客户端完成，用户输入的字符先缓存到一个缓存区，直到用户输入回车或者换行才发送到服务端原始模式：又称为字符模式，回显由服务端完成。用户输入的一个字符立即发送到服务端，服务端然后将该字符回显到客户端。ISIG ： 当输入INTR、QUIT、SUSP或DSUSP时，产生相应的信号ICANON ： 使用标准输入模式XCASE ： 在ICANON和XCASE同时设置的情况下，终端只使用大写。如果只设置了XCASE，则输入字符将被转换为小写字符，除非字符使用了转义字符（非POSIX，且Linux不支持该参数）ECHO ： 显示输入字符ECHOE ： 如果ICANON同时设置，ERASE将删除输入的字符，WERASE将删除输入的单词ECHOK ： 如果ICANON同时设置，KILL将删除当前行ECHONL ： 如果ICANON同时设置，即使ECHO没有设置依然显示换行符ECHOPRT： 如果ECHO和ICANON同时设置，将删除打印出的字符（非POSIX）TOSTOP ： 向后台输出发送SIGTTOU信号 控制字符标志c_cc[NCCS]标准模式和非标准模式下,c_cc数组的下标有不同的值:标准模式:VEOF:ＥＯＦ字符VEOL:ＥＯＬ字符VERASE:ERASE字符VINTR:INTR字符VKILL:KILL字符VQUIT:QUIT字符VSTART:START字符VSTOP:STOP字符非标准模式:VINTR:INTR字符VMIN:MIN值VQUIT:QUIT字符VSUSP:SUSP字符VTIME:TIME值VSTART:START字符VSTOP:STOP字符 字符INTR:该字符使终端驱动程序向与终端相连的进程以送SIGINT信号QUIT:该字符使终端驱动程序向与终端相连的进程发送SIGQUIT信号EOF;该字符使终端驱动程序将输入行中的全部字符传递给正在读取输入的应用程序.如果输入行为空,read调用将返回０,就好像在文件尾调用read一样 TIME和MIN值 这两个值只用于非标准模式,两者结合共同控制对输入的读取方式,还能控制在一个程序试图与一个终端关联的文件描述符时将发生的情况MIN = 0, TIME = 0时:read立即返回,如果有待处理的字符,它们就会被返回,如果没有,read调用返回0,且不读取任何字符MIN = 0, TIME &gt; 0时:有字符处理或经过TIME个0.1秒后返回MIN &gt; 0, TIME = 0时:read一直等待,直到有ＭＩＮ个字符可以读取,返回值是字符的数量.到达文件尾时返回0MIN &gt; 0, TIME &gt; 0时:read调用时,它会等待接收一个字符.在接收到第一个字符及其后续的每个字符后,启用一个字符间隔定时器.当有ＭＩＮ个字符可读或两字符间的时间间隔超进TIME个0.1秒时,read返回通过设置ＭＩＮ和ＴＩＭＥ值,我们可以逐个字符地对输入进行处理 其他函数这些函数直接作用于文件描述符,不需要读写termios结构:#include int tcdrain(int fd);让调用程序一直等待,直到所有排队的输出都发送完毕int tcflow(int, int flowtype);暂停或重新开始输出int tcflush(int fd, int in_out_selector);清空输入,输出或两者都清空]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[linux读写串口]]></title>
      <url>%2F2017%2F03%2F30%2Flinux%E8%AF%BB%E5%86%99%E4%B8%B2%E5%8F%A3%2F</url>
      <content type="text"><![CDATA[串口操作串口操作需要的头文件 #include &lt;stdio.h&gt; #include &lt;stdlib.h&gt; #include &lt;unistd.h&gt; #include &lt;sys/types.h&gt; #include &lt;sys/stat.h&gt; #include &lt;fcntl.h&gt; #include &lt;termios.h&gt; #include &lt;errno.&gt; 打开串口在 Linux 下串口文件是位于 /dev 下的串口一 为 /dev/ttyS0串口二 为 /dev/ttyS1打开串口是通过使用标准的文件打开函数操作： int open_port(void) { int fd; fd = open( &quot;/dev/ttyS0&quot;, O_RDWR | O_NOCTTY ); if(-1 == fd) { perror(&quot; 提示错误！&quot;); } return (fd); } O_NOCTTY: 表示当前进程不期望与终端关联，从而避免控制端输入的信息影响当前进程 设置串口最基本的设置串口包括波特率设置，效验位和停止位设置。串口的设置主要是设置 struct termios 结构体的各成员值。 struct termio { unsigned short c_iflag; /* 输入模式标志 */ unsigned short c_oflag; /* 输出模式标志 */ unsigned short c_cflag; /* 控制模式标志*/ unsigned short c_lflag; /* local mode flags */ unsigned char c_line; /* line discipline */ unsigned char c_cc[NCC]; /* control characters */ }; 下面是修改波特率的代码： struct termios Opt; tcgetattr(fd, &amp;Opt); cfsetispeed(&amp;Opt,B19200); /*设置为19200Bps*/ cfsetospeed(&amp;Opt,B19200); tcsetattr(fd,TCANOW,&amp;Opt); 设置波特率的例子函数：/** *@brief 设置串口通信速率 *@param fd 类型 int 打开串口的文件句柄 *@param speed 类型 int 串口速度 *@return void */ int speed_arr[] = { B38400, B19200, B9600, B4800, B2400, B1200, B300, B38400, B19200, B9600, B4800, B2400, B1200, B300, }; int name_arr[] = {38400, 19200, 9600, 4800, 2400, 1200, 300, 38400, 19200, 9600, 4800, 2400, 1200, 300, }; void set_speed(int fd, int speed) { int i; int status; struct termios Opt; tcgetattr(fd, &amp;Opt); for ( i= 0; i &lt; sizeof(speed_arr) / sizeof(int); i++) { if (speed == name_arr[i]) { tcflush(fd, TCIOFLUSH); cfsetispeed(&amp;Opt, speed_arr[i]); cfsetospeed(&amp;Opt, speed_arr[i]); status = tcsetattr(fd1, TCSANOW, &amp;Opt); if (status != 0) { perror(&quot;tcsetattr fd1&quot;); return; } tcflush(fd,TCIOFLUSH); } } } 效验位和停止位的设置：无效验 8位 Option.c_cflag &amp;= ~PARENB; Option.c_cflag &amp;= ~CSTOPB; Option.c_cflag &amp;= ~CSIZE; Option.c_cflag |= ~CS8; 奇效验(Odd) 7位 Option.c_cflag |= ~PARENB; Option.c_cflag &amp;= ~PARODD; Option.c_cflag &amp;= ~CSTOPB; Option.c_cflag &amp;= ~CSIZE; Option.c_cflag |= ~CS7; 偶效验(Even) 7位 Option.c_cflag &amp;= ~PARENB; Option.c_cflag |= ~PARODD; Option.c_cflag &amp;= ~CSTOPB; Option.c_cflag &amp;= ~CSIZE; Option.c_cflag |= ~CS7; Space效验 7位 Option.c_cflag &amp;= ~PARENB; Option.c_cflag &amp;= ~CSTOPB; Option.c_cflag &amp;= &amp;~CSIZE; Option.c_cflag |= CS8; 设置效验的函数： 需要注意的是:如果不是开发终端之类的，只是串口传输数据，而不需要串口来处理，那么使用原始模式(Raw Mode)方式来通讯。设置方式如下： options.c_lflag &amp;= ~(ICANON | ECHO | ECHOE | ISIG); /*Input*/ options.c_oflag &amp;= ~OPOST; /*Output*/ 读写串口设置好串口之后，把串口当作文件读写。发送数据 char buffer[1024]; int Length;int nByte; nByte = write(fd, buffer ,Length) 读取串口数据使用文件操作read函数读取，如果设置为原始模式(Raw Mode)传输数据，那么read函数返回的字符数是实际串口收到的字符数。可以使用操作文件的函数来实现异步读取，如fcntl，或者select等来操作。 char buff[1024];int Len;int readByte = read(fd,buff,Len); 关闭串口关闭串口就是关闭文件。 close(fd);]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[linux命令学习之文件查找命令——find-exec命令]]></title>
      <url>%2F2017%2F03%2F30%2Flinu%E5%91%BD%E4%BB%A4%E5%AD%A6%E4%B9%A0-%E6%96%87%E4%BB%B6%E6%9F%A5%E6%89%BE%E4%B9%8Bfind-xargs%E5%91%BD%E4%BB%A4%2F</url>
      <content type="text"><![CDATA[find之xargs简介在使用 find命令的-exec选项处理匹配到的文件时， find命令将所有匹配到的文件一起传递给exec执行。但有些系统对能够传递给exec的命令长度有限制，这样在find命令运行几分钟之后，就会出现溢出错误。错误信息通常是“参数列太长”或“参数列溢出”。这就是xargs命令的用处所在，特别是与find命令一起使用。find命令把匹配到的文件传递给xargs命令，而xargs命令每次只获取一部分文件而不是全部，这样它可以先处理最先获取的一部分文件，然后是下一批，并如此继续下去。在有些系统中，使用-exec选项会为处理每一个匹配到的文件而发起一个相应的进程，并非将匹配到的文件全部作为参数一次执行；这样在有些情况下就会出现进程过多，系统性能下降的问题，因而效率不高； 而使用xargs命令则只有一个进程。另外，在使用xargs命令时，究竟是一次获取所有的参数，还是分批取得参数，以及每一次获取参数的数目都会根据该命令的选项及系统内核中相应的可调参数来确定。 命令学习-0 当sdtin含有特殊字元时候，将其当成一般字符，/‘空格等-a file 从文件中读入作为sdtin-e flag ，注意有的时候可能会是-E，flag必须是一个以空格分隔的标志，当xargs分析到含有flag这个标志的时候就停止。-p 当每次执行一个argument的时候询问一次用户。-n num 后面加次数，表示命令在执行的时候一次用的argument的个数，默认是用所有的。-t 表示先打印命令，然后再执行。-i 或者是-I，这得看linux支持了，将xargs的每项名称，一般是一行一行赋值给{}，可以用{}代替。-r no-run-if-empty 当xargs的输入为空的时候则停止xargs，不用再去执行了。-s num 命令行的最好字符数，指的是xargs后面那个命令的最大命令行字符数。-L num Use at most max-lines nonblank input lines per command line.-s是含有空格的。-l 同-L-d delim 分隔符，默认的xargs分隔符是回车，argument的分隔符是空格，这里修改的是xargs的分隔符-x exit的意思，主要是配合-s使用。-P 参数会提示让你确认是否执行后面的命令,y执行，n不执行。 常用范例例1： 查找系统中的每一个普通文件，然后使用xargs命令来测试它们分别属于哪类文件find . -type f -print | xargs file 例2:在当前目录下查找所有用户具有读、写和执行权限的文件，并收回相应的写权限find . -perm -7 -print | xargs chmod o-w 例3：用grep命令在所有的普通文件中搜索in这个词find . -type f -print | xargs grep “in” 例4：用grep命令在当前目录下的所有普通文件中搜索hostnames这个词find . -name * -type f -print | xargs grep “hostnames”\用来取消find命令中的*在shell中的特殊含义。 例5：使用xargs执行mvfind . -name “*.log” | xargs -i mv {} test5将当前目录下.log文件移到test5目录下 例6：find后执行xargs提示xargs: argument line too long解决方法find . -type f -atime +0 -print0 | xargs -0 -l1 -t rm -f-l1是一次处理一个；-t是处理之前打印出命令 例7：xargs的-p参数的使用-p参数会提示让你确认是否执行后面的命令,y执行，n不执行。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[linux命令学习之exec命令]]></title>
      <url>%2F2017%2F03%2F30%2Flinu%E5%91%BD%E4%BB%A4%E5%AD%A6%E4%B9%A0-find%E4%B9%8Bexec%E5%91%BD%E4%BB%A4%2F</url>
      <content type="text"><![CDATA[find之exec简介find一般查找文件，进一步的操作由exec完成。 使用find时，只要把想要的操作写在一个文件里，就可以用exec来配合find查找 命令学习exec解释：-exec 参数后面跟的是command命令，它的终止是以;为结束标志的，考虑到各个系统中分号会有不同的意义，前面加反斜杠。{} 花括号代表前面find查找出来的文件名。在有些操作系统中只允许-exec选项执行诸如l s或ls -l这样的命令。大多数用户使用这一选项是为了查找旧文件并删除它们。建议在真正执行rm命令删除文件之前，最好先用ls命令看一下，确认它们是所要删除的文件exec选项后面跟随着所要执行的命令或脚本，然后是一对儿{ }，一个空格和一个\，最后是一个分号。 为了使用exec选项，必须要同时使用print选项。如果验证一下find命令，会发现该命令只输出从当前路径起的相对路径及文件名。 常用范例例1：ls -l命令放在find命令的-exec选项中find . -type f -exec ls -l {} \;find命令匹配到了当前目录下的所有普通文件，并在-exec选项中使用ls -l命令将它们列出。 例2：在目录中查找更改时间在n日以前的文件并删除它们find . -type f -mtime +14 -exec rm {} \; 例3：在目录中查找更改时间在n日以前的文件并删除它们，在删除之前先给出提示find . -name “*.log” -mtime +5 -ok rm {} \; 例4：-exec中使用grep命令find /etc -name “passwd“ -exec grep “root” {} \;find命令首先匹配所有文件名为“ passwd”的文件，例如passwd、passwd.old、passwd.bak，然后执行grep命令看看在这些文件中是否存在一个root用户。 例5：查找文件移动到指定目录find . -name “*.log” -exec mv {} .. \; 例6：用exec选项执行cp命令find . -name “*.log” -exec cp {} test3 \;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[linux命令学习之文件查找命令——find参数详解]]></title>
      <url>%2F2017%2F03%2F30%2Flinu%E5%91%BD%E4%BB%A4%E5%AD%A6%E4%B9%A0-%E6%96%87%E4%BB%B6%E6%9F%A5%E6%89%BE%E4%B9%8Bfind%E5%8F%82%E6%95%B0%E8%AF%A6%E8%A7%A3%2F</url>
      <content type="text"><![CDATA[find参数范例1．使用name选项：文件名选项是find命令最常用的选项，要么单独使用该选项，要么和其他选项一起使用。 可以使用某种文件名模式来匹配文件，记住要用引号将文件名模式引起来。用户目录$HOME中查找文件名符合.log的文件，使用~作为 ‘pathname’参数，波浪号~代表了$HOME目录。find ~ -name “.log” -print 想要在当前目录及子目录中查找所有的”.log”文件find . -name “.log” -print 想要的当前目录及子目录中查找文件名以一个大写字母开头的文件find . -name “[A-Z]*” -print 想要在/etc目录中查找文件名以host开头的文件find /etc -name “host*” -print 要想让系统高负荷运行，就从根目录开始查找所有的文件find / -name “*” -print 想在当前目录查找文件名以一个个小写字母开头，最后是4到9加上.log结束的文件find . -name “[a-z]*[4-9].log” -print 2. 用perm选项：按照文件权限模式用-perm选项如在当前目录下查找文件权限位为755的文件，即文件属主可以读、写、执行，其他用户可以读、执行的文件find . -perm 755 -print 数字前面要加一个横杠-，表示都匹配，如-005表示至少005,-757至少757 3．忽略某个目录-prune：如果在查找文件时希望忽略某个目录，因为你知道那个目录中没有你所要查找的文件，那么可以使用-prune选项来指出需要忽略的目录。在使用-prune选项时要当心，因为如果你同时使用了-depth选项，那么-prune选项就会被find命令忽略。find [-path ..] [expression]在路径列表的后面的是表达式-path “test” -prune -o -print 是 -path “test” -a -prune -o -print 的简写表达式按顺序求值, -a 和 -o 都是短路求值，与 shell 的 &amp;&amp; 和 || 类似如果-path “test” 为真，则求值 -prune , -prune 返回真，与逻辑表达式为真；否则不求值 -prune，与逻辑表达式为假。如果 -path “test” -a -prune 为假，则求值 -print ，-print返回真，或逻辑表达式为真；否则不求值 -print，或逻辑表达式为真。这个表达式组合特例可以用伪码写为:if -path “test” then-pruneelse-print 查看Test目录下文件，但不希望在Test/test2目录下查找find Test -path “Test/test2” -prune -o -print 避开多个文件夹:find Test ( -path Test/test2 -o -path Test/test1 ) -prune -o -print圆括号表示表达式的结合。 \ 表示引用，即指示 shell 不对后面的字符作特殊解释，而留给 find 命令去解释其意义。 查找某一确定文件，-name等选项加在-o 之后find Test (-path Test/test2 -o -path test/test1 ) -prune -o -name “*.log” -print 5．使用user和nouser选项：按文件属主查找文件：在$HOME目录中查找文件属主为peida的文件find ~ -user username -print 在/etc目录下查找文件属主为peida的文件:命令：find /etc -user username -print 实例3：为了查找属主帐户已经被删除的文件，可以使用-nouser选项。在/home目录下查找所有的这类文件find /home -nouser -print这样就能够找到那些属主在/etc/passwd文件中没有有效帐户的文件。在使用-nouser选项时，不必给出用户名； find命令能够为你完成相应的工作。 6．使用group和nogroup选项：就像user和nouser选项一样，针对文件所属于的用户组， find命令也具有同样的选项。为了在/apps目录下查找属于gem用户组的文件，可以用：find /apps -group gem -print要查找没有有效所属用户组的所有文件，可以使用nogroup选项。下面的find命令从文件系统的根目录处查找这样的文件:find / -nogroup-print 7．按照更改时间或访问时间等查找文件：如果希望按照更改时间来查找文件，可以使用mtime,atime或ctime选项。如果系统突然没有可用空间了，很有可能某一个文件的长度在此期间增长迅速，这时就可以用mtime选项来查找这样的文件。用减号-来限定更改时间在距今n日以内的文件，而用加号+来限定更改时间在距今n日以前的文件。希望在系统根目录下查找更改时间在5日以内的文件，可以用：find / -mtime -5 -print为了在/var/adm目录下查找更改时间在3日以前的文件，可以用:find /var/adm -mtime +3 -print 8．查找比某个文件新或旧的文件：如果希望查找更改时间比某个文件新但比另一个文件旧的所有文件，可以使用-newer选项。它的一般形式为：newest_file_name ! oldest_file_name其中，！是逻辑非符号。 查找更改时间比文件1log新但比文件3.log旧的文件（包含3.log） 9．使用type选项：在当前目录下查找所有的目录find . -type d -print 在当前目录下查找除目录以外的所有类型的文件find . ! -type d -print 在当前目录下查找所有的符号链接文件find . -type l -print 10．使用size选项：可以按照文件长度来查找文件，这里所指的文件长度既可以用块（block）来计量，也可以用字节来计量。以字节计量文件长度的表达形式为数字加c结尾；以块计量文件长度只用数字表示即可。在按照文件长度查找文件时，一般使用这种以字节表示的文件长度，在查看文件系统的大小，因为这时使用块来计量更容易转换。 在当前目录下查找文件长度大于1 M字节的文件find . -size +1000000c -print 在当前目录下查找文件长度恰好为100字节的文件:find . -size 100c -print 在当前目录下查找长度超过10块的文件（一块等于512字节）find . -size +10 -print 11．使用depth选项：在使用find命令时，可能希望先匹配所有的文件，再在子目录中查找。使用depth选项就可以使find命令这样做。这样做的一个原因就是，当在使用find命令向磁带上备份文件系统时，希望首先备份所有的文件，其次再备份子目录中的文件。下面例子可以看出输出是相反的。 12．使用mount选项：在当前的文件系统中查找文件（不进入其他文件系统），可以使用find命令的mount选项。 从当前目录开始查找位于本文件系统中文件名以XC结尾的文件find . -name “*.XC” -mount -print]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[linux命令学习之文件查找命令——find-exec命令]]></title>
      <url>%2F2017%2F03%2F30%2Flinu%E5%91%BD%E4%BB%A4%E5%AD%A6%E4%B9%A0-%E6%96%87%E4%BB%B6%E6%9F%A5%E6%89%BE%E4%B9%8Bfind-exec%E5%91%BD%E4%BB%A4%2F</url>
      <content type="text"><![CDATA[find之exec简介find一般查找文件，进一步的操作由exec完成。 使用find时，只要把想要的操作写在一个文件里，就可以用exec来配合find查找 命令学习exec解释：-exec 参数后面跟的是command命令，它的终止是以;为结束标志的，考虑到各个系统中分号会有不同的意义，前面加反斜杠。{} 花括号代表前面find查找出来的文件名。在有些操作系统中只允许-exec选项执行诸如l s或ls -l这样的命令。大多数用户使用这一选项是为了查找旧文件并删除它们。建议在真正执行rm命令删除文件之前，最好先用ls命令看一下，确认它们是所要删除的文件exec选项后面跟随着所要执行的命令或脚本，然后是一对儿{ }，一个空格和一个\，最后是一个分号。 为了使用exec选项，必须要同时使用print选项。如果验证一下find命令，会发现该命令只输出从当前路径起的相对路径及文件名。 常用范例例1：ls -l命令放在find命令的-exec选项中find . -type f -exec ls -l {} \;find命令匹配到了当前目录下的所有普通文件，并在-exec选项中使用ls -l命令将它们列出。例2：在目录中查找更改时间在n日以前的文件并删除它们find . -type f -mtime +14 -exec rm {} \; 例3：在目录中查找更改时间在n日以前的文件并删除它们，在删除之前先给出提示find . -name “*.log” -mtime +5 -ok rm {} \; 例4：-exec中使用grep命令find /etc -name “passwd“ -exec grep “root” {} \;find命令首先匹配所有文件名为“ passwd”的文件，例如passwd、passwd.old、passwd.bak，然后执行grep命令看看在这些文件中是否存在一个root用户。 例5：查找文件移动到指定目录find . -name “*.log” -exec mv {} /home/jiangbiao/Test/test4 \; 例6：用exec选项执行cp命令find . -name “*.log” -exec cp {} /home/jiangbiao/Test/test3 \;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[linux下telnet远程登入]]></title>
      <url>%2F2017%2F03%2F30%2Flinux%E4%B8%8Btelnet%E8%BF%9C%E7%A8%8B%E7%99%BB%E5%85%A5%2F</url>
      <content type="text"><![CDATA[telnet原理当用Telnet登录进入远程计算机系统时，事实上启动了两个程序，一个 叫Telnet客户程序，它运行在你的本地机上；另一个叫Telnet服务器程序，它运行在你要登录的远程计算机上。本地机上的客户程序要完成如下功能：1 、建立与服务器的TCP 联接；2 、从键盘上接收你输入的字符；3 、把你输入的字符串变成标准格式并送给远程服务器；4 、从远程服务器接收输出的信息；5 、把该信息显示在你的屏幕上。 远程计算机的“服务”程序通常被称为“精灵”，它平时不声不响地候在远程计算机上，一接到你的请求，就马上活跃起来，并完成如下功能：1 、通知你的计算机，远程计算机已经准备好了；2 、等候你输入命令；3 、对你的命令作出反应（如显示目录内容，或执行某个程序等）；4 、把执行命令的结果送回给你的计算机；5 、重新等候你的命令。 客户机上装一个telnet的客户端，服务器上装一个telnet的监听程序（精灵），一般这个监听程序监听的是23号端口。把这个过程简单抽象一下，就是客户端使用telnet工具发送一个命令到服务器端，服务器端监听到了之后就调用系统相关API来执行这些命令，从而达到了客户机远程操作服务器主机的目的。 这里需要注意一点，“把你输入的字符串变成标准格式并送给远程服务器”，指的是接受的字符，要按照一定的协议格式传送到服务器端，而这些字符是通过TCP连接传输的，跟Http有点像。Http是通过TCP连接传输字符，但是数据格式是HTTP协议规定的格式。简单来说，所谓的HTTP协议，FTP协议，SMTP协议，就是各自规定了以什么样的数据包方式在网络上通过TCP管道传输数据。 其实，telnet是以TCP为基础与服务器进行通信，所以它的功能远不止远程登录服务器（远程操纵服务器）。不管是什么协议，如果它基于 tcp/ip，那么你使用 TcpClient（或者 Socket）连接它，然后发点信息，依然能连通。Telnet可以看作是一种TCP的连接工具。 安装telnet在Ubuntu下的telnet服务需要安装xinetd服务和telnetd服务 apt-get install xinetd apt-get install telnetd 配置telnet1.gedit /etc/inetd.conf没有则添加如下注释依次为：服务名称。和xinetd一样，inetd通过查询/etc/service获得该服务的相关信息。套接口类型。TCP用stream，UDP用dgram。该服务使用的通信日志相关参数协议。inetd是否等到守护进程结束才继续接管端口。wait表示等待（相当于xinetd的wait = yes），nowait表示不等待，inetd每次接到一个请求就启动守护进程的新副本（相当于xinetd的wait = no）。运行该守护进程的用户身份。守护进程二进制文件的完整路径及其命令行参数 2.gedit /etc/xinetd.conf注释：instances = 60：表示最大连接进程数为60个。log_type = SYSLOG daemon info：表示使用syslog进行服务登记。log_on_success= HOST PID：表示设置成功后记录客户机的IP地址的进程ID。log_on_failure = HOST：表示设置失败后记录客户机的IP地址。cps = 25 30：表示每秒25个入站连接，如果超过限制，则等待30秒。主要用于对付拒绝服务攻击。 3.gedit /etc/xinetd.d/telnet注释：disable = no：表示启用这个服务。socket_type = stream：表示服务的数据包类型为stream。wait = no：表示不需等待，即服务将以多线程的方式运行。user = root：表示执行此服务进程的用户是root。server = /usr/bin/in.telnetd：启动程序的位置。log_on_failure += USERID：表示设置失败时，在/etc/xinetd.conf中设置的default值基础之上还把UID添加到系统登记表 重启xinetd 查看telnet状态 telnet端口telnet端口默认23，一般不做修改，在/etc/services中查看，如果需要从其他端口启动该服务，则可收到配置 telnet远程登入使用putty进行telnet远程登入，默认端口是23，主机IP是linux下的IP地址，通过ifconfig查看。 备注xinetd 配置参数 日志相关参数]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Hexo+github搭建个人博客（一）]]></title>
      <url>%2F2017%2F03%2F29%2Fhexo-github-one%2F</url>
      <content type="text"><![CDATA[简介Hexo 是一个快速、简洁且高效的静态站点生成框架，它基于 Node.js 。 它有以下特点： 超快速度：Node.js 所带来的超快生成速度，让上百个页面在几秒内瞬间完成渲染。 支持Markdown：Hexo 支持 GitHub Flavored Markdown 的所有功能，甚至可以整合 Octopress 的大多数插件。 一件部署：只需一条指令即可部署到Github Pages，或其他网站 丰富的插件：Hexo 拥有强大的插件系统，安装插件可以让 Hexo 支持 Jade,CoffeeScript。 安装准备工作安装 Hexo 相当简单。然而在安装前，您必须检查电脑中是否已安装下列应用程序: Node.jsGit 安装 Git Windows： git下载地址： 官网Download Now 安装：在Git Setup中选择Use Git from the windows Command Prompt,除此之外一路Next完成安装 安装 Node.js Windos:Node.js v0.12.5 x64 :下载地址： 百度云Download Now Node.js官网Download Now 安装：一路NExt即可，等待完成安装 ##软件验证运行窗口CMD,输入一下命令，会显示相应版本信息： git --version node -v npm -v申请GITHUB申请地址：Github方法简述： 申请账号（用户名+密码),并进行邮箱验证 创建repository，名字与用户名一致。例如我的用户名BlueSky-chamo,Repository name为BlueSky-chamo.github.io 在创建的repository中settings中的Github pages中选择theme,启用Github page## 安装 Hexohexo是基于node.js的静态博客，官网也是搭建在GitHub上安装方法： 新建文件夹blog,右键选择Git Bash 安装hexo为了避免出现被“墙”，使用淘宝NPM镜像npm install -g cnpm --registry=https://registry.npm.taobao.org 安装hexo:cnpm install -g hexo-clicnpm install hexo --save 验证：hexo -v 本地运行：初始化命令：hexo init安装生成器：cnpm install浏览器本地访问：hexo s,本地浏览器输入http://localhost:4000/即可本地访问 hexo基本管理目录结构12345678.├── _config.yml├── package.json├── scaffolds├── source| ├── _drafts| └── _posts└── _config.yml：站点配置文件，即博客基本设置source:资源文件，即自定义的页面与推送的博客文件 ###_config.yml文件关键配置： url: 博客地址，与github申请的repository一致 如：http://BlueSky-chamo.github.io theme: 博客主题。默认下为landscape deploy: 发布设置。两种方式如下，可自行选择repository: https://github.com/BlueSky-chamo/BlueSky-chamo.github.io.gitrepository: git@github.com:BlueSky-chamo/BlueSky-chamo.github.io.git source文件资源文件 新建文章hexo new &quot;hello&quot;2.新建页面hexo new page hello Github与hexo创建联系配置SSH KEY 生成SSH KEY：ssh-keygen -t rsa -C &quot;邮件地址@youremail.com&quot; 按提示输入密码后在C:\Documents and Settings\Administrator.ssh\id_rsa.pub文件的内容即为秘钥 登陆github系统，点击右上角的 Account Settings—&gt;SSH Public keys —&gt; add another public keys把你本地生成的密钥复制到里面（key文本框中） 设置git身份信息git config --global user.name &quot;你的用户名&quot;git config --global user.email &quot;你的邮箱&quot; 验证git信息SSH -T git@github.com 发布博客安装hexo git插件cnpm install hexo-deployer-git --save 发布更新博客hexo d -g ##参考零基础免费搭建个人博客]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Hexo+Github搭建个人博客（二）]]></title>
      <url>%2F2017%2F03%2F29%2Fhexo-github-two%2F</url>
      <content type="text"><![CDATA[安装NEXT主题下载主题Hexo 安装主题的方式非常简单，只需要将主题文件拷贝至站点目录的 themes 目录下， 然后修改下配置文件即可。&gt; cd bloggit clone https://github.com/iissnan/hexo-theme-next themes/next 启用next主题在站点配置文件_config.yml中： theme: next 验证主题 hexo shttp://localhost:4000 NEXT主题设置Hexo 中有两份主要的配置文件，其名称都是 _config.yml 。其中，一份位于站点根目录下，主要包含 Hexo 本身的配置；另一份位于主题目录下，主要用于配置主题相关的选项。前者称为 站点配置文件，后者称为 主题配置文件 基本设置关于NEXT主题的基本设置可参考NEXT在线文档，包含NEXT主题的详细使用介绍。 其他设置添加High一下打开博客根目录 \themes\next\layout\_partials\header.swig ，在&lt;ul&gt; ... /ul&gt; 标签之间加入以下代码：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137&lt;li&gt; &lt;a title="把这个链接拖到你的Chrome收藏夹工具栏中" href='javascript:(function() &#123; function c() &#123; var e = document.createElement("link"); e.setAttribute("type", "text/css"); e.setAttribute("rel", "stylesheet"); e.setAttribute("href", f); e.setAttribute("class", l); document.body.appendChild(e) &#125; function h() &#123; var e = document.getElementsByClassName(l); for (var t = 0; t &lt; e.length; t++) &#123; document.body.removeChild(e[t]) &#125; &#125; function p() &#123; var e = document.createElement("div"); e.setAttribute("class", a); document.body.appendChild(e); setTimeout(function() &#123; document.body.removeChild(e) &#125;, 100) &#125; function d(e) &#123; return &#123; height : e.offsetHeight, width : e.offsetWidth &#125; &#125; function v(i) &#123; var s = d(i); return s.height &gt; e &amp;&amp; s.height &lt; n &amp;&amp; s.width &gt; t &amp;&amp; s.width &lt; r &#125; function m(e) &#123; var t = e; var n = 0; while (!!t) &#123; n += t.offsetTop; t = t.offsetParent &#125; return n &#125; function g() &#123; var e = document.documentElement; if (!!window.innerWidth) &#123; return window.innerHeight &#125; else if (e &amp;&amp; !isNaN(e.clientHeight)) &#123; return e.clientHeight &#125; return 0 &#125; function y() &#123; if (window.pageYOffset) &#123; return window.pageYOffset &#125; return Math.max(document.documentElement.scrollTop, document.body.scrollTop) &#125; function E(e) &#123; var t = m(e); return t &gt;= w &amp;&amp; t &lt;= b + w &#125; function S() &#123; var e = document.createElement("audio"); e.setAttribute("class", l); e.src = i; e.loop = false; e.addEventListener("canplay", function() &#123; setTimeout(function() &#123; x(k) &#125;, 500); setTimeout(function() &#123; N(); p(); for (var e = 0; e &lt; O.length; e++) &#123; T(O[e]) &#125; &#125;, 15500) &#125;, true); e.addEventListener("ended", function() &#123; N(); h() &#125;, true); e.innerHTML = " &lt;p&gt;If you are reading this, it is because your browser does not support the audio element. We recommend that you get a new browser.&lt;/p&gt; &lt;p&gt;"; document.body.appendChild(e); e.play() &#125; function x(e) &#123; e.className += " " + s + " " + o &#125; function T(e) &#123; e.className += " " + s + " " + u[Math.floor(Math.random() * u.length)] &#125; function N() &#123; var e = document.getElementsByClassName(s); var t = new RegExp("\\b" + s + "\\b"); for (var n = 0; n &lt; e.length; ) &#123; e[n].className = e[n].className.replace(t, "") &#125; &#125; var e = 30; var t = 30; var n = 350; var r = 350; var i = "//7xuupy.com1.z0.glb.clouddn.com/tongxingSibel%20-%20Im%20Sorry.mp3"; var s = "mw-harlem_shake_me"; var o = "im_first"; var u = ["im_drunk", "im_baked", "im_trippin", "im_blown"]; var a = "mw-strobe_light"; var f = "//s3.amazonaws.com/moovweb-marketing/playground/harlem-shake-style.css"; var l = "mw_added_css"; var b = g(); var w = y(); var C = document.getElementsByTagName("*"); var k = null; for (var L = 0; L &lt; C.length; L++) &#123; var A = C[L]; if (v(A)) &#123; if (E(A)) &#123; k = A; break &#125; &#125; &#125; if (A === null) &#123; console.warn("Could not find a node of the right size. Please try a different page."); return &#125; c(); S(); var O = []; for (var L = 0; L &lt; C.length; L++) &#123; var A = C[L]; if (v(A)) &#123; O.push(A) &#125; &#125; &#125;)() '&gt;High一下&lt;/a&gt; &lt;/li&gt; 添加最近访客 在主题配置文件中menu项添加guestbook菜单 在Hexo的source文件夹下，利用hexo new page guestbook创建guestbook页面,对应的index文件中添加如下代码：12最近访客 &lt;div class=&quot;ds-recent-visitors&quot; data-num-items=&quot;39&quot; data-avatar-size=&quot;40&quot; id=&quot;ds-recent-visitors&quot;&gt;&lt;/div&gt; 修改文章内链接文本样式将链接文本设置为蓝色，鼠标划过时文字颜色加深，并显示下划线。找到文件 themes\next\source\css\_custom\custom.styl ，添加如下 css 样式：12345678.post-body p a &#123; color: #0593d3; border-bottom: none; &amp;:hover &#123; color: #0477ab; text-decoration: underline; &#125;&#125; 给 Github 添加 README默认情况下，Github中每一个项目，我们希望有一份 README.md 的文件来作为项目的说明，但是我们在项目根目录下的 blog\source 目录下创建一份 README.md 文件，写好说明介绍，部署的时候，这个 README.md 会被 hexo 解析掉，而不会被解析到 Github 中去的。正确的解决方法其实很简单： 把 README.md 文件的后缀名改成 “MDOWN” 然后扔到blog/source文件夹下即可，这样 hexo 不会解析，Github 也会将其作为 MD 文件解析。 插入网易云音乐如果只加入单曲，只需要搜索歌曲，点开歌曲名，点击生成外链播放器，复制html代码将html代码无需任何修改放入markdown文章里就OK了。 如果想要加入歌单，就需要自己创建歌单，然后分享歌单，找到自己的分享动态，点进去可以看到有“生成外链播放器”这些字眼，其余操作就和上面一样了。 参考Never_yu’s Blog]]></content>
    </entry>

    
  
  
</search>
