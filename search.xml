<?xml version="1.0" encoding="utf-8"?>
<search>
  
    
    <entry>
      <title><![CDATA[polyfill — Respond.js]]></title>
      <url>%2F2017%2F02%2F11%2Frespond-js%2F</url>
      <content type="text"><![CDATA[Respond.js 让不支持 css3 Media Query 的浏览器包括 IE6-IE8 等其他浏览器支持媒体查询。 Respond.js 是一个快速、轻量的 polyfill，用于为 IE6-8 以及其它不支持 CSS3 Media Queries 的浏览器提供媒体查询的 min-width 和 max-width特性，实现响应式网页设计（Responsive Web Design）。 响应式布局，理想状态是，对 PC/移动 各种终端进行响应。媒体查询的支持程度是 IE9+ 以及其他现代的浏览器，但是 IE8 在市场当中仍然占据了比较大量的市场份额，使我们不得不进行 IE 低端浏览器的考虑。那么如何在 IE6~8 浏览器中兼容响应式布局呢？这里我们需要借助这样一个文件：respond.js. 文件下载地址：respond.js. 自己在阅读了官方文档之后，进行了一系列测试。友情提示各位朋友，关于 respond.js 的使用，有一些需要注意的地方，一旦不注意，在 IE6-8 中就无法显示出来。 插件原理既然要实现响应式网页，那么就需要用到媒体查询，媒体查询的核心是 min-width 和 max-width,而 IE8 以下以及一些其它的浏览器不支持这两个属性，respond.js 是怎么做的呢？ 将 &lt;head&gt; 中所有外部引入的CSS文件路径取出来存储到一个数组当中； 遍历数组，并一个个发送 AJAX 请求； AJAX 回调后，分析 response 中的 media query 的 min-width 和 max-width 语法（注意，仅仅支持 min-width 和 max-width ），分析出 viewport 变化区间对应相应的 css 块； 页面初始化时和 window.resize 时，根据当前 viewport 使用相应的 css 块。 使用方法考虑到 IE9 是支持 CSS3 的，所以直接在 HTML 页面的 &lt;head&gt; 标签中添加脚本引入即可： 123456&lt;head&gt; &lt;link rel="stylesheet" href="style.css"&gt; &lt;!--[if lt IE 9]&gt; &lt;script src="js/respond.js"&gt;&lt;/script&gt; &lt;![endif]--&gt;&lt;/head&gt; 讲道理，我们是应该将 js 文件放在 html 文件的最后，但是 repond.js 文件，我还是建议你将它放在 &lt;head&gt; 中，并且放在 css 文件的后面。越早引入越好，在 IE 下面看到页面闪屏的概率就越低，因为最初 css 会先渲染出来，如果 respond.js 加载得很后面，这时重新根据 media query 解析出来的 css 会再改变一次页面的布局等，所以看起来有闪屏的现象. 核心结论那么此时，就可以根据基本的实现思路，得到一些书写代码时要注意的地方： 需要启动本地服务器（localhost），不能使用普通本地的url地址（file://开头）； 需要外部引入 CSS 文件，将 CSS 样式书写在 style 中是无效的； 由于 respond 插件是查找 CSS 文件，再进行处理，所以 respond.js 文件一定要放置在 CSS 文件的后面； 另外，虽然把 respond.js 放置在 &lt;head&gt; 里还是在 &lt;body&gt; 后面都能够实现，但是建议放置在 &lt;head&gt; 中（具体原因在下面的文档提示中有提到）； 最好不要为 CSS 设置 utf-8 的编码，使用默认（原因详见下面的文档提示部分） 文档提示在官方文档当中的一些提示： 越早的引入 respond.js 文件，也就越可能避免 IE 下出现的闪屏。 不支持嵌套的媒体查询。 utf-8 的字符编码对 respond.js 文件的运行有影响。官方API原文：if CSS files are encoded in UTF-8 with Byte-Order-Mark, they will not work with Respond.js in IE7 or IE8.基本含义就是：utf-8 格式的 CSS 文件字符编码会对插件造成影响但是在我使用 IE6-8 进行测试的时候，都能够正常显示（无论是在 css 文件中增加 charset 设置还是在 link 标签中增加 charset 设置）。因此，并不是太清楚这个位置 bug 的含义。 跨域可能会出现闪屏（还没有测试，具体情况不详） NOTE Respond.js 和 跨域（cross-domain） CSS 的问题如果Respond.js和CSS文件被放在不同的域名或子域名下面（例如，使用CDN）时需要一些额外的设置。请参考Respond.js文档获取详细信息。 Internet Explorer 8 与 box-sizingIE8 不能完全支持 box-sizing: border-box; 与 min-width、max-width、min-height 或 max-height 一同使用。由于此原因，从 Bootstrap v3.0.1 版本开始，我们不再为 .container 使用 max-width。 IE兼容模式Bootstrap 不支持 IE 的兼容模式。为了让 IE 浏览器运行最新的渲染模式，建议将此 标签加入到你的页面中：&lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=Edge&quot;&gt;此标签被加入到所有文档页面和案例页面中，以确保在每个被支持的 IE 浏览器中保持最好的页面展现效果。 Respond.js 和 @importRespond.js 不支持通过 @import 引入的 CSS 文件。例如，Drupal 一般被配置为通过 @import 引入 CSS 文件，Respond.js 对其将无法起到作用。 Tips从 respond.js 的工作原理可以知道，它将 &lt;head&gt; 中所有外部引入的 CSS 文件路径取出来存储到一个数组当中；然后遍历数组，并一个个发送 AJAX 请求；可以看出这里必须依赖 ajax 请求 css 路径才能得到 css 文件中的 media query 的内容，那 ajax 的跨域问题就要解决了； 由于我们的静态资源都是要放在 cdn 的，responds.js 也给出了跨域方法，即引入代理页面： //把 cross-domain/respond-proxy.html 放到cdn上//把 cross-domain/respond.proxy.gif 放到当前域服务器上 12345678&lt;!-- Respond.js proxy on external server --&gt;&lt;link href="http://externalcdn.com/respond-proxy.html" id="respond-proxy" rel="respond-proxy" /&gt;&lt;!-- Respond.js redirect location on local server --&gt;&lt;link href="/path/to/respond.proxy.gif" id="respond-redirect" rel="respond-redirect" /&gt;&lt;!-- Respond.js proxy script on local server --&gt;&lt;script src="/path/to/respond.proxy.js"&gt;&lt;/script&gt; 其他的支持响应式布局的插件 css3-dediaqueries.jscss3-mediaqueries.js 支持几乎所有的 media query 的语法。会出现闪屏。并不是很推荐使用，虽然能够支持全部的 media queries,但 min-width 和 max-width 其实就可以满足我们对响应式布局的需要。 补充一点if CSS files are encoded in UTF-8 with Byte-Order-Mark,they will not work with Repond.js in IE7 or IE8. 也就是说保存格式应该是 utf-8 无 BOM 格式，BOM 会影响程序对文档的处理，正常的 utf-8 文档应该没事。 Tipsalways link stylesheets or write inline CSS before js scripts. Respond.js on Github： https://github.com/scottjehl/Respond.]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[腻子脚本 — HTML5Shiv]]></title>
      <url>%2F2017%2F01%2F18%2Fhtml5shiv%2F</url>
      <content type="text"><![CDATA[简介HTML5shiv is a javascript workaround to provide support for the new HTML 5 elements in IE Browsers older than IE 9. 越来越多的站点开始使用 HTML5 标签。但是目前的情况是还有很多人在使用IE6，IE7，IE8。 而IE6，IE7，IE8是不能识别 HTML5 标签的。 这里提供一种让 IE 浏览器支持 HTML5 的方法，那就是使用 HTML5Shiv。 HTML5Shiv 主要解决 HTML5 提出的新的元素不被IE6-8识别。 为什么要使用 HTML5 的新标签 &lt;header&gt; 定义页面或区段的头部 &lt;footer&gt; 定义页面或区段的尾部 &lt;nav&gt; 定义页面或区段的导航区域 &lt;section&gt; 页面的逻辑区域或内容组合 &lt;article&gt; 定义正文或一段完整的内容 &lt;aside&gt; 定义补充或相关内容 使用他们能让代码语义化更直观，而且更方便 SEO 优化，但是此 HTML5 新标签在 IE6/IE7/IE8 上并不能识别，需要 javascript 处理，所以我们就需要使用目前使用最广泛的 html5shiv.js 了，包括 Bootstrap 框架也是使用的这个来兼容低版本 IE 的。 实现原理 这些 HTML5 新元素不能被 IE6-8 识别，不能作为父节点包裹子元素，并且不能应用 CSS 样式。让 CSS 样式应用在未知元素上只需执行 document.createElement(elementName) 即可实现。HTML5Shiv 就是根据这个原理创建的。 关于 HTML5 不得不提 IE，在苹果、Google、Opera 和 Mozilla 等主流浏览器厂商积极参与新版本 HTML 标准的制定和推广时，微软却对 HTML5 规范不屑一顾。然而微软近期才表态要在 IE 中支持 HTML5,以致到今天为止的 IE8 及以下是无法支持 HTML5 标签的. 使用HTML5Shiv 的使用非常的简单，考虑到 IE9 是支持 HTML5 的，所以只需要在页面 head 中添加如下代码即可：123&lt;!--[if lt IE 9]&gt; &lt;script src=".js/html5shiv.js "&gt;&lt;/script &gt;&lt;![endif]–-&gt; The syntax for the HTML5shiv is :12345&lt;head&gt; &lt;!--[if lt IE 9]&gt; &lt;script src="./js/html5shiv.js"&gt;&lt;/script&gt; &lt;![endif]--&gt;&lt;/head&gt; 注意事项注意事项一在引入了 html5shiv.js 以后，还需要在你自己的 css 文件中添加:123article,aside,dialog,footer,header,section,footer,nav,figure,menu&#123; display:block;&#125; 主要是让这些 HTML5 标签成块状,像 div 那样。 No matter how ways what did you using, you should be initialize the new lable css.123article,aside,dialog,footer,header,section,footer,nav,figure,menu&#123; display:block;&#125; 注意事项二 因为 html5shiv.js 是 JavaScript 文件，如果 IE6/7/8 禁用脚本的用户,那么就变成了无样式的”白板”网页,我们该怎么解决呢? 我们可以参照 Facebook 的做法，即引导用户进入带有 noscript 标识的页面，用 xhtml 标签替换 html5 标签，这要比为了保持兼容而写大量 hack 的作法更轻便一些。123456789&lt;!--[if lte IE 8]&gt; &lt;noscript&gt;&lt;style&gt; .html5-wrappers&#123;display:none!important;&#125;&lt;/style&gt;&lt;div class="ie-noscript-warning"&gt;您的浏览器禁用了脚本，请&lt;a href="#"&gt;查看这里&lt;/a&gt;来启用脚本!或者&lt;a href="/?noscript=1"&gt;继续访问&lt;/a&gt;.&lt;/div&gt;&lt;/noscript&gt;&lt;![endif]--&gt; 这样可以引导用户开启脚本，或者直接跳到 xhtml 标签设计的页面。 注意事项三 HTML5shiv is found within the &lt;head&gt; tag. HTML5shiv is a javascript file that is referenced in a &lt;script&gt; tag. You should usr HTML5shiv when you are using the new HTML5 element such as : &lt;header&gt;,&lt;footer&gt;,&lt;nav&gt;,&lt;aside&gt;,&lt;article&gt; Download the latest version of HTML5shiv from github or reference the Open Source Software CDN version at https://oss.maxcdn.com/libs/html5shiv/3.7.0/html5shiv.js or https://cdn.bootcss.com/html5shiv/3.7.0/html5shiv.min.js. You will require the HTML5shiv to provide compatibility for IE Browser older than IE 9. ExampleHTML 5 DocumentIf you created a new web page in HTML5,you would include the HTML5shiv as follows: &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;!--[if lt IE 9]&gt; &lt;script src=&quot;.js/html5shiv.min.js&quot;&gt;&lt;/script&gt; &lt;![endif]--&gt; &lt;/head&gt; In this HTML 5 Document example,we have added HTML5shiv within the tag.In this case,the HTML5shiv is a javascript file called html5shiv.js found in the ./js directory. If you did not want to download and store the HTML5shiv on your site,you could reference the version found on the Open Source Software CDN site. Support two CDN site1234567&lt;head&gt;&lt;meta charset="UTF-8"&gt;&lt;title&gt;HTML 5 Example by github.com/neveryu&lt;/title&gt;&lt;!--[if lt IE 9]&gt; &lt;script src="https://oss.maxcdn.com/libs/html5shiv/3.7.0/html5shiv.js"&gt;&lt;/script&gt;&lt;![endif]--&gt;&lt;/head&gt; 1234567&lt;head&gt;&lt;meta charset="UTF-8"&gt;&lt;title&gt;HTML 5 Example by github.com/neveryu&lt;/title&gt;&lt;!--[if lt IE 9]&gt; &lt;script src="https://cdn.bootcss.com/html5shiv/3.7.0/html5shiv.min.js"&gt;&lt;/script&gt;&lt;![endif]--&gt;&lt;/head&gt; 注意事项四HTML 4.0.1 Transitional DocumentHTML5shiv does not apply to HTML 4.0.1 Transitional. XHTML 1.0 Transitional DocumentHTML5shiv does not apply to XHTML 1.0 Transitional. XHTML 1.0 Strict DocumentHTML5shiv does not apply to XHTML 1.0 Strict. XHTML 1.1 DocumentHTML5shiv does not apply to XHTML 1.1. Tips关于低版本浏览器不能识别 HTML5 标签的问题，除了使用 html5shiv.js 之外，还有一种做法就是为网站创建多套模版，通过程序对 User-Agent 的判断给不同的浏览器用户显示不同的页面，比如优酷网就是采用的这种模式。 总结HTML5Shiv and Respond.js for IE8 support of HTML5 elements and media queries.]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[【转】为什么一些生活中很外向开朗的人会喜欢独来独往]]></title>
      <url>%2F2016%2F12%2F24%2Fwhy-introversion-like-alone%2F</url>
      <content type="text"><![CDATA[因为他是一个内向的人。 不要怀疑，很多人都是这样。 内向的人，通过独处来恢复精力。 所以他们不是喜欢孤独，而是，孤独才是他们的常态。 他们跟别人交流、相处，其实都是在消耗精力。 下面详述： 心理学上有一个模型，叫「五因素模型」，又叫「大五人格模型」。是目前公认比较全面的人格分析模型。这个模型中，把人的性格用五个维度来区分。分别是： 外向性（Extraversion）神经质（Neuroticism）亲和性（Agreeableness）负责性（Conscientiousness）经验开放性（Openness to experience） 在「外向性」维度量表上，高得分者被认为是「外向」的，而低得分者则被认为「内向」。这里的「外向」和「内向」是有一定描述的。 外向：倾向于人际交往，热情、爱说话、充满自信、喜欢交友。在社交聚会中感到快乐。大都愿意与他人共处而不是独处。在其他人面前精力充沛，而在独处时变得平淡或感到无聊。更愿意与别人交谈而不是独自思考。等等。 内向：倾向于安静的、低调的、深思熟虑的，很少参加社交活动。他们在独自的活动中感到快乐，比如阅读、写作、绘画、编程，等等。典型内向的人大都愿意独处而不是与他人共处。习惯在一个时间只专注于一件事情。更愿意独自思考而不是与别人交谈。等等。 可以看到，区分「外向」和「内向」，最关键是，是看他是更愿意跟别人在一起，还是一个人独处。而不是开朗、活泼、健谈，这些。 因为：内向的人在跟亲密朋友相处时，也能表现出如上特质。 更深入地说，外向与内向的差异，主要在于下面三点： 经验的广度和深度外向的人倾向于广度。他们喜欢了解很多事物，对很多领域都抱有热情，喜欢交很多朋友（但也许都不够知心），喜欢尝试不同的东西。对他们而言，生活就是积累尽可能广泛的经验。 内向的人则倾向于拓展某一方面的深度。他们同样会对许多领域和事物抱有兴趣，但与外向的人不同，他们大多不会浅尝辄止，而是会深入钻研下去。他们的朋友不多，多数人跟他们只是点头之交，但他们会对朋友交心。对他们而言，太多的经验会造成压力。 对刺激的反应外向的人喜欢体验各种不同的刺激，并对刺激有较高的适应值和较高的恢复水平。也就是说，他们乐于接受刺激，并且对刺激有较高的适应能力。 内向的人内心活动水平较高，对他们而言，任何进入大脑的刺激，都会引起紧张水平的迅速升高（相对于外向的人），引起「刺激过多」的不舒服感受。 精力的来源 （这是重点）外向的人会从外部世界获得精力。对他们而言，聚会、聊天、一起做事情，都是获得精力的方式。而当他们独处时，亦即切断了他们的精力来源，很快就会感到精力耗尽和无聊疲倦。 内向的人，则是自己制造精力。对他们而言，聚会、聊天、一起做事情，都是在花费他们的精力。他们只有在独处时，才能恢复精力。所以有些人跟别人在一起时很容易疲倦，自个儿待着反而神采奕奕，就是这样。 但是，内向的人绝非都安静、低调、不善言谈，当他们精力充沛时，他可以跟你聊上几个小时，眉飞色舞。同样，外向的人也绝非一定开朗活泼。当他精力耗尽时，同样会一蹶不振。 关键只在于精力的水平，以及恢复精力的方式。 这里给一张图，帮助大家理解： 作者：Lachel原文：https://www.zhihu.com/question/24303670]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Hexo-NexT搭建个人博客（四）]]></title>
      <url>%2F2016%2F12%2F15%2Fhexo-next-four%2F</url>
      <content type="text"><![CDATA[提示：本篇文章将介绍在使用 heox 做博客框架中的一些 bug 处理情况。 按照之前的教程介绍应该是会比较顺利的搭建好你的博客，但是难免会遇到一些意外，这个时候就要学会解决问题了。解决问题的原则是：查看 bug 信息，从上到下依次解决 bug。 下面来看几个例子： 首先这个是在 hexo clean 时报的错：提示插件 hexo-deployer-git 加载失败，想了一下，应该是上次我在移动博客目录的时候，这个模块中有一些文件名比较长的文件，系统会提示移动不过来，导致这个模块异常，很简单，文件夹中删除这个模块，重新安装即可。（或者使用 npm 来卸载这个模块，然后重新安装）如下： OK ， 现在好了，hexo clean 没有报错了。 下面，我是在执行 hexo g 的操作，同样也出现了错误： 按照图中我标注的步骤，来看一下错误信息：如 1 所示：我们首先会发现缺少模块 isarray ，但是我们查看 package.json 文件，我们的项目根本就没有引入 isarray 这个模块，我猜测这个 isarray 模块应该是某个模块的子模块 。 如 2 所示：我们顺着 at 一路往下找。 如 3 所示：发现这个 isarray 是在 hexo-generator-sitemap 里面的 ，所以我们删除这个 hexo-generator-sitemap 模块，然后重新安装这个模块。如下： OK ， 现在好了，hexo g 没有报错了。 那么，就以这两个例子来作为本次的示范吧，其实，Hexo 中的一些问题还是比较好解决的，因为它都是依赖其他模块的，定位到出问题的模块，卸载重装即可。 总结：遇到问题 bug，一定要仔细查阅错误提示信息，遵守从上往下解决的方案。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[jQuery使用技巧]]></title>
      <url>%2F2016%2F11%2F22%2Fuse-jquery-skill%2F</url>
      <content type="text"><![CDATA[禁用页面的右键菜单12345$(document).ready(function()&#123; $(document).bind("contextmenu",function(e)&#123; return false; &#125;); &#125;); 新窗口打开页面123456789101112131415161718&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;Document&lt;/title&gt; &lt;script src="jquery.js"&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;a href="https://www.google.com"&gt;google_新窗口&lt;/a&gt; &lt;a href="https://www.google.com" rel="external"&gt;google_新窗口&lt;/a&gt; &lt;a href="demo1.html"&gt;当前窗口&lt;/a&gt;&lt;script&gt; $(function()&#123; $('a[href^="http://"]').attr("target","_blank"); &#125;);&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 输入框文字获取和失去焦点【推荐】 1234567891011121314151617181920212223242526272829&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;Document&lt;/title&gt; &lt;script src="jquery.js"&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;input type="text" class="text1" /&gt;&lt;script&gt;$(document).ready(function() &#123; $("input.text1").val("Enter your search text here."); textFill( $('input.text1') ); &#125;);function textFill(input)&#123; //input focus text function var originalvalue = input.val(); input.focus( function()&#123; if( $.trim(input.val()) == originalvalue )&#123; input.val(''); &#125; &#125;).blur( function()&#123; if( $.trim(input.val()) == '' )&#123; input.val(originalvalue); &#125; &#125;); &#125;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 返回头部滑动动画123456789101112&lt;script&gt;jQuery.fn.scrollTo = function(speed) &#123; var targetOffset = $(this).offset().top; $('html,body').stop().animate(&#123;scrollTop: targetOffset&#125;, speed); return this;&#125;; // use$("#goheader").click(function()&#123; $("body").scrollTo(500); return false;&#125;); &lt;/script&gt; 获取鼠标位置123456789101112131415161718&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;Document&lt;/title&gt; &lt;script src="jquery.js"&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;div id="XY" &gt;&lt;/div&gt;&lt;script&gt;$(function()&#123; $(document).mousemove(function(e)&#123; $('#XY').html("X : " + e.pageX + " | Y : " + e.pageY); &#125;);&#125;);&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 关闭所有 jQuery 动画效果1jQuery.fx.off = true; 检测鼠标的右键和左键123$('#box').mousedown(function(e) &#123; alert(e.which);&#125;); 回车提交表单1234567$(function() &#123; $('input').keyup(function(e) &#123; if(e.which == '13') &#123; alert('回车提交'); &#125; &#125;);&#125;); 切换复选框12345var tog = false;$('button').click(function() &#123; $("input[type=checkbox]").attr("checked",!tog); tog = !tog;&#125;); 使用 siblings() 来选择同辈元素123456789//不这样做$('#nav li').click(function()&#123; $('#nav li').removeClass('active'); $(this).addClass('active');&#125;);//替代做法是$('#nav li').click(function() &#123; $(this).addClass('active').siblings().removeClass('active');&#125;); 为任何与选择器相匹配的元素绑定事件123$("table").on("click","td",function()&#123; $(this).toggleClass("hover"); &#125;); $.proxy 的使用使用回调方法的缺点之一是当执行类库中的方法后，上下文对象被设置到另外一个元素，比如，执行下面代码：123456789101112131415161718192021222324252627&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style&gt; #panel &#123; width: 300px; height: 300px; background-color: #ccc; &#125; &lt;/style&gt; &lt;script src="jquery.js"&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;div id="panel" style="display:none"&gt; &lt;button&gt;Close&lt;/button&gt; &lt;/div&gt; &lt;script&gt; $('#panel').fadeIn(function()&#123; $('#panel button').click(function()&#123; $(this).fadeOut(); &#125;); &#125;); &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 你将遇到问题，button 元素会消失，而不是 panel 元素。可以使用 $.proxy 方法解决这个问题，代码如下：123456789101112131415161718192021222324252627&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style&gt; #panel &#123; width: 300px; height: 300px; background-color: #ccc; &#125; &lt;/style&gt; &lt;script src="jquery.js"&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;div id="panel" style="display:none"&gt; &lt;button&gt;Close&lt;/button&gt; &lt;/div&gt; &lt;script&gt; $('#panel').fadeIn(function()&#123; $('#panel button').click($.proxy(function()&#123; $(this).fadeOut(); &#125;,this)); &#125;); &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 这样才正确执行。 限制 Text-Area 域中的字符的个数12345678910111213141516171819202122232425262728293031323334353637&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;Document&lt;/title&gt; &lt;script src="jquery.js"&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;textarea id="mytextarea"&gt;&lt;/textarea&gt; &lt;script&gt; jQuery.fn.maxLength = function(max)&#123; this.each(function()&#123; var type = this.tagName.toLowerCase(); var inputType = this.type? this.type.toLowerCase() : null; if(type == "input" &amp;&amp; inputType == "text" || inputType == "password")&#123; //应用标准的maxLength this.maxLength = max; &#125;else if(type == "textarea")&#123; this.onkeypress = function(e)&#123; var ob = e || event; var keyCode = ob.keyCode; var hasSelection = document.selection? document.selection.createRange().text.length &gt; 0 : this.selectionStart != this.selectionEnd; return !(this.value.length &gt;= max &amp;&amp; (keyCode &gt; 50 || keyCode == 32 || keyCode == 0 || keyCode == 13) &amp;&amp; !ob.ctrlKey &amp;&amp; !ob.altKey &amp;&amp; !hasSelection); &#125;; this.onkeyup = function()&#123; if(this.value.length &gt; max)&#123; this.value = this.value.substring(0,max); &#125; &#125;; &#125; &#125;); &#125;; //use $('#mytextarea').maxLength(10); &lt;/script&gt; &lt;/body&gt;&lt;/html&gt; 解析 json 数据时报 parseError 错误jQuery 在 1.4 版本后，采用了更为严格的 json 解析方式，即所有内容都必须要有双引号，如果升级 jQuery 版本后，ajax 加载 json 报错，有可能就是这个原因。比如：12345// 1.4之前版本，key没引号，这样没问题&#123; key:"coco", status:"0"&#125; 但升级成jQuery1.4后，都必须加上双引号，格式如下：1234&#123; "key":"coco", "status":"0"&#125; 从元素中除去 HTML12345678910111213&lt;script&gt;(function($) &#123; $.fn.stripHtml = function() &#123; var regexp = /&lt;("[^"]*"|'[^']*'|[^'"&gt;])*&gt;/gi; this.each(function() &#123; $(this).html( $(this).html().replace(regexp,'') ); &#125;); return $(this); &#125; &#125;)(jQuery); //用法： $('div').stripHtml(); &lt;/script&gt; 扩展 String 对象的方法123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;Document&lt;/title&gt; &lt;script src="jquery.js"&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;div&gt; &lt;input type="text" /&gt;&lt;button &gt;check&lt;/button&gt; &lt;/div&gt; &lt;script&gt; $.extend(String.prototype, &#123; isPositiveInteger:function()&#123; return (new RegExp(/^[1-9]\d*$/).test(this)); &#125;, isInteger:function()&#123; return (new RegExp(/^\d+$/).test(this)); &#125;, isNumber: function(value, element) &#123; return (new RegExp(/^-?(?:\d+|\d&#123;1,3&#125;(?:,\d&#123;3&#125;)+)(?:\.\d+)?$/).test(this)); &#125;, trim:function()&#123; return this.replace(/(^\s*)|(\s*$)|\r|\n/g, ""); &#125;, trans:function() &#123; return this.replace(/&amp;lt;/g, '&lt;').replace(/&amp;gt;/g,'&gt;').replace(/&amp;quot;/g, '"'); &#125;, replaceAll:function(os, ns) &#123; return this.replace(new RegExp(os,"gm"),ns); &#125;, skipChar:function(ch) &#123; if (!this || this.length===0) &#123;return '';&#125; if (this.charAt(0)===ch) &#123;return this.substring(1).skipChar(ch);&#125; return this; &#125;, isValidPwd:function() &#123; return (new RegExp(/^([_]|[a-zA-Z0-9])&#123;6,32&#125;$/).test(this)); &#125;, isValidMail:function()&#123; return(new RegExp(/^\w+((-\w+)|(\.\w+))*\@[A-Za-z0-9]+((\.|-)[A-Za-z0-9]+)*\.[A-Za-z0-9]+$/).test(this.trim())); &#125;, isSpaces:function() &#123; for(var i=0; i&lt;this.length; i+=1) &#123; var ch = this.charAt(i); if (ch!=' '&amp;&amp; ch!="\n" &amp;&amp; ch!="\t" &amp;&amp; ch!="\r") &#123;return false;&#125; &#125; return true; &#125;, isPhone:function() &#123; return (new RegExp(/(^([0-9]&#123;3,4&#125;[-])?\d&#123;3,8&#125;(-\d&#123;1,6&#125;)?$)|(^\([0-9]&#123;3,4&#125;\)\d&#123;3,8&#125;(\(\d&#123;1,6&#125;\))?$)|(^\d&#123;3,8&#125;$)/).test(this)); &#125;, isUrl:function()&#123; return (new RegExp(/^[a-zA-z]+:\/\/([a-zA-Z0-9\-\.]+)([-\w .\/?%&amp;=:]*)$/).test(this)); &#125;, isExternalUrl:function()&#123; return this.isUrl() &amp;&amp; this.indexOf("://"+document.domain) == -1; &#125; &#125;); $("button").click(function()&#123; alert( $("input").val().isInteger() ); &#125;); &lt;/script&gt;&lt;/body&gt;&lt;/html&gt;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[中国国内 JavaScript 圈的现状如何]]></title>
      <url>%2F2016%2F11%2F18%2Fchina-javascript-environment%2F</url>
      <content type="text"><![CDATA[探讨核心： 我们不编写代码，我们只是国外优秀框架的搬运工。 现状么二五八万忙着造轮子步道小白忙着加群拜山头还有几个默默钻研又不为人知的浮躁，自我，没劲有天 leader 抽烟吹逼时候说：国内这些前端啊，多数靠的是名声，写点东西造个轮子，参加一下活动吹吹逼，建个群拉个山头搞一帮小弟，等公司挖了当上leader就算升天了国内 star 最多的没记错是NW吧，噢，人家是C艹分类下的玻璃心洗洗睡吧 只不过很多开发者停留在外来的和尚会念经阶段。如果很多老外都在用你的技术，国内的名博上写上一篇你的文章表扬一下，国内脑残粉扎堆严重。 放大些来看，不只前端，其他行业的观念也是如此。 另外，国内开源心态还不成熟，拿来主义倾向严重。遇到问题，你不帮 ta 解决问题你做的技术就是无用论的不在少数。使得很多开发人员认为做这样的开源简直就是做雷锋，没什么意义，所以很多牛人独善其身的不少。 认为开源的技术就是无 bug ，产品，是完美，否则你就不要开，这种扯蛋的心态的人也很多。 有个东西叫KPI的好吗，你成天在公司，不折腾点东西怎么算KPI，怎么分奖金?为了自身业务和KPI需求，在大点的公司，是肯定有自己的框架的,虽然往往里面充满了来自jquery啊prototypejs等等类库或者框架的几乎一样的代码，甚至在自身需求上还剪掉了一些通用方法，用开发者的话说，这个太臃肿了，我的简洁，然后慢慢的，功能加上来，文件也越来越大了，最后也都趋于跟其他已经使用广泛的类库或者框架一致… 在量的堆积下，国内的开源东西也凸显了不少好用的，比如fis、eccharts、sea、至于kissy之流咱就忽略吧，毕竟可能是自己的业务需求嘛，虽然文档写的好烂,领导升职了，后续也没人搞了…. 另外还有一个问题，国内很多框架什么的，核心就一个人，在工作繁忙的时候，bug也就没有精力去修复,框架能存在多久，是个问题…有时候在群里都有人宣传自己的框架的，说不定一两年后，人都转行了，之前的框架呢？会有人接手？悄无声息死掉的框架，大把的。 确实搬运了不少国外牛人的框架，但是我也要说一句吐槽的话【bug真特么的多，屁股还要自己擦】水平不够只有搬运，擦屁股才是个技术活。 国内其实是有不少在做框架开发或者库开发的，包括BAT新浪网易等等，只是这些框架多数主要围绕自身业务做的，在加上文档、封闭性等等原因其它公司不太适合去用。比如当年做的还不错的seajs，从前端的设计思路和实现上都很简洁明了，只是当时它们要支持自己的复杂业务搞了一套繁琐的路径配置逻辑结果就让人比较头疼了。 所以我觉得最重要的原因还是环境问题，没有包容、协作、共赢的生态环境人们的思维就会局限在谋求自身的利益，而不是整体价值的最大化。我倒是觉得做搬运工也没什么丢人的，只能说我们条件还不具备，能给出一些有用的反馈也算是有价值的事情了。 开源不分国界，私以为在这个时代还纠结于国内外，纠结于自主知识产权，纠结于国人当自强的都是莫名其妙的民族主义在作祟。 这不是民族主义，这是圈子问题。你的圈子里没有牛人能做出这些东西，这就是差距。国内圈子要是和湾区的交流跟加拿大人一样方便频繁肯定没人说这话。 我想问的是那些自己发明轮子的同行们，Backbone.js、AngularJS、jQuery、RequireJS、Bower、Grunt、Yomen 等等无数的开源框架和库以及整个开源社区组成的前端开发生态圈的各种免费解决方案们，到底无法解决工作当中的哪些实际问题，以至于要不停的重复发明轮子，而且还是方的轮子，难道只是为了秀肌肉？或者在各种场合做 talk？ 国内某圈子都是国外技术的搬运工不可怕，可怕的是几个高票答案里那股反智主义倾向。 有优秀的轮子为什么不拿来用？实际上这并不只是国内JS圈的情况，甚至不只是JS圈的情况，其实世界上大多数程序员都是优秀的搬运工啊XD。 谢邀。我工作中并不用js，所以对于js圈的话并不是很熟悉。题主说国内只是优秀库的搬运工，其实对于这句话我觉得应该客观对待，确实很多前端都是在使用国外的优秀库，比如boostrap等，但是会用与能用是两个不同的概念，会用意味着肯定是有pr的，会用的人水平也应该是肯定的。而且国内也有非常多的优秀js库，比如老赵的wind.js，淘宝的kissy等，再看诸如淘宝，腾讯，360等前端团队牛人泛多，他们是绝对有能力写出题主所定义的优秀库的，有能力会用而且会改造现有的优秀库其实力也不是一般的。所以对于是否是国外优秀库的搬运工，这里应该不存在绝对的定论，理性看待这个问题，至少鄙人非常乐观。 其实我刚入行的时候，真的很认真的去听所有国内的 talk，想听到他们为什么做这样的库、做那样的框架，而不是使用开源的解决方案，目前为止，没听到有说服力的理由。 很多答案都提到了国内的几个优秀开源库，当然前端圈子里面优秀的开源库很多，但目之所及，更多的是照猫画虎反类犬，至于哪些经典案例，我还是怕得罪同行的，就不说了。 我真的希望能和同行们一起做点别人没做过的库和框架，解决一些现在没人解决的问题，改善一下这种浮躁的风气。所以这个评价算是很中肯了，至少我会选择更务实的同事一起工作。 我匿名是怕得罪同行，毕竟还要混饭吃。但是替他们说话的人还匿名恐怕是中枪了吧？ Gulp 和 Grunt 用不同的方式解决同一个问题，并且各有千秋，但请别告诉我你们发明的轮子比人家的好用。没有人会反对创新和自主创造，反对的是用同一个姿势吃人家剩下的东西。 就算是同样的东西，你能说出 Bootstrap 和 GWSK 哪个更好吗，恐怕是同样好吧？但请别说 jQuery 和 XX 板，RequireJS 和 XXXJS 一样好用。你当然也可以反驳说如果不做永远都无法超越，那么首先请你做的至少和人家一样好了以后再到处去布道去秀，另外我始终不觉得超越是什么伟大到值得拿出来说的目的。作为一个工程师，我只想做出真正有用、用户喜欢的产品，对于我所用的框架到底是中国人开发的还是外国人开发的，对不起我不 care，如果你说这叫反智我只能呵呵了。 我对这么多答案中表现出来的对于浪费公司资源去做完全无意义的事情然后还到处去显摆并作为 promotion 资本这件事情表现出来的漠然感到震惊。 这个世界上从来都不缺想让世界变得更好的人，特别是工程师群体，但可惜的是出于某些邪恶目的而重复发明轮子的人也不少。我不否定国内有优秀的轮子，并且敬佩能做出好的开源项目的人，但我敬佩你不会是因为你有个「中国工程师」的定语。 要强调的的是国内前端圈子里面非常流行的「为了做而做，做的是完全一样的东西还没人家好，然后还到处去显摆」这种行为真的是令人恶心。 排名第一的答案的外链中有一句话：“我以前就一直说：我们离最先进的技术的差距只有半年。” 其实这已经很说明问题了，离最先进的技术有差距（不管是半年还是半个月），这说明国内做的东西不是原创的，而是在重复造轮子（有些有微创新，当然我相信也有原创的，但应该非常少） 比如 ueditor，国外都有那么强大的编辑器了，如果照着它都不能造一个轮子出来，那只能怀疑造轮子的人水平有问题。我记得 ueditor 团队还制作了个视频宣讲 ueditor，其中说到xxx还用了很nb的算法（二分查找），不知道的人还真以为是自己想出来的，回来一看 fckeditor，代码都几乎一模一样（当然 ueditor 本身是很不错的，比较符合国情）。 再说 SeaJS，CMD 是神马啊，它真的很C（ommon）吗？SeaJS 模块难道不是异步模块（AMD）吗？命名上就把人搞晕了。怎么解释还需要修改 jQuery 源代码的问题？jQuery 会来兼容 SeaJS 吗？你们知道有多少人兴致勃勃地用了 SeaJS 后最后又切换到 requierJS 吗？ 再说下，国内的技术人员不但不团结，还互相讥讽，我相信这一点玉伯深有体会。大家可以去看下 SeaJS 的源代码贡献者，除了玉伯你们都还认识谁？SeaJS 团队发布了 SPM 工具，遭受了多少的嘲笑啊！虽然 SPM 最为人诟病。 整天张口闭口说开源的那些人，怎么都觉得 SeaJS 已经很完美了？ 不是不用国内的东西，而是用过后觉得很失望，要文档没文档，说改就改不够稳定。并且据我所知，很多项目的核心开发就一个人，我能相信这东西靠谱吗？我可要为我整个公司负责啊，解决业务需求是我的首要目标，出了 bug 我可担当不起啊。 重复造轮子没问题，但你造个方的轮子或者和不符合国际标准的轮子还到处得瑟让你的同事或者业界朋友来用，你就是来捣乱的！ 语气重了点，希望大家见谅！ 中小公司缺乏强力统一的方向和规范，很多都只是搬运工，没有深入。大公司如bat之类的会有自己的体系，也是众多工程师的学习楷模。 原文]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Hexo-NexT搭建个人博客（三）]]></title>
      <url>%2F2016%2F11%2F11%2Fhexo-next-three%2F</url>
      <content type="text"><![CDATA[经过前面两期文章，我相信你已经可以在本地建立一个非常令人满意的静态博客了，本篇文章将介绍如何将自己的静态博客部署到 gitpage 上，并托管到 github 上；以及关于 Hexo 和 NexT 中更深层次的一些问题及解方案。 一、菜单栏中标签与侧边栏中标签关联的问题 以我的博客为例，关于菜单栏中的选项 与侧边栏中的选项，由于顶部菜单栏中位置有限，所以我就想在顶部菜单栏中不显示标签这一项，于是我在 主题配置文件 中 将 menu 配置项中的标签这一个选项给注释掉了，所以它不会在菜单栏中显示，但是不代表没有这个页面，这个页面是存在的，我们只是使其不显示在顶部的菜单栏中而已，我们可以直接输入绝对地址来查看这个页面，例如：https://neveryu.github.io/tags/。但是与此同时，我们发现侧边栏中的标签选项只能显示标签数量，不能点击。 这是因为侧边栏中的点击链接是根据菜单栏中对应的项来添加的，什么意思呢？就是说如果顶部菜单栏中有 标签 这一项，那么就会给侧边栏中标签这一项也添加点击链接；如果顶部菜单栏中没有标签这一项，那么就不给侧边栏中标签这一项添加点击链接，导致侧边栏中的标签项只有显示数据，不提供点击链接。 如果我们不想在菜单栏中显示标签项，但是希望侧边栏中的标签项 可以点击，该怎么做呢？ 在 主题配置文件 \themes\next\layout\_macro\sidebar.swing_ 中，将12345678&#123;% if site.tags.length &gt; 0 %&#125; &lt;div class="site-state-item site-state-tags"&gt; &#123;% if theme.menu.tags %&#125;&lt;a href="&#123;&#123; url_for(theme.menu.tags) &#125;&#125;"&gt;&#123;% endif %&#125; &lt;span class="site-state-item-count"&gt;&#123;&#123; site.tags.length &#125;&#125;&lt;/span&gt; &lt;span class="site-state-item-name"&gt;&#123;&#123; __('state.tags') &#125;&#125;&lt;/span&gt; &#123;% if theme.menu.tags %&#125;&lt;/a&gt;&#123;% endif %&#125; &lt;/div&gt;&#123;% endif %&#125; 改成：12345678&#123;% if site.tags.length &gt; 0 %&#125; &lt;div class="site-state-item site-state-tags"&gt; &lt;a href="&#123;&#123; url_for(theme.menu.tags) &#125;&#125;"&gt; &lt;span class="site-state-item-count"&gt;&#123;&#123; site.tags.length &#125;&#125;&lt;/span&gt; &lt;span class="site-state-item-name"&gt;&#123;&#123; __('state.tags') &#125;&#125;&lt;/span&gt; &lt;/a&gt; &lt;/div&gt;&#123;% endif %&#125; 同理，关于菜单栏中 归档 和 分类 的类似操作也是如此。 二、关于High一下中的音乐多次点击重叠播放的解决方案 在之前的 High一下 的播放音乐，如果多次点击的话，音乐会重复叠加播放，严重影响听歌体验，而且只能播放一首歌。 而现在的 High一下 已经解决了这个问题，而且可以列表循环多首歌曲。我将之前的那段播放音乐的代码换了。由于代码太长了，就不在这里贴出来了。大家可以去查看我的源码：https://github.com/Neveryu/Blog。关于播放音乐的代码是在： https://github.com/Neveryu/Blog/blob/master/themes/next/layout/_partials/header.swig 中的第 60 行开始。 需要说明的是：现在的 High一下 实现了歌曲列表循环，所以，我们可以放入多首歌的链接。在代码中以数组元素的形式加入歌曲链接。1234var songs = [ "http://v.65dj.com/wailian/84791c997d8c55023dad0d5690e48c28.mp3", "http://7xoiki.com1.z0.glb.clouddn.com/Music-sunburst.mp3"]; 三、关于github屏蔽vendors ，导致页面空白的解决方案关于 Github Pages 过滤掉了 source/vendors 目录的访问，导致加载 vendor 里面的文件全部 404 ，页面大面积空白。1.在根目录添加 .nojekyll 文件。2.也可以手动将 source/vendors 目录修改成 source/lib 同时，修改主题配置文件 _config.yml ，将 _internal: vendors 改成你所修改的名字，例如 _internal: lib 。 四、关于如何获取自己的多说userid首先进入自己的帐号管理页面，点击左上自己的名字此时地址栏后面的一串数字就是你的多说 userid。 五、关于如何修改内容区域宽度Next 对内容的宽度的设定如下： 700px，当屏幕宽度 &lt; 1600px 900px，当屏幕宽度 &gt;= 1600px 移动设备下，宽度自适应 如果你需要修改内容的宽度，同样需要编辑样式文件。编辑主题的 source\css_variables\custom.styl 文件，新增变量：12345// 修改成你期望的宽度$content-desktop = 700px// 当视窗超过 1600px 后的宽度$content-desktop-large = 900px 此方法不适用于 Pisces Scheme ， Pisces Scheme 编辑 themes\next\source\css\_schemes\Picses\_layout.styl 文件，更改以下 css 选项定义值：123.header &#123;width: 1150px;&#125;.container .main-inner &#123;width: 1150px;&#125;.content-wrap &#123;width: calc(100% - 260px);&#125; 六、图片模式新建博文，设置 type: &quot;picture&quot; ，使用 {\% gp x-x \%}...{\% endgp \%} 标签引用要展示的图片地址，如下所示：1234567891011121314---title: Naruto-Picturescategories: [picture]tags: [picture,naruto]date: 2016-11-02 14:36:04type: "picture"---&#123;% gp 5-3 %&#125;![](http://oapjp6spr.bkt.clouddn.com/18210.jpg)![](http://oapjp6spr.bkt.clouddn.com/196232.jpg)![](http://oapjp6spr.bkt.clouddn.com/224147.jpg)![](http://oapjp6spr.bkt.clouddn.com/199301.jpg)![](http://oapjp6spr.bkt.clouddn.com/213318.jpg)&#123;% endgp %&#125; 图片展示效果 {\% gp 5-3 \%}：设置图片展示效果，参考 themes\next\scripts\tags\group-pictures.js 注释示意图。5-3 的意思就是5张图片将会按照这种布局来展示，Next 提供了多张图片的多种布局，你可以随意选择。 最后要说的是： 博客源码]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Sass入门教程]]></title>
      <url>%2F2016%2F10%2F23%2Fsass%2F</url>
      <content type="text"><![CDATA[Sass： (Syntactically Awesome StyleSheets) sass简介来自于官网的简介：Sass is the most mature, stable, and powerful professional grade CSS extension language in the world. Sass 是世界上最成熟的，稳定的，功能强大的专业级 CSS 扩展语言。 sass 安装因为 sass 依赖 ruby 环境，所以装 sass 之前先确认安装了 ruby .在安装的时候，请勾选 Add Ruby executables to your PATH 这个选项，添加环境变量，不然以后使用编译软件的时候会提示找不到 ruby 环境. 安装完 ruby 之后，在开始菜单中，打开我们的命令行，输入ruby -v 那么我们的ruby就安装成功了。 然后直接在命令行中输入gem install sass按回车键确认，等待一段时间就会提示你 sass 安装成功。 如果要安装 beta 版本的，可以在命令行中输入gem install sass --pre 最近因为墙的比较厉害，如果你没有安装成功，那么请参考下面的淘宝的 RubyGems 镜像安装 sass ，如果成功则忽略。由于国内网络原因（你懂的），导致 rubygems.org 存放在 Amazon S3 上面的资源文件间歇性连接失败。这时候我们可以通过 gem sources 命令来配置源，先移除默认的 https://rubygems.org 源，然后添加淘宝的源 https://ruby.taobao.org/ ，然后查看下当前使用的源是哪个，如果是淘宝的，则表示可以输入 sass 安装命令 gem install sass 了. 123gem sources --remove https://rubygems.org/gem sources -a https://ruby.taobao.org/gem sources -l 如果输出：12*** CURRENT SOURCES ***https://ruby.taobao.org 则表示镜像替换成功，下一步1gem install sass 按回车键确认，等待一段时间就会提示你sass安装成功。 如果你熟悉git命令的话，你还可以从sass的Git repository来安装，git的命令行为123git clone git://github.com/nex3/sass.gitcd sassrake install 升级 sass 版本的命令行为我们可以使用命令 gem update sass 来升级我们的 sass 版本。 如果想要安装sass的某一特定版本，命令行为gem install sass --version=3.3.0 如果想要删除sass的某一特定版本，命令行为gem uninstall sass --version=3.3.0 卸载sass,命令行为gem uninstall sass 查看sass版本的命令行为sass -v 查看ruby安装的所有程序包，命令语句为 gem list 。 sass 命令单文件转换命令sass style.scss style.css 单文件监听命令sass --watch style.scss:style.css 文件夹监听命令sass --watch sassFileDirectory:cssFileDirectory css文件转成sass/scss文件12sass-convert style.css style.sasssass-convert style.css style.scss sass语法变量sass 的变量必须是 $ 开头，后面紧跟变量名，而变量值和变量名之间就需要使用冒号(：)分隔开（就像 CSS 属性设置一样），如果值后面加上 !default 则表示默认值。普通变量定义之后可以在全局范围内使用。 1234$fontSize: 12px;body &#123; font-size: $fontSize;&#125; 默认变量sass 的默认变量仅需要在值后面加上 !default 即可。 1234$baseLineHeight: 1.5 !default;body &#123; line-height: $baseLineHeight;&#125; sass 的默认变量一般是用来设置默认值，然后根据需求来覆盖的。1234567$baseLineHeight: 1.5 !default;body &#123; line-height: 2;&#125;p &#123; line-height: $baseLineHeight;&#125; 特殊变量一般我们定义的变量都为属性值，可直接使用，但是如果变量作为属性或在某些特殊情况下等则必须要以 #{$variables} 形式使用。123456789101112$borderDirection: top !default;$baseFontSize: 12px !default;$baseLineHeight: 1.5 !default;//应用于 class 和属性.border-#&#123;$borderDirection&#125; &#123; border-#&#123;$borderDirection&#125;: 1px solid #ccc;&#125;//应用于复杂的属性值body &#123; font:#&#123;$baseFontSize&#125;/#&#123;$baseLineHeight&#125;;&#125; 多值变量多值变量分为 list 类型和 map 类型，简单来说 list 类型有点像 js 中的数组，而 map 类型有点像 js 中的对象。 listlist 数据可通过空格，逗号或小括号分隔多个值，可用 nth($var,$index) 取值。关于 list 数据操作还有很多其他函数如 length($list) ， join($list,$list2,[$separator]) ， append($list,$value,[$separator]) 等。具体可参考sass Functions（搜索List Functions即可）定义12345//一维数组$px: 5px 10px 20px 30px;//二维数组$px: 5px 10px, 20px 30px;$px: (5px 10px) (20px 30px); demo ： 1234567$linkColor: #08c #333 !default;a &#123; color: nth($linkColor,1); &amp;:hover &#123; color: nth($likColor,2); &#125;&#125; mapmap 数据以 ke y和 value 成对出现，其中 value 又可以是 list 。格式为： $map:(key1: value1,key2:value2,key3:value3); 。可通过 map-get($map,$key) 取值。关于map数据还有很多其他函数如 map-merge($map1,$map2) ， map-keys($map) ， map-values($map) 等。123456$headings: (h1: 2em, h2: 1.5em, h3: 1.2em);@each $header,$size in $headings &#123; #&#123;$header&#125; &#123; font-size: $size; &#125;&#125; 全局变量在变量值后面加上 !global 即为全局变量。在选择器中声明的变量会覆盖外面全局声明的变量。12345678$fontSize: 12px;body &#123; $fontSize: 14px; font-size: $fontSize;&#125;p &#123; font-size: $fontSize;&#125; 启用global之后的机制 12345678$fontSize: 12px;body &#123; $fontSize: 14px !global; font-size: $fontSize;&#125;p &#123; font-size: $fontSize;&#125; 与上面的机制对比就会发现默认在选择器里面的变量为局部变量，而只有设置了!global之后才会成为全局变量。 嵌套(Nesting)sass的嵌套包括两种：一种是选择器的嵌套；另一种是属性的嵌套。 选择器嵌套所谓选择器嵌套指的是在一个选择器中嵌套另一个选择器来实现继承，从而增强了sass文件的结构性和可读性。在选择器嵌套中，可以使用 &amp; 表示父元素选择器 1234567891011121314151617#top_nav &#123; line-height: 30px; text-transform: capitalize; background-color: #333; li &#123; display: block; &#125; a &#123; display: block; padding: 0 10px; color: #fff; &amp;:hover &#123; color: #ddd; &#125; &#125;&#125; 属性嵌套所谓属性嵌套指的是有些属性拥有同一个开始单词，如border-width，border-color都是以border开头。12345678910111213.fakeshadow &#123; border: &#123; style: solid; left: &#123; width: 4px; color: #888; &#125; right: &#123; width: 2px; color: #ccc; &#125; &#125;&#125; 当然这个只是属性嵌套的一个例子，在实际中这样来写 border 的样式或许有些复杂了，但在属性嵌套在别的地方肯定用得到。 @at-root@at-root 用来跳出选择器嵌套的。默认所有的嵌套，继承所有上级选择器，但有了这个就可以跳出所有上级选择器。 普通跳出嵌套1234567891011121314151617181920212223242526272829/*没有跳出*/.parent-1 &#123; color: #f00; .child &#123; width: 100px &#125;&#125;/*单个选择器跳出*/.parent-2 &#123; color: #f00; @at-root .child &#123; width: 200px; &#125;&#125;/*多个选择器跳出*/.parent-3 &#123; background: #f00; @at-root &#123; .child1 &#123; width: 300px; &#125; .child2 &#123; width: 400px; &#125; &#125;&#125; @at-root(without:…)和@at-root(with:…)默认 @at-root 只会跳出选择器嵌套，而不能跳出 @media 或 @support ，如果要跳出这两种，则需要使用 @at-root(without:media) ，@at-root(without:support) 。这个语法的关键词有四个： all （表示所有），true（表示常规CSS）， media（表示media）， ‘support’（表示support，因为 @support 目前还无法广泛使用）。我们默认的 @at-root 其实就是 @at-root(without:rule) 。123456789101112131415161718192021222324252627282930@media print &#123; .parent1 &#123; color: #000; @at-root .child1 &#123; width: 200px &#125; &#125;&#125;//跳出media嵌套，父级有效@media print &#123; .parent2 &#123; color: #f00; @at-root (without:media) &#123; .child2 &#123; widht: 200px &#125; &#125; &#125;&#125;//跳出media和父级@media print &#123; .parent3 &#123; color: #f00; @at-root (without:all) &#123; .child3 &#123; width: 200px; &#125; &#125; &#125;&#125; @at-root 与 &amp; 配合使用12345.child &#123; @at-root .parent &amp; &#123; color: #f00; &#125;&#125; 应用于@keyframe123456789.demo &#123; ... animation: motion 3s infinite; @at-root &#123; @keyframes motion &#123; ... &#125; &#125;&#125; 混合(mixin)sass 中使用 @mixin 声明混合，可以传递参数，参数名以 $ 符号开始，多个参数以逗号分开，也可以给参数设置默认值，声明的 @mixin 通过 @include 来调用。 无参数mixin123456789@mixin center-block &#123; margin: &#123; left: auto; right: auto; &#125;&#125;.demo &#123; @include center-block;&#125; 有参数mixin1234@mixin opacity($opacity: 50) &#123; opacity: $opacity / 100; filter: alpha(opacity=$opacity);&#125; 多个参数mixin调用时可直接传入值，如 @include 传入参数的个数小于 @mixin 定义参数的个数，则按照顺表示，后面不足的使用默认值，如不足的没有默认值则报错。除此之外还可以选择性的传入参数，使用参数名与值同时传入。1234567891011@mixin horizontal-line($border:1px dashed #ccc,$padding:10px) &#123; border-bottom: $border; padding-top: $padding; padding-bottom: $padding;&#125;.imgtext-h li &#123; @include horizontal-line(1px solid #ccc);&#125;.imgtext-h-product li &#123; @include horizontal-line($padding:15px);&#125; 多组值参数mixin如果一个参数可以有多组值，如 box-shadow 、transition 等，那么参数则需要在变量后加三个点表示，如 $variables... 。123456789//box-shadow可以有多组值，所以在变量参数后面添加...@mixin box-shadow($shadow...) &#123; -webkit-box-shadow: $shadow; box-shadow: $shadow;&#125;.box &#123; border: 1px solid #ccc; @include box-shadow (0 2px 2px rgba(0,0,0,.3),0 3px 3px rgba(0,0,0,.3),0 4px 4px rgba(0,0,0,.3));&#125; @content@content 可以用来解决 css3 的 @media 等带来的问题。它可以使 @mixin 接受一整块样式，接受的样式从 @content 开始。12345678910@mixin max-screen($res) &#123; @media only screen and (max-width:$res) &#123; @content; &#125;&#125;@include max-screen(480px) &#123; body &#123; color: red; &#125;&#125; PS：@mixin 通过 @include 调用后解析出来的样式是以拷贝形式存在的，而下面的继承则是以联合声明的方式存在的，所以从 3.2.0 版本以后，建议传递参数的用 @mixin ，而非传递参数的使用下面的继承 % 。 继承sass 中，选择器继承可以让选择器继承另一个选择器的所有样式，并联合声明。使用选择器的继承，要使用关键词 @extend ，后面紧跟需要继承的选择器。1234567h1 &#123; border: 4px solid #ff9aa9;&#125;.speaker &#123; @extend h1; border-width: 2px;&#125; 继承的工作细节关于 @extend 有两个要点你应该知道。 跟混合器相比，继承生成的 css 代码相对更少。因为继承仅仅是重复选择器，而不会重复属性，所以使用继承往往比混合器生成的 css 体积更小。如果你非常关心你站点的速度，请牢记这一点。举个例子,使用混合器的时候：1234567891011@mixin border-colors &#123; width: 200px; height: 200px; border: 1px solid #333;&#125;.demo1 &#123; @include border-colors;&#125;.demo2 &#123; @include border-colors; &#125; 它生成的 css 如下：12345678910.demo1 &#123; width: 200px; height: 200px; border: 1px solid #333;&#125;.demo2 &#123; width: 200px; height: 200px; border: 1px solid #333;&#125; 使用继承的时候：12345678.demo1 &#123; width: 200px; height: 200px; border: 1px solid #333;&#125;.demo2 &#123; @extend .demo1; &#125; 它生成的 css 如下：12345.demo1, .demo2 &#123; width: 200px; height: 200px; border: 1px solid #333;&#125; 可以看到，继承仅仅是重复选择器，而不会重复属性，所以使用继承往往比混合器生成的 css 体积更小。 继承遵从 css 层叠的规则。当两个不同的 css 规则应用到同一个 html 元素上时，并且这两个不同的 css 规则对同一属性的修饰存在不同的值， css 层叠规则会决定应用哪个样式。相当直观：通常权重更高的选择器胜出，如果权重相同，定义在后边的规则胜出。 混合器本身不会引起 css 层叠的问题，因为混合器把样式直接放到了 css 规则中，而继承存在样式层叠的问题。被继承的样式会保持原有定义位置和选择器权重不变。通常来说这并不会引起什么问题，但是知道这点总没有坏处。 使用继承的最佳实践通常使用继承会让你的 css 美观、整洁。因为继承只会在生成 css 时复制选择器，而不会复制大段的 css 属性。但是如果你不小心，可能会让生成的 css 中包含大量的选择器复制。避免这种情况出现的最好方法就是不要在 css 规则中使用后代选择器（比如 .foo .bar）去继承 css 规则。如果你这么做，同时被继承的 css 规则有通过后代选择器修饰的样式，生成 css 中的选择器的数量很快就会失控。例如：123456.bip .baz &#123; color: red;&#125;.foo .bar &#123; @extend .baz;&#125; 生成的css如下：123.bip .baz, .bip .foo .bar, .foo .bip .bar &#123; color: red;&#125; 所以如果允许，尽可能避免这种用法。 值得一提的是，只要你想，你完全可以放心地继承有后代选择器修饰规则的选择器，不管后代选择器多长，但有一个前提就是，不要用后代选择器去继承。 占位选择器 %从 sass 3.2.0 以后就可以定义占位选择器 % 。这种选择器的优势在于：如果不调用则不会有任何多余的css文件，避免了以前在一些基础的文件中预定义了很多基础的样式，然后实际应用中不管是否使用了 @extend 去继承相应的样式，都会解析出来所有的样式。占位选择器以 % 标识定义，通过 @extend 调用。1234567891011121314151617181920212223242526272829%ir &#123; color: transparent; text-shadow: none; background-color: transparent; border: 0;&#125;$lte7:true !default;%clearfix &#123; @if $lte7 &#123; *zoom: 1; &#125; &amp;:before,&amp;:after &#123; content: ''; display: table; font: 0/0; &#125; &amp;:after &#123; clear: both; &#125;&#125;#header &#123; h1 &#123; @extend %ir; width: 300px &#125;&#125;.ir &#123; @extend %ir;&#125; 如上代码，定义了两个占位选择器 %ir 和 %clearfix ，其中 %clearfix 这个没有调用，所以解析出来的css样式也就没有clearfix部分。占位选择器的出现，使css文件更加简练可控，没有多余。所以可以用其定义一些基础的样式文件，然后根据需要调用产生相应的css。ps:在 @media 中暂时不能 @extend @media 外的代码片段，以后将会可以。 函数sass 定义了很多函数可供使用，当然你也可以自己定义函数，以@function开始。sass 的官方函数链接为：sass function ，实际项目中我们使用最多的应该是颜色函数，而颜色函数中又以 lighten 减淡和 darken 加深使用最多，其调用方法为 lighten($color,$amout) 和 darken($color,$amount) ，它们的第一个参数都是颜色值，第二个参数都是百分比。1234567891011121314$baseFontSize: 10px !default;$gray: #ccc !default;@function pxToRem($px) &#123; @return $px / $baseFontSize * 1rem;&#125;body &#123; font-size: $baseFontSize; color: lighten($gray,10%);&#125;.test &#123; font-size: pxToRem(16px); color: darken($gray,10%);&#125; 关于 @mixin ，% ，@function 更多说明可参阅：sass文档 运算sass 具有运算的特性，可以对数值型的Value（如：数字、颜色、变量等）进行加减乘除四则运算。请注意运算前后请留一个空格，不然会出错。123456$baseFontSize: 14px !default;$baseLineHeight: 1.5 !default;$baseGap: $baseFontSize * $baseLineHeight !default;.balber &#123; font-size: $baseGap; //21px&#125; 条件判断及循环@if判断@if 可一个条件单独使用，也可以和 @else 结合多条件使用。1234567891011121314151617181920$lte7: true;$type: monster;.ib&#123; display:inline-block; @if $lte7 &#123; *display:inline; *zoom:1; &#125;&#125;p &#123; @if $type == ocean &#123; color: blue; &#125; @else if $type == matador &#123; color: red; &#125; @else if $type == monster &#123; color: green; &#125; @else &#123; color: black; &#125;&#125; 生成的 css 如下：12345678.ib &#123; display: inline-block; *display: inline; *zoom: 1;&#125;p &#123; color: green;&#125; 三目判断语法为：if($condition,$if_true,$if_false)。三个参数分别表示：条件，条件为真的值，条件为假的值。12if(true,1px,2px) =&gt; 1pxif(false,1px,2px) =&gt; 2px for循环for 循环有两种形式，分别为：@for $var from &lt;start&gt; through &lt;end&gt; 和 @for $var from &lt;start&gt; to &lt;end&gt; 。$i 表示变量，start 表示起始值，end 表示结束值，这两个的区别是关键字 through 表示包括 end 这个数，而 to 则不包括 end 这个数。12345678910@for $i from 1 through 3 &#123; .item-#&#123;$i&#125; &#123; width: 2em * $i; &#125;&#125;@for $i from 5 to 7 &#123; .item-#&#123;$i&#125; &#123; width: 2em * $i; &#125;&#125; each循环语法为：@each $var in &lt;list or map&gt; 。其中 $var 表示变量，而 list 和 map 表示 list 类型数据和 map 类型数据。sass 3.3.0新加入了多字段循环和map数据循环。 单个字段 list 数据循环123456$animal-list: puma, sea-slug, egret, salamander;@each $animal in $animal-list &#123; .#&#123;$animal&#125;-icon &#123; background-image: url('/images/#&#123;$animal&#125;.png'); &#125;&#125; 多个字段 list 数据循环12345678$animal-data: (puma, black, default),(sea-slug, blue, pointer),(egret, white, move);@each $animal, $color, $cursor in $animal-data &#123; .#&#123;$animal&#125;-icon &#123; background-image: url('/images/#&#123;$animal&#125;.png'); border: 2px solid $color; cursor: $cursor; &#125;&#125; 多个字段 map 数据循环123456$headings: (h1: 2em, h2: 1.5em, h3: 1.2em);@each $header, $size in $headings &#123; #&#123;$header&#125; &#123; font-size: $size; &#125;&#125; 小结本文介绍了 sass 最基本部分,你可以轻松地使用 sass 编写清晰、无冗余、语义化的 css 。对于 sass 提供的工具你已经有了一个比较深入的了解，同时也掌握了何时使用这些工具的指导原则。 变量是 sass 提供的最基本的工具。通过变量可以让独立的 css 值变得可重用，无论是在一条单独的规则范围内还是在整个样式表中。变量、混合器的命名甚至 sass 的文件名，可以互换通用 _ 和 - 。同样基础的是 sass 的嵌套机制。嵌套允许 css 规则内嵌套 css 规则，减少重复编写常用的选择器，同时让样式表的结构一眼望去更加清晰。sass 同时提供了特殊的父选择器标识符 &amp; ，通过它可以构造出更高效的嵌套。 你也已经学到了 sass 的另一个重要特性，样式导入。通过样式导入可以把分散在多个 sass 文件中的内容合并生成到一个 css 文件，避免了项目中有大量的 css 文件通过原生的 css @import 带来的性能问题。通过嵌套导入和默认变量值，导入可以构建更强有力的、可定制的样式。混合器允许用户编写语义化样式的同时避免视觉层面上样式的重复。你不仅学到了如何使用混合器减少重复，同时学习到了如何使用混合器让你的 css 变得更加可维护和语义化。最后，我们学习了与混合器相辅相成的选择器继承。继承允许你声明类之间语义化的关系，通过这些关系可以保持你的 css 的整洁和可维护性。 sass文档sass函数列表]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[【转】在2016年学JavaScript是一种什么样的体验]]></title>
      <url>%2F2016%2F10%2F16%2Fhow-it-feels-to-learn-javascript-in-2016%2F</url>
      <content type="text"><![CDATA[嘿，我最近接到一个 Web 项目，不过老实说，我这两年没怎么接触 Web 编程，听说 Web 技术已经发生了一些变化。听说你是这里对新技术最了解的 Web 开发工程师？ 准确地说，我是一名「前端工程师」。不过你算是找对人了。我对今年的技术别提多熟了，前端可视化、音乐播放器、能踢足球的无人机，你尽管问吧。我刚去 JS 大会和 React 大会逛了一圈，没有什么新技术是我不知道的。 厉害。是这样的，我要开发一个网页，用来展示用户的最新动态。我想我应该通过后端接口获取数据，然后用一个 table 来展示数据，用户可以对数据进行排序。如果服务器上的数据变化了，我还需要更新这个 table。我的思路是用 jQuery 来做。 可别用 jQuery！现在哪还有人用 jQuery。现在是 2016 年了，你绝对应该用 React。 哦，好吧，React 是什么？ React 是一个非常厉害的库，Facebook 的牛人写的。它能让页面更可控，性能极高，而且使用起来很简单。 听起来确实不错。我能用 React 展示服务器传来的数据吗？ 当然可以，你只需要添加两个依赖，一个是 React，一个是 React DOM 额，等下，为什么是两个库？ React 是我说的库，React DOM 是用来操作 DOM 的。因为这些 DOM 是用 JSX 写的，所以需要一个专门的库来操作。 JSX？JSX 是什么？ JSX 是对 JS 的扩展，它看起来跟 XML 差不多，可以用来写 HTML，你可以认为 JSX 是一种更优雅的 HTML 写法。 为什么不用 HTML 了……？ 现在可是 2016 年啊，没有直接写 HTML 的。 对哦。好吧，加了这两个依赖，是不是就可以开始用 React 了？ 不行哦。你需要添加 Babel，然后才能用 React。 Babel 是另一个库？ 嗯，Babel 是一个转译工具，Babel 能把你写的 JS 转译成任意版本的 JS。你不一定非要用 Babel，但是如果你不用的话，你就只能写 ES5 的语法了。你知道的，现在是 2016 年，你怎么能不使用 ES2016+ 的语法呢？ES2016+ 多么酷啊。 ES5 是啥？ES2016+ 又是啥？我有点晕。 ES5 就是 ECMAScript 5。大部分人都会使用 ES5，因为大部分浏览器都支持 ES5。 ECMAScript 是啥…… 你晓得的，JS是1995年诞生的，而JS的标准是1999制定出来的。那时候 JavaScript 还叫做 Livescript，只能运行在网景的浏览器里。那时真是混乱的年代，现在好了，我们有了 JS 的 7 个版本的规范。 7 个版本？那 ES5 和 ES2016+ 是？ 分别是第 5 个版本和第 7 个版本。 诶，那第六个版本呢？ 你说的是 ES6。每个版本都是上一个版本的超集，所以你直接使用最新的 ES2016+ 就好了。 对哦。为什么不用 ES6 呢？ 好吧，你可以用 ES6，但是你就用不到 async 和 await 这么酷的语法了。用 ES2016+ 比较好。用 ES6 的话你就只能用 generator 来控制异步任务流了。 不知道你在说什么……你说了太多我听不懂的名词了。我只是想从服务器取点数据，我以前用 jQuery 挺好的，从 CDN 引入 jQuery，我就能用 AJAX 获取数据了，现在不能这样做吗？ 大哥，都 2016 年了，没人用 jQuery 好吗。所有人都知道用 jQuery 只会造出「意大利面条」一样的代码（不可维护） 好吧，所以我现在要加载三个库才能获取并展示数据。 对的，其实你可以用「模块管理器」把这三个库「打包」成一个文件。 哦，什么是模块管理器…… 不同平台的模块管理器不同啦。前端的模块管理器一般指管理 AMD 或者 CommonJS 模块的东西。 好……吧，什么是 AMD 和 CommonJS？ 是两个定义。我们有很多方式来描述 JS 中多个库或类的交互方式，比如 exports 和 requires。你可以按照 AMD 或者 CommonJS 的 API 来书写 JS，然后用 Browserify 将它们打包。 听起来很有道理。不过，什么是 Browserify？ 是一个工具，用来将 CommonJS 形式的 JS 文件打包起来，放到浏览器里运行。用 npm 仓库的人发明了 CommonJS。 npm 仓库是什么…… 是一个公开的仓库，用于放置可依赖的模块。 就像一个 CDN 么？ 不太一样。它更像是一个数据库，每个人都能在上面发布代码，也能下载上面的代码。你可以在开发的时候将这些代码下载到本地来使用，必要的时候也能上传到 CDN。 听起来像是 Bower！ 是的，不过现在是 2016 年了，没有人用 Bower 了…… 好吧，我知道了，所以我应该用 npm 来安装依赖。 对的。我举个例子吧，如果你要使用 React，你直接用 npm 安装 React，然后在代码里导入 React 就可以了。大部分 JS 库都能这么安装。 嗯，Angular 也可以。 Angular 是 2015 年的事情了。不过今年 Angular 还没死，还有 VueJS 和 RxJS 等等，你想学一学么？ 还是用 React 吧。我刚才已经学了够多东西了。所以我用 npm 安装 React 然后用 Browerify 来打包就好了？ 是的。 这么做看起来有点过于复杂啊。 确实。这就是为什么你应该使用 Grunt、Gulp 或者 Broccoli 这样的任务管理工具，它们能自动运行 Browserify。不对，你现在可以用 Mimosa。 你在说什么…… 任务管理工具。不过我们现在已经不用了。去年我们还在用，后来改成了 Makefiles，但是现在我们用的都是 Webpack。 我以为只有 C/C++ 项目才会用 Makefiles。 是的，不过显然我们做 Web 开发的，喜欢先把事情搞复杂，然后回归到最朴素的状态。每年我们都是这么搞的。你就看着吧，过不了两年，我们就可以在网页上写汇编了。 唉，你刚才说的 Webpack 是什么？ 另一种模块管理工具，同时也是一个任务管理工具。你可以认为它是 Browserify 的加强版。 哦，好吧，为什么 Webpack 是加强版？ 额，可能并没有加强吧。Webpack 告诉你应该如何管理你的依赖，Webpack 允许你使用不同的模块管理器，不只是 CommonJS，甚至支持 ES6 模块。 这都是哪跟哪啊，我都被绕晕了。 大家都被绕晕了，不过等 SystemJS 出来了就好了。 天呐，又一个 JS 库，这是什么鬼？ 呵呵，不像 Browserify 和 Webpack 1.x，SystemJS 是一个动态的模块加载器。 等下，刚才不是说应该把所有依赖打包成一个文件吗？ 话是这么说，但是等 HTTP/2 普及之后，不打包反而更好。 那为什么我们不直接在页面里添加 React 的三个依赖文件呢？ 不行。你可以从 CDN 加载这些文件，但是你还是要在本地用 Babel 转译。 唉，这么鹾？ 是的，你不能在生产环境上运行 babel，你应该在发布到生产环境之前，运行一系列的任务，包括压缩、混淆、内联化CSS、延迟加载script…… 我懂了我懂了。既然我不能直接用 CDN，那么我应该怎么做？ 我会考虑用 Webpack + SystemJS + Babel 来转译 Typescript。 Typescript？我们不是在说 JavaScript 吗？！ Typescript 也是 JavaScript 呀，它比 JS 更好用，是 JS 的超集，它是基于 ES6 的，就是我们刚才谈论的 ES6，你还记得吧。 ES2016+ 已经是 ES6 的超集了，怎么又冒出来一个 Typescript？ 是这样的，Typescript 能让我们写出「强类型」的 JS，从而减少运行时的错误。2016年，我们应该让 JS 支持强类型了。 显然 Typescript 可以做到。 Flow 也可以做到，区别是 Typescript 需要编译，而 Flow 只是检查语法。 唉，Flow 是？ 是一个静态类型检查器，就是 Facebook 的人写的。使用 OCaml 写的，函数式编程很叼的。 OCaml？函数式编程？ 如今大牛都用这些东西，都2016年了，你懂的，函数式编程、高阶函数、柯里化、纯函数这些概念。 不知道你在说什么。 一开始大家都不知道。这么说吧，你只需要知道函数式编程比面向对象编程厉害，2016 年我们就指着函数式编程了。 等下，我大学里学过面向对象编程，当时我觉得它还不错。 Java 在被 Oracle 买下来之前也挺不错啊。我的意思是，面向对象以前是不错，现在依然有人用它，但是现在所有人都发觉状态变换是很难维护的，所以大家都开始用「不可变对象」和函数式编程了。Haskell 的人已经用这套东西用了很久了，不过幸运的是 Web 开发领域里有 Ramda 这样的库，让我们用 JS 就可以进行函数式编程了。 你刚刚是不是又抛出了几个名词？Ramnda 又是什么？ 不是 Ramnda，是 Ramda，跟 Lambda 表达式有点像。是 David Chambers 写的库。 谁？ David Chambers，大神一个。blablabla 我不得不打断你一下了。这些东西看起来都不错，但是我觉得它们都太复杂，而且没必要。我只是想获取数据然后展示，我很确定这种情况下我不需要掌握这些知识。 回到 React 吧，用 React 我怎么从服务器获取数据？ 额，React 没有提供这个功能，你只能用 React 展示数据。 服了啊。那我怎么获取数据？ 你用 Fetch API 就可以了。 啥玩意？这个 API 的名字很烂啊。 我也觉得是啊。Fetch API 是浏览器提供的异步请求接口。 哦，那不就是 AJAX。 AJAX 只是使用 XMLHttpRequest 对象，但是 Fetch API 可以让你用 Promise 风格来发起异步请求，帮你摆脱「回调地狱」。 回调地狱？ 是的，每次你发起一个异步请求，就得等待它响应。这时你就得在函数里使用一个函数，这种嵌套调用就是回调地狱。 好吧。Promise 解决了这个问题么？ 是的。用 Promise 来管理回调，你就可以写出更易读的代码，更容易测试的代码。甚至可以同时发起多个请求，然后等待它们全部返回。 Fetch 也能做到吗？ 是的。但前提是你的用户使用了新版的浏览器，不然的话你就需要加一个 Fetch 的 「polyfill」，或者使用 Request、Bluebird 或者 Axios 这些库。 天呐我到底需要多少个库？ 这是 JS，同一件事情有上千个库在做。我们了解库，而且我们有最好的库，我们有海量的库，要什么有什么。 你刚才说的几个库都是干什么的？ 这几个库操作 XMLHttpRequest 然后返回 Promise 对象。 好像 jQuery 的 ajax 方法做的是同样的事吧…… 从 2016 年起我们就不用 jQuery 了。用 Fetch，大不了加个 Polyfill，要不然用 Bluebird、Request 或者 Axios 都行。然后用 await 和 async 管理 Promise，这样才能控制好异步任务。 这是你第三次说 await 了，那是什么东西？ await 能让你拦住一个异步调用，让你更好地控制异步返回的数据，大大增强了代码的可读性。await 非常好用，你只需要在 Babel 里添加 stage–3 配置，或者添加 syntax-async-functions 和 transform-async-to-generator 插件就可以了。 听起来像是疯了。 没疯。为了使用 await，把 Typescript 编译之后再用 Babel 转译一道的人才是疯了。 啥玩意？Typescript 不支持 await？ 下个版本就支持了。 我已经无话可说了。 你看其实很简单。用 Typescript 写代码，用 Fetch 发起异步请求，所有代码编译成 ES6，然后用上 Babel 的 stage–3 配置项，把 ES6 转译成 ES5。所有代码用 SystemJS 加载。如果你用不了 Fetch，就加个 polyfill，或者用 Bluebird、Request 或者 Axios，这样你就可以用 await 来处理 Promise 了。 看来我们俩对于「简单」的理解是不同的。好吧，有了这些，我终于可以获取数据然后用 React 展示数据了，对吧？ 你的网页需要处理状态变更吗？ 唔，不用吧。我只是想展示数据。 那就好，不然我就得跟你解释 Flux，以及 Flux 的一些实现，比如 Flummox、Alt、Fluxible。不过说真的你应该用 Redux。 你说的这些我就当耳旁风了。再说一次，我只想展示数据。 这样啊，如果你只是想展示数据，其实你不需要 React。你只需要一个模板引擎。 你逗我呢？ 我只是告诉你你可以用什么技术。 别说了，真的。 我想说，即使只是用一个模板引擎，我还是会用 Typescript + SystemJS + Babel 的。 我只是想在页面上展示数据，你就告诉我用哪个模板引擎就好了。 有很多，你用过哪一个？ 额，太久没用了，不记得了。 jTemplates、jQote 还是 PURE？ 额，不记得，还有别的么？ Transparency? JSRender? MarkupJS? KnockoutJS? 这一个支持双向绑定。 还有吗？ PlatesJS? jQuery-tmpl? Handlebars? 还有些人在用。 有点像。有哪些跟最后一个比较像的？ Mustache, underscore? 我记得连 Lodash 都有一个模板引擎，不过这是 2014 年的事情了。 额，也许是再新一点的库？ Jade? DustJS？ 没用过 DotJS? EJS？ 没用过。Nunjucks? ECT? 没用过。记不起来了，要是你的话，你用哪个？ 我应该会用 ES6 原生的模板字符串 我猜猜，只有 ES6 支持。 对的。 需要用 Babel 对的。 需要用 npm 安装 对的。 需要用 Browserify 或者 Webpack，或者 SystemJS 对的。 如果没用 Webpack 的话，我还需要一个任务管理工具。 对的。 但是由于我要用函数式编程和强类型语言，所以我首先要用上 Typescript 或者 Flow。 对的。 如果我要用 await，那我就必须用 Babel 转译。 对的。 然后我就能用上 Fetch、Promise 和各种炫酷的东西。 嗯，别忘了加上 Fetch 的 Polyfill，因为 Safari 不支持 Fetch。 你猜怎么着，我们就聊到这吧。我不做了，我不做 Web 了，我也不想再碰 JS 了。 没事，过不了几年，我们都会用 Elm 或者 WebAssembly 了。 我要回后端去了，我受不这些变动、版本更新、编译和转译了，JS 社区如果觉得有人能跟上它的脚步，那这个社区就是疯了。 我理解你。我建议你去 Python 社区。 为什么？ 听说过 Python 3 吗？译者注：最后一句「听说过 Python 3 吗？」是讽刺 Python 3 发布已经 8 年了，Python 社区却依然在使用 Python 2.7。而 JS 社区正好相反，把还没有实现的语言特性都用到生成环境中了！ 译者：方应杭原文]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Git学习总结]]></title>
      <url>%2F2016%2F10%2F07%2Fgit%2F</url>
      <content type="text"><![CDATA[git 简介git 是分布式的，所以其核心就是分支，分支的意义在于，可以将项目代码按照功能、模块拆分成不同的分支。比如这个产品要加一个支付功能和一个登陆功能，可以创建两个分支，交给不同的开发人员并行开发。登陆功能先开发完，测试无误后合并改分支到 master 分支，master 分支部署上线。支付功能虽然没有开发完成，但是在另一条分支上，所以产品上线和功能开发完全不受影响。这才是分布式开发的高效模式。在 git 中，工作目录下面的所有文件都不外乎这两种状态：已跟踪或未跟踪。已跟踪的文件是指本来就被纳入版本控制管理的文件，在上次快照中有它们的记录，工作一段时间后，它们的状态可能是未更新，已修改或者已放入暂存区。而所有其他文件都属于未跟踪文件。它们既没有上次更新时的快照，也不在当前的暂存区域。初次克隆某个仓库时，工作目录中的所有文件都属于已跟踪文件，且状态为未修改。 实用指令详解merge通常，合并分支时，如果可能，Git 会用 Fast froward 模式，但这种模式下，删除分支后，会丢掉分支信息。如果要强制禁用 Fast forward 模式，Git 就会在 merge 时生成一个新的 commit ，这样，从分支历史上就可以看出分支信息。git merge --no-ff -m &#39;merge with no-ff&#39; dev因为本次合并要创建一个新的 commit，所以加上 -m 参数，把 commit 描述写进去。 合并分支时，加上 --no-ff 参数就可以用普通模式合并，合并后的历史有分支，能看出来曾经做过合并，而 fast forward 合并就看不出来曾经做过合并。 fetch一旦远程主机的版本库有了更新(git 术语叫做 commit)，需要将这些更新取回本地，这时就要用到 git fetch 命令。git fetch &lt;远程主机名&gt;上面命令将某个远程主机的更新，全部取回本地。默认情况下，git fetch 取回所有分支(branch)的更新。如果只想取回特定分支的更新，可以指定分支名。git fetch &lt;远程主机名&gt; &lt;分支名&gt;比如，取回 origin 主机的 master 分支git fetch origin master所取回的更新，在本地主机上要用“远程主机名/分支名”的形式读取。比如 origin 主机的 master，就要用 origin/master 读取。 git fetch -p ：取回远程更新，删除不存在的分支。 pullgit pull 命令的作用是，取回远程主机的某个分支的更新，再与本地的指定分支合并，完整格式如下：git pull &lt;远程主机名&gt; &lt;远程分支名&gt;:&lt;本地分支名&gt;比如，取回origin主机的next分支，与本地的master分支合并，需要写成下面这样。git pull origin next:master如果远程分支是与当前分支合并，则冒号后面的部分可以省略。git pull origin master上面的命令表示，取回 origin/master 分支，再与当前分支合并。实质上，这等同于先做 git fetch，再 merge。12git fetch origingit merge origin/master 在某些场合，git 会自动在本地分支与远程分支之间，建立一种追踪关系(tracking)。比如，在 git clone 的时候，所有本地分支默认与远程主机的同名分支，建立追踪关系，也就是说，本地的 master 分支自动“追踪” origin/master 分支。git 也允许手动建立追踪关系。git branch --set-upstream master origin/next上面的命令指定 master 分支追踪 origin/next 分支。如果当前分支与远程分支存在追踪关系，git pull 就可以省略远程分支名。git pull origin上面命令表示，本地的当前分支自动与对应的 origin 主机“追踪分支”(remote-tracking branch)进行合并。如果当前分支只有一个追踪分支，连远程主机名都可以忽略。git pull上面命令表示，当前分支自动与唯一一个追踪分支进行合并。如果合并需要采用 rebase 模式，可以使用 -rebase 选项。git pull --rebase &lt;远程主机名&gt; &lt;远程分支名&gt;:&lt;本地分支名&gt; pushgit push 命令用于将本地分支的更新，推送到远程主机。它的格式与 git pull 命令相仿。git push &lt;远程主机名&gt; &lt;本地分支名&gt;:&lt;远程分支名&gt;如果省略远程分支名，则表示将本地分支推送与之存在“追踪关系”的远程分支(通常两者同名)，如果该远程分支不存在，则会被新建。git push origin master上面命令表示，将本地的 master 分支推送到 origin 主机的 master 分支。如果后者不存在，则会被新建。如果省略本地分支名，则表示删除指定的远程分支，因为这等同于推送一个空的本地分支到远程分支。git push origin :master等同于git push origin --delete master上面命令表示删除 origin 主机的 master 分支。如果当前分支与远程分支之间存在追踪关系，则本地分支和远程分支都可以省略。git push origin上面命令表示，将当前分支推送到 origin 主机的对应分支。如果当前分支只有一个追踪分支，那么主机名都可以省略。git push如果当前分支与多个主机存在追踪关系，则可以使用-u选项指定一个默认主机，这样后面就可以不加任何参数使用 git push 。git push -u origin master上面的命令将本地 master 分支推送到 origin 主机，同时指定 origin 为默认主机，后面就可以不加任何参数使用 git push 了。不带任何参数的 git push ，默认只推送当前分支，这叫做 simple 方式。此外，还有一种 matching 方式，会推送所有有对应的远程分支的本地分支。git 2.0 版本之前，默认采用 matching 方式，现在改为默认采用 simple 方式，如果要修改这个设置，可以采用 git config 命令。git config --global push.default matching或者git config --global push.default simple还有一种情况，就是不管是否存在对应的远程分支，将本地的所有分支都推送到远程主机，这时需要使用 -all 选项。git push --all origin上面命令表示，将所有本地分支都推送到 origin 主机。如果远程主机的版本比本地版本更新，推送时 git 会报错，要求先在本地做 git pull 合并差异，然后再推送到远程主机。这时，如果你一定要推送，可以使用 -force 选项。git push --force origin上面命令使用-force选项，结果导致在远程主机产生一个“非直进式”的合并(non-fast-forward merge)。除非你很确定要这样做，否则应该尽量避免使用 -force 选项。最后，git push 不会推送标签(tag)，除非使用 -tags 选项。git push origin --tags loggit log 命令可以查看历史记录，git log 命令显示从最近到最远的提交日志；如果嫌输出信息太多，看得眼花缭乱的，可以试试 git log --pretty=oneline 。我们可以看到当前版本以及之前的版本日志以及版本号。用 git log --graph 命令可以看到分支合并图。或者两个参数一起用：git log --graph --pretty=onelinegit log --graph --pretty=oneline --abbrev-commit首先，git 必须知道当前版本是哪个版本，在 git 中，用 HEAD 表示当前版本，上一个版本就是 HEAD^ ，上上一个版本就是 HEAD^^ ， 当然往上100个版本写100个 ^ 比较容易数不过来，所以写成 HEAD~100 。现在，我们要把当前版本回退到上一个版本，就可以使用 git reset 命令：git reset --hard HEAD^当你回退到了某个版本后，git log 只能显示此版本及之前的版本的日志，之后的版本日志就看不到了，但是，我们想恢复到之后教新的版本怎么办？Git 提供了一个命令 git reflog 用来记录你的每一次命令 tag查看标签（用来标记标志性的稳定版本信息）发布一个版本时，我们通常先在版本库中打一个标签(tag)，这样，就唯一确定了打标签时刻的版本。将来无论什么时候，取某个标签的版本，就是把那个打标签的时刻的历史版本取出来。所以，标签也是版本库的一个快照。相比于 commit 的版本号(40位16进制)，标签号则要好使的多。所以，tag 就是一个让人容易记住的有意义的名字，它跟某个 commit 绑定在一起。 git tag [tag name]如果没有标签名，则为查看所有标签，带标签名则为新建标签 git tag &lt;tag name&gt; 就可以打一个新标签 还可以创建带有说明的标签，用 -a 指定标签名，-m 指定说明文字。git tag -a &lt;tag name&gt; -m &lt;comment&gt; ：添加带注释的标签eg: git tag -a v1.2 -m &#39;version 1.2 released&#39; git tag -a &lt;tag name&gt; &lt;md5&gt; ：对某个版本打标签默认标签是打在最新提交的 commit 上的。有时候，如果忘了打标签，比如，现在已经是周五了，但应该在周一打的标签没有打，怎么办？方法是找到历史提交的 commit id，然后打上就可以了。git log --pretty=oneline --abbrev-commit比方说要对 add merge 这次提交打标签，它对应的 commit id 是 6224937，那么我们就可以使用命令：git tag v1.2 6224937再用命令 git log 查看标签 可以用 git show &lt;tagname&gt; 查看标签信息 如果标签打错了，也可以删除：git tag -d v1.2 如果要推送某个标签到远程，使用命令 git push origin &lt;tagname&gt;eg: git push origin v1.2 如果标签已经推送到远程，要删除远程标签就要麻烦一点，先从本地删除：git tag -d v1.2然后，从远程删除；删除命令也是 push ，但是格式如下：git push origin :ref/tags/v1.2 git tag -l &#39;[expression]&#39;查看那符合正则表达式的 stashgit stash备份当前的工作区的内容，从最近的一次提交中读取相关内容，让工作区保证和上次提交的内容一致。同时，将当前的工作区内容保存到 Git 栈中。git stash pop从 Git 栈中读取最近一次保存的内容，恢复工作区的相关内容。由于可能存在多个 stash 的内容，所以用栈来管理，pop 会从最近的一个 stash 中读取内容并恢复。git stash list显示 Git 栈中内的所有备份，可以利用这个列表来决定从哪个地方恢复。git stash clear : 清空 Git 栈。 使用 git 的时候，我们往往使用 branch 解决任务切换问题，例如，我们往往会建一个自己的分支去修改和调试代码，如果别人或者自己发现原有的分支上有个不得不修改的 bug，我们往往会把完成一半的代码 commit 提交到本地仓库，然后切换分支去修改 bug，改好之后再切换回来。这样的话往往 log 上会有大量不必要的记录。其实如果我们不想提交完成一半或者不完善的代码，但是却不得不去修改一个紧急 bug，那么使用 git stash 就可以将你当前未提交到本地的代码推入到 git 的栈中，这时候你的工作区间和上一次提交的内容是完全一样的，所以你可以放心的修 bug，等到修完 bug，提交到服务器上后，再使用 git stash apply 将以前一般的工作应用回来。也许有的人会说，那我可不可以多次将未提交的代码压入到栈中？答案是可以的。当你多次使用 git stash 命令后，你的栈里将充满了未提交的代码，这时候你会对将哪个版本应用回来有些困惑， git stash list 命令可以将当前的 Git 栈信息打印出来，你只需要将找到对应的版本号，例如使用 git stash apply stash@{1} 就可以将你指定版本号为 stash@{1} 的工作取出来，当你将所有的栈都应用回来的时候，可以使用 git stash clear 来将栈清空。在这里顺便提下 git format-patch -n , n是具体某个数字， 例如 ‘git format-patch -1’ 这时便会根据log生成一个对应的补丁，如果 ‘git format-patch -2’ 那么便会生成 2 个补丁，当然前提是你的 log 上有至少有两个记录。 看过上面的信息，就可以知道使用场合了：当前工作区内容已被修改，但是并未完成。这时 Boss 来了，说前面的分支上面有一个 bug，需要立即修复。可是我又不想提交目前的修改，因为修改没有完成。但是，不提交的话，又没有办法 checkout 到前面的分支。此时用 git stash 就相当于备份了工作区了。然后在 checkout 过去修改，就能够达到保存当前工作区，并及时恢复的作用。 注意这里由于只 stash 了一次所以要使用 pop，具体你存放了多少。 remote查看远程仓库名 git remote -v查看远程仓库url git remote add &lt;basename&gt; &lt;url&gt;新增远程仓库 git remote show &lt;basename&gt;查看远程仓库详细信息 git remote rename &lt;old basename&gt; &lt;new basename&gt;重命名远程仓库 commitgit commit -a -m &#39;xx&#39;暂存并提交 branchgit branch查看本地仓库分支 git branch -r查看远程分支情况 git branch -a查看本地和远程的所有分支情况 git branch -v查看本地仓库分支最后一次提交情况 git branch -vv查看分支跟踪情况 git branch &lt;branch name&gt;新建分支 git branch -d &lt;branch name&gt;删除分支 git branch -D &lt;branch name&gt;强制删除分支 git branch [--merged | --no-merged]查看已合并|未合并的本地仓库分支 git branch -u &lt;remote base&gt;/&lt;remote branch&gt;修改当前跟踪分支 checkoutgit checkout -- [file] ：恢复文件git checkout -- demo.html 意思就是，把 demo.html 文件在工作区的修改全部撤销，这里有两种情况：一种是 demo.html 自修改后还没有被放到暂存区，现在，撤销修改就回到和版本库一模一样的状态；一种是 demo.html 已经添加到暂存区后，又作了修改，现在，撤销修改就回到添加暂存区后的状态。总之，就是让这个文件回到最后一次 git commit 或 git add 时的状态。 但是如果 git add 到暂存区了，在 commit 之前，想撤销：Git 同样告诉我们，用命令 git reset HEAD file 可以把暂存区的修改撤销掉(unstage)，重新放回工作区。git reset 命令既可以回退版本，也可以把暂存区的修改回退到工作区，当我们用 HEAD 时，表示最新的版本。再用 git status 查看一下，现在暂存区是干净的，工作区有修改：还记得如果丢弃工作区的修改吗？对的，使用：git checkout -- demo.html git checkout 其实是用版本库里的版本替换工作区的版本，无论工作区是修改还是删除，都可以”一键还原”。 git checkout -b [branchname] [tagname]在特定的版本上创建一个新的分支并切换到此分支 git checkout -b [local branch] [remote base]/[remote branch]将远程分支检出到本地分支，并追踪 git checkout --track &lt;remote base&gt;/&lt;remote branch&gt;让当前分支跟踪远程分支 rebasegit rebase [basebranch]变基是将一系列提交按照原有次序依次应用到另一分支上，而合并是把最终结果合在一起。 常见问题git clonegit clone 支持多种协议，除了HTTP(s)以外，还支持SSH、Git、本地文件协议等。使用 https 除了速度慢意外，还有个最大的麻烦是每次推送都必须输入口令，但是在某些只开放 http 端口的公司内部就无法使用ssh协议而只能用 https。 如何新建分支本地建立 branch 並立即切换到新分支git checkout -b &lt;branch_name&gt; 下面的命令表示，在 origin/master 的基础上，创建一个分支。git checkout -b newBranch origin/master 修改分支名称git branch -m &lt;new_name&gt; 从远程仓库拉取代码到本地仓库，并建立跟踪关系git checkout -b &lt;本地新分支名&gt; &lt;对应的远程分支名&gt; 如何在远程仓库新建一个分支新建一个本地分支，按照正常流程提交完代码后，推送到远程git push &lt;remote base&gt; &lt;local branch&gt;:&lt;remote branch&gt; 比较文件git diff HEAD -- demo.html命令可以查看工作区的 demo.html 和版本库里面最新版本的区别。 忽略某些文件默认方法是在当前项目目录下创建一个 .gitignore 文件，如果需要忽略的文件已经添加到版本库中，请先移除git rm --cached [file]不删除文件，只移除追踪。123cat .gitignore*.[oa]*~ 文件 .gitignore 的格式规范如下： 所有空行或者以注释符号 # 开头的目录都会被 git 忽略 可以使用标准的 glob 模式匹配 匹配模式最后跟反斜杠（/）说明要忽略的目录 要忽略指定模式以外的文件或目录，可以在模式前加上惊叹号（!）取反 bug 分支git 提供了一个 stash 功能，可以把当前工作现场“储藏”起来，等以后恢复现场后继续工作。git stash修改完 bug 后，回到当前分支上继续干活，工作区是干净的，刚才的工作现场存到哪里去了？git stash list ：查看 stash 列表(stash 是一个栈的结构)git 把 stash 内容存在某个地方了，但是需要恢复一下，有两个办法：一是用 git stash apply 恢复，但是恢复后，stash 内容并不删除，你需要用 git stash drop 来删除；另一种方式是用 git stash pop ，恢复的同时把 stash 内容也删了；你可以多次 stash ，恢复的时候，先用 git stash list 查看，然后恢复指定的 stash，用命令：git stash apply stash@{0} 配置文件配置 Git 的时候，加上 –global 是针对当前用户起作用的，如果不加，那只针对当前的仓库起作用。配置文件放哪了？每个仓库的 Git 配置文件都放在 .git/config 文件中，在这份配置文件中，别名就在 [alias] 后面，要删除别名，直接把对应的行删掉即可。 查看配置git config -1 设置git push 默认git config --global push.default current 设置别名git config --global alias.&lt;name&gt; &lt;commend&gt;我的设置：git config --global alias.st statusgit config --global alias.cm &quot;commit -m&quot;git config --global alias.ph &quot;push origin &lt;local_repository&gt;:&lt;remote_repository&gt;&quot; 保存用户名和密码对于http(s)协议，可以用下面命令临时缓存git config --global credential.helper cache开启linux缓存git config --global credential.helper wincred开启windows缓存 对于 ssh 协议，可以用 ssh key，具体教程网上很多解决问题问题一git 中执行命令 add .报错：Unlink of file ‘templates/opms.exe’ failed.Should I try again?(y/n) 因为这个文件正在被占用，所以不能添加到暂存区，而正好这个 .exe 文件，我们是不需要添加到版本管理工具的。所以我们选择 n 。 问题二git 中生成 sshkey: ssh-keygen -t rsa -C &quot;youremail&quot;这个email并没有什么用所以我们使用ssh-keygen -t rsa来生成sshkey就可以了。然后git中的配置文件：git config --listgit config --global user.name &quot;yu&quot;git config --global user.email &quot;react.dong.yu@gmail.com&quot;这种配置将会对本地所有的git仓库有效。那么在 push 的时候，远程就知道这个push来自于哪个email.但有时候在公司的时候，有的仓库是公司的，有的仓库是自己github的。这个时候就可以不设置global的配置了，而是在自己的仓库中设置git config --local user.email &quot;react.dong.yu@gmail.com&quot; 问题三使用 windows 的同学注意了，如果你在资源管理器里新建一个 .gitignore 文件，它会提示你必须输入文件名，但是在文本编辑器里“保存”或者“另存为”就可以把文件保存为 .gitignore 了。有些时候，你想添加一个文件到 git，但发现添加不了，原因是这个文件被 .gitignore 忽略了：git add App.class如果你确实想添加该文件，可以用 -f 制添加到 git：git add -f App.class或者你发现，可能是 .gitignore 写得有问题，需要找出来到底哪个规则写错了。可以用 git check-ignore 命令检查：git check-ignore -v App.class 问题四为什么我把我生成的 ssh key 添加到了 github 中然后 也 remote 了 https://github.com/Neveryu/Xxx.git为什么提交的时候报错，或者提示 输入密码账号是为什么 ssh key 是 ssh 协议的密钥，http 协议没权限 权威教程Pro Git 简体中文版]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Hexo-NexT搭建个人博客（二）]]></title>
      <url>%2F2016%2F09%2F30%2Fhexo-next-two%2F</url>
      <content type="text"><![CDATA[本篇文章将介绍基于NexT主题下的一些扩展功能的实现。首先，我们需要明白： 在 Hexo 中有两份主要的配置文件，其名称都是 _config.yml 。其中，一份位于站点根目录下，主要包含 Hexo 本身的配置；另一份位于主题目录下，这份配置由主题作者提供，主要用于配置主题相关的选项。 我们约定，将前者称为 站点配置文件，后者称为 主题配置文件 1.设置侧栏的位置修改 主题配置文件 中 sidebar.position 的值，支持的选项有：left right目前仅 Pisces Scheme 支持 position 配置，也就是说NexT主题的侧栏位置是不能设置的，设置了也没用，反正都在右边。 2. 关于添加居中模块优秀的人，不是不合群，而是他们合群的人里面没有你代码如下：1&lt;blockquote class="blockquote-center"&gt;优秀的人，不是不合群，而是他们合群的人里面没有你&lt;/blockquote&gt; 3. 添加High一下打开博客根目录 \themes\next\layout\_partials\header.swig ，在&lt;ul&gt; ... /ul&gt; 标签之间加入以下代码：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150&lt;li&gt; &lt;a title="把这个链接拖到你的Chrome收藏夹工具栏中" href='javascript:(function() &#123; function c() &#123; var e = document.createElement("link"); e.setAttribute("type", "text/css"); e.setAttribute("rel", "stylesheet"); e.setAttribute("href", f); e.setAttribute("class", l); document.body.appendChild(e) &#125; function h() &#123; var e = document.getElementsByClassName(l); for (var t = 0; t &lt; e.length; t++) &#123; document.body.removeChild(e[t]) &#125; &#125; function p() &#123; var e = document.createElement("div"); e.setAttribute("class", a); document.body.appendChild(e); setTimeout(function() &#123; document.body.removeChild(e) &#125;, 100) &#125; function d(e) &#123; return &#123; height : e.offsetHeight, width : e.offsetWidth &#125; &#125; function v(i) &#123; var s = d(i); return s.height &gt; e &amp;&amp; s.height &lt; n &amp;&amp; s.width &gt; t &amp;&amp; s.width &lt; r &#125; function m(e) &#123; var t = e; var n = 0; while (!!t) &#123; n += t.offsetTop; t = t.offsetParent &#125; return n &#125; function g() &#123; var e = document.documentElement; if (!!window.innerWidth) &#123; return window.innerHeight &#125; else if (e &amp;&amp; !isNaN(e.clientHeight)) &#123; return e.clientHeight &#125; return 0 &#125; function y() &#123; if (window.pageYOffset) &#123; return window.pageYOffset &#125; return Math.max(document.documentElement.scrollTop, document.body.scrollTop) &#125; function E(e) &#123; var t = m(e); return t &gt;= w &amp;&amp; t &lt;= b + w &#125; function S() &#123; var e = document.createElement("audio"); e.setAttribute("class", l); e.src = i; e.loop = false; e.addEventListener("canplay", function() &#123; setTimeout(function() &#123; x(k) &#125;, 500); setTimeout(function() &#123; N(); p(); for (var e = 0; e &lt; O.length; e++) &#123; T(O[e]) &#125; &#125;, 15500) &#125;, true); e.addEventListener("ended", function() &#123; N(); h() &#125;, true); e.innerHTML = " &lt;p&gt;If you are reading this, it is because your browser does not support the audio element. We recommend that you get a new browser.&lt;/p&gt; &lt;p&gt;"; document.body.appendChild(e); e.play() &#125; function x(e) &#123; e.className += " " + s + " " + o &#125; function T(e) &#123; e.className += " " + s + " " + u[Math.floor(Math.random() * u.length)] &#125; function N() &#123; var e = document.getElementsByClassName(s); var t = new RegExp("\\b" + s + "\\b"); for (var n = 0; n &lt; e.length; ) &#123; e[n].className = e[n].className.replace(t, "") &#125; &#125; var e = 30; var t = 30; var n = 350; var r = 350; var i = "//7xuupy.com1.z0.glb.clouddn.com/tongxingSibel%20-%20Im%20Sorry.mp3"; var s = "mw-harlem_shake_me"; var o = "im_first"; var u = ["im_drunk", "im_baked", "im_trippin", "im_blown"]; var a = "mw-strobe_light"; var f = "//s3.amazonaws.com/moovweb-marketing/playground/harlem-shake-style.css"; var l = "mw_added_css"; var b = g(); var w = y(); var C = document.getElementsByTagName("*"); var k = null; for (var L = 0; L &lt; C.length; L++) &#123; var A = C[L]; if (v(A)) &#123; if (E(A)) &#123; k = A; break &#125; &#125; &#125; if (A === null) &#123; console.warn("Could not find a node of the right size. Please try a different page."); return &#125; c(); S(); var O = []; for (var L = 0; L &lt; C.length; L++) &#123; var A = C[L]; if (v(A)) &#123; O.push(A) &#125; &#125; &#125;)() '&gt;High一下&lt;/a&gt; &lt;/li&gt; 4. 添加最近访客在需要添加最近访客的网页对应的 markdown 文件中添加如下代码：12最近访客&lt;div class="ds-recent-visitors" data-num-items="39" data-avatar-size="40" id="ds-recent-visitors"&gt;&lt;/div&gt; 5. 鼠标点击小红心的设置 将 love.js 文件添加到 \themes\next\source\js\src 文件目录下。 找到 \themes\next\layout\_layout.swing 文件， 在文件的后面，&lt;/body&gt; 标签之前 添加以下代码：12&lt;!-- 页面点击小红心 --&gt;&lt;script type="text/javascript" src="/js/src/love.js"&gt;&lt;/script&gt; 6. 背景的设置 将 particle.js 文件添加到 \themes\next\source\js\src 文件目录下。 找到 \themes\next\layout\_layout.swing 文件， 在文件的后面，&lt;/body&gt;标签之前 添加以下代码：12&lt;!-- 背景动画 --&gt;&lt;script type="text/javascript" src="/js/src/particle.js"&gt;&lt;/script&gt; 7.修改文章内链接文本样式将链接文本设置为蓝色，鼠标划过时文字颜色加深，并显示下划线。找到文件 themes\next\source\css\_custom\custom.styl ，添加如下 css 样式：12345678.post-body p a &#123; color: #0593d3; border-bottom: none; &amp;:hover &#123; color: #0477ab; text-decoration: underline; &#125;&#125; 8. 多说评论不稳定，加载速度慢怎么办？把多说评论依赖的 embed.js 放置底部，这里需要修改的文件是 duoshuo.swig。将1(document.getElementsByTagName('head')[0] 修改成下面的代码1(document.getElementById('footer') 9. 给 Github 添加 README默认情况下，Github中每一个项目，我们希望有一份 README.md 的文件来作为项目的说明，但是我们在项目根目录下的 blog\source 目录下创建一份 README.md 文件，写好说明介绍，部署的时候，这个 README.md 会被 hexo 解析掉，而不会被解析到 Github 中去的。正确的解决方法其实很简单： 把 README.md 文件的后缀名改成 “MDOWN” 然后扔到blog/source文件夹下即可，这样 hexo 不会解析，Github 也会将其作为 MD 文件解析。 10. 给 Blog 添加 LICENSE在 主题配置文件 中的 160 行左右：12345# Creative Commons 4.0 International License.# http://creativecommons.org/# Available: by | by-nc | by-nc-nd | by-nc-sa | by-nd | by-sa | zerocreative_commons: by-nc-sa#creative_commons: 将其中第 4 行的注释放开，然后选择你想使用的 LICENSE 即可，可选项参照第 3 行。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[如果深圳的夜晚没有风]]></title>
      <url>%2F2016%2F09%2F25%2Fessay-20160925%2F</url>
      <content type="text"><![CDATA[这座城市人很多，每天在路上都能看到好多拉着行李箱的人，不管他们是来到这座城市还是离开这座城市，至少他们都曾努力过。 其实专业做博客的网站还是挺多的，比如说 CSDN 是吧，我之前也是在 CSDN 上面写一点东西，我的 CSDN 博客 http://blog.csdn.net/csdn_yudong 。但是 CSDN 毕竟是一个技术类的博客网站，如果写一点生活杂谈还是不太好，而且 CSDN 上面挂载的广告，以及页面风格，我不太喜欢，因为我喜欢【精于心，简于形】，这波 NexT 主题的广告是不是很硬。 在我想做博客之前，一直到我开始着手做这个博客，其实花了好久时间。而在我着手开始做这个博客，到这个博客完成，其实并没有花多久。也说明了一个道理，就是一定要勇于尝试，关键是要动手。我想起了马士兵老师的一句话，一个新鲜的事物，你一定要先去用它，应用驱动学习。——我的建站日志有记录网站的建设过程。 究其原因：第一个，我觉得是自己考虑的太多，没有太大的把握就不会轻易的去尝试，所以我在着手做这个之前花了很多的时间去查，域名空间这些的，而且这些出售这些的服务商也挺多的，我这个人有选择恐惧症。也是怪尴尬的，每次看到一个东西有好多选择的时候，我都去比较，去分析，头痛。。而且我想，域名空间搞好以后，还要自己写页面这些的。关键是还要设计博客风格，页面样式这些的，一想到这些，就感觉是一个不小的工程啊，后来才发现我多虑了。 后来，无意中看到了 Hexo 的 Next 主题的一篇博客，风格样式挺不错的，感谢 Hexo 和 Next 的文档写的如此的棒，以至于每一个人都能根据教程搭建一个自己的博客。这一切是如此的美好。 最后送给大家一首歌，晚安。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Hexo-NexT搭建个人博客（一）]]></title>
      <url>%2F2016%2F09%2F03%2Fhello%2F</url>
      <content type="text"><![CDATA[简介Hexo 是一个快速、简洁且高效的静态站点生成框架，它基于 Node.js 。 它有以下特点： 超快速度Node.js 所带来的超快生成速度，让上百个页面在几秒内瞬间完成渲染。 支持MarkdownHexo 支持 GitHub Flavored Markdown 的所有功能，甚至可以整合 Octopress 的大多数插件。 一件部署只需一条指令即可部署到Github Pages，或其他网站 丰富的插件Hexo 拥有强大的插件系统，安装插件可以让 Hexo 支持 Jade, CoffeeScript。 通过 Hexo 你可以轻松地使用 Markdown 编写文章，除了 Markdown 本身的语法之外，还可以使用 Hexo 提供的 标签插件 来快速的插入特定形式的内容。 基于 Hexo 这个优秀的博客框架，很多优秀的开发者奉献出了它们基于 Hexo 开发的主题。NexT 因其 精于心，简于形 的风格，一直被广大用户所喜爱。 安装安装 Hexo 只需几分钟时间，若你在安装过程中遇到问题或无法找到解决方式，请提交问题，我会尽力解决你的问题。 安装前提安装 Hexo 相当简单。然而在安装前，您必须检查电脑中是否已安装下列应用程序: Node.jsGit 如果您的电脑中已经安装上述必备程序，那么恭喜你！接下来只需要使用 npm 即可完成 Hexo 的安装。1$ npm install -g hexo-cli 如果你的电脑中尚未安装所需要的程序，请根据以下安装指示完成安装。 安装 Git Windows：下载安装 git 。 Download Now Mac：使用 Homebrew，MacPorts 或下载 安装程序 安装 Linux（Ubuntu，Debian）：sudo apt-get install git-core Linux（Fedora，Red Hat，CentOS）：sudo yum install git-core 安装 Node.js安装 Node.js 的最佳方式是使用 nvm。（nvm：Node Version Manager）windows 下使用 nvm 请看这里： nvm-windows ，首先需要下载安装 nvm 。 Download Nowwindows下安装完nvm以后，我们可以打开命令行中执行命令12$ nvm$ nvm install latest 执行完以后，重启命令行，执行命令 node -v ，如果出现版本号，那么 Node.js 就安装成功了。 如果没有安装成功，那可能就是墙的原因。建议下载 Node.js 直接安装。 Download Now 安装 Hexo有了 Node.js ，我们可以使用 npm 安装 Hexo。1$ npm install -g hexo-cli 安装 Hexo 完成后，我们首先需要为我们的项目创建一个指定文件夹（例如我在 D 盘目录下创建了一个文件夹 blog 。D:\blog ），在指定文件夹中执行下列命令， Hexo 将会在指定文件夹中新建所需要的文件。1$ hexo init 等待安装，安装完成后，指定文件夹 的目录如下：12345678.├── _config.yml├── package.json├── scaffolds├── source| ├── _drafts| └── _posts└── 我们继续执行命令12$ hexo g$ hexo s --debug Hexo 将 source 文件夹中除 posts 文件夹之外，开头命名为 (下划线)的文件 / 文件夹和隐藏的文件将会被忽略。Markdown 和 HTML 文件会被解析并放到 public 文件夹，而其他文件夹会被拷贝过去。这个时候，我们在浏览器中访问 http://localhost:4000/ ，就可以看到基于 Hexo 的默认主题的原型： 安装 NexT 主题下载 NexT 主题依旧是在当前目录下，使用 Git checkout 代码：1$ git clone https://github.com/iissnan/hexo-theme-next themes/next 等待下载完成。 在 Hexo 中有两份主要的配置文件，其名称都是 _config.yml 。其中，一份位于站点根目录下，主要包含 Hexo 本身的配置；另一份位于主题目录下，这份配置由主题作者提供，主要用于配置主题相关的选项。 我们约定，将前者称为 站点配置文件，后者称为 主题配置文件 启用 NexT 主题打开 站点配置文件 ，找到 theme 字段，并将其值更改为 next 。到此， NexT 主题安装完成。下一步我们将验证主题是否正确启用。在切换主题之后、验证之前，我们最好使用 hexo clean 来清除 Hexo 的缓存。 验证主题首先启动 Hexo 本地站点，并开启调试模式（即加上 --debug），整个命令是 hexo s --debug。在服务启动的过程，注意观察命令行输出是否有任何异常信息。当命令行输出中提示： 1INFO Hexo is running at http://0.0.0.0:4000/. Press Ctrl+C to stop. 此时即可使用浏览器访问 http://localhost:4000/ ，检查站点是否正确运行。 当你看到站点的外观与下图所示类似时即说明你已成功安装 NexT 主题。这是 NexT 默认的 Scheme —— Muse现在，我们已经成功安装并启用了 NexT 主题。关于更多基本操作和基础知识，请查阅 Hexo 与 NexT 官方文档. 总结本地调试步骤三部曲：123$ hexo clean$ hexo g$ hexo s --debug 这种带 debug 的运行，如果出现错误，可以在命令行中看到错误提示信息。 部署步骤三部曲：123$ hexo clean$ hexo g$ hexo d 当然在部署之前，需要先配置好配置文件中的 deploy。 常用命令1234567$ hexo new "postName" #新建文章$ hexo new page "pageName" # 新建页面$ hexo generate # 生成静态页面至public目录$ hexo server # 开启预览访问端口(默认端口4000，'ctrl+c'关闭server)$ hexo deploy # 项目部署$ hexo help # 查看帮助$ hexo version # 查看Hexo的版本 简写命令1234$ hexo new == hexo n$ hexo generate == hexo g$ hexo server == hexo s$ hexo deploy == hexo d 常见问题1在 hexo 的配置和设置文件中，在冒号后面没留空格会导致出问题：错误的设置：123author:Neveryuemail:react.dong.yu@gmail.comlanguage:zh-CN 正确的设置：123author: Neveryuemail: react.dong.yu@gmail.comlanguage: zh-CN 常见问题2关于 Git 提交中用户名和 Email 的设置12git config --global user.name "Your name"git config --global user.email "Your email" 常见问题3Hexo 中的图标使用的是 Font Awesome ，所以，我们的博客已经自带了 Font Awesome 中的所有图标，基本可以满足我们的所有需求，我们可以去 Font Awesome 中查找我们想要使用的图标。 &lt;i class=&quot;fa fa-github&quot;&gt;&lt;/i&gt; &lt;i class=&quot;fa fa-github fa-lg&quot;&gt;&lt;/i&gt; &lt;i class=&quot;fa fa-github fa-2x&quot;&gt;&lt;/i&gt;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Hexo-NexT搭建个人博客（一）]]></title>
      <url>%2F2016%2F09%2F03%2Fhexo-next-one%2F</url>
      <content type="text"><![CDATA[简介Hexo 是一个快速、简洁且高效的静态站点生成框架，它基于 Node.js 。 它有以下特点： 超快速度Node.js 所带来的超快生成速度，让上百个页面在几秒内瞬间完成渲染。 支持MarkdownHexo 支持 GitHub Flavored Markdown 的所有功能，甚至可以整合 Octopress 的大多数插件。 一件部署只需一条指令即可部署到Github Pages，或其他网站 丰富的插件Hexo 拥有强大的插件系统，安装插件可以让 Hexo 支持 Jade, CoffeeScript。 通过 Hexo 你可以轻松地使用 Markdown 编写文章，除了 Markdown 本身的语法之外，还可以使用 Hexo 提供的 标签插件 来快速的插入特定形式的内容。 基于 Hexo 这个优秀的博客框架，很多优秀的开发者奉献出了它们基于 Hexo 开发的主题。NexT 因其 精于心，简于形 的风格，一直被广大用户所喜爱。 安装安装 Hexo 只需几分钟时间，若你在安装过程中遇到问题或无法找到解决方式，请提交问题，我会尽力解决你的问题。 安装前提安装 Hexo 相当简单。然而在安装前，您必须检查电脑中是否已安装下列应用程序: Node.jsGit 如果您的电脑中已经安装上述必备程序，那么恭喜你！接下来只需要使用 npm 即可完成 Hexo 的安装。1$ npm install -g hexo-cli 如果你的电脑中尚未安装所需要的程序，请根据以下安装指示完成安装。 安装 Git Windows：下载安装 git 。 Download Now Mac：使用 Homebrew，MacPorts 或下载 安装程序 安装 Linux（Ubuntu，Debian）：sudo apt-get install git-core Linux（Fedora，Red Hat，CentOS）：sudo yum install git-core 安装 Node.js安装 Node.js 的最佳方式是使用 nvm。（nvm：Node Version Manager）windows 下使用 nvm 请看这里： nvm-windows ，首先需要下载安装 nvm 。 Download Nowwindows下安装完nvm以后，我们可以打开命令行中执行命令12$ nvm$ nvm install latest 执行完以后，重启命令行，执行命令 node -v ，如果出现版本号，那么 Node.js 就安装成功了。 如果没有安装成功，那可能就是墙的原因。建议下载 Node.js 直接安装。 Download Now 安装 Hexo有了 Node.js ，我们可以使用 npm 安装 Hexo。1$ npm install -g hexo-cli 安装 Hexo 完成后，我们首先需要为我们的项目创建一个指定文件夹（例如我在 D 盘目录下创建了一个文件夹 blog 。D:\blog ），在指定文件夹中执行下列命令， Hexo 将会在指定文件夹中新建所需要的文件。1$ hexo init 等待安装，安装完成后，指定文件夹 的目录如下：12345678.├── _config.yml├── package.json├── scaffolds├── source| ├── _drafts| └── _posts└── 我们继续执行命令12$ hexo g$ hexo s --debug Hexo 将 source 文件夹中除 posts 文件夹之外，开头命名为 (下划线)的文件 / 文件夹和隐藏的文件将会被忽略。Markdown 和 HTML 文件会被解析并放到 public 文件夹，而其他文件夹会被拷贝过去。这个时候，我们在浏览器中访问 http://localhost:4000/ ，就可以看到基于 Hexo 的默认主题的原型： 安装 NexT 主题下载 NexT 主题依旧是在当前目录下，使用 Git checkout 代码：1$ git clone https://github.com/iissnan/hexo-theme-next themes/next 等待下载完成。 在 Hexo 中有两份主要的配置文件，其名称都是 _config.yml 。其中，一份位于站点根目录下，主要包含 Hexo 本身的配置；另一份位于主题目录下，这份配置由主题作者提供，主要用于配置主题相关的选项。 我们约定，将前者称为 站点配置文件，后者称为 主题配置文件 启用 NexT 主题打开 站点配置文件 ，找到 theme 字段，并将其值更改为 next 。到此， NexT 主题安装完成。下一步我们将验证主题是否正确启用。在切换主题之后、验证之前，我们最好使用 hexo clean 来清除 Hexo 的缓存。 验证主题首先启动 Hexo 本地站点，并开启调试模式（即加上 --debug），整个命令是 hexo s --debug。在服务启动的过程，注意观察命令行输出是否有任何异常信息。当命令行输出中提示： 1INFO Hexo is running at http://0.0.0.0:4000/. Press Ctrl+C to stop. 此时即可使用浏览器访问 http://localhost:4000/ ，检查站点是否正确运行。 当你看到站点的外观与下图所示类似时即说明你已成功安装 NexT 主题。这是 NexT 默认的 Scheme —— Muse现在，我们已经成功安装并启用了 NexT 主题。关于更多基本操作和基础知识，请查阅 Hexo 与 NexT 官方文档. 总结本地调试步骤三部曲：123$ hexo clean$ hexo g$ hexo s --debug 这种带 debug 的运行，如果出现错误，可以在命令行中看到错误提示信息。 部署步骤三部曲：123$ hexo clean$ hexo g$ hexo d 当然在部署之前，需要先配置好配置文件中的 deploy。 常用命令1234567$ hexo new "postName" #新建文章$ hexo new page "pageName" # 新建页面$ hexo generate # 生成静态页面至public目录$ hexo server # 开启预览访问端口(默认端口4000，'ctrl+c'关闭server)$ hexo deploy # 项目部署$ hexo help # 查看帮助$ hexo version # 查看Hexo的版本 简写命令1234$ hexo new == hexo n$ hexo generate == hexo g$ hexo server == hexo s$ hexo deploy == hexo d 常见问题1在 hexo 的配置和设置文件中，在冒号后面没留空格会导致出问题：错误的设置：123author:Neveryuemail:react.dong.yu@gmail.comlanguage:zh-CN 正确的设置：123author: Neveryuemail: react.dong.yu@gmail.comlanguage: zh-CN 常见问题2关于 Git 提交中用户名和 Email 的设置12git config --global user.name "Your name"git config --global user.email "Your email" 常见问题3Hexo 中的图标使用的是 Font Awesome ，所以，我们的博客已经自带了 Font Awesome 中的所有图标，基本可以满足我们的所有需求，我们可以去 Font Awesome 中查找我们想要使用的图标。 &lt;i class=&quot;fa fa-github&quot;&gt;&lt;/i&gt; &lt;i class=&quot;fa fa-github fa-lg&quot;&gt;&lt;/i&gt; &lt;i class=&quot;fa fa-github fa-2x&quot;&gt;&lt;/i&gt;]]></content>
    </entry>

    
  
  
</search>
