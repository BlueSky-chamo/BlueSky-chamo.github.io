<?xml version="1.0" encoding="utf-8"?>
<search>
  
    
    <entry>
      <title><![CDATA[IOTKOT入手初体验]]></title>
      <url>%2F2017%2F03%2F30%2FIOTKOT%E5%85%A5%E6%89%8B%E5%88%9D%E4%BD%93%E9%AA%8C%2F</url>
      <content type="text"><![CDATA[简介IOTKOT套件提供WIFI接口，可兼容marvell、高通、博通、TI、庆科、汉枫、乐鑫、微雪电子等主流WIFI模组，方便用户选择。开发板配套的WIFI模组默认烧写的是支持机智云平台的云服务的固件，只需要MCU用串口就可以跟WIFI模组进行通信，并且实现远程控制。 IOTKOT手册Download NowIOTKOT硬件结构上采用两层板架构，包括底层板与功能板，下面分别来了解底层板与功能板。 功能板简介WIFI扩展接口: 引出WIFI模块的串口与JTAG下载口WIFI接口：外接wifi模块LM393:红外对射管驱动芯片扩展接口：引出Arduino上多余的IO口用户按键：用户自定义按键温度传感器：实时检测当前环境温度电机驱动芯片：L9110S红外线对射管：红外被遮挡就会触发报警RGB灯：可以变换256256256中颜色PB913: 驱动RGB芯片 底板简介STM32F103R8T6:72MHZ工作频率CP2102:USB转串口芯片AMS1117-3.3:5v转3.3V LDO串口跳线：隔离USB转串口和MCU串口USB接口：USB供电接口和USB转串口SWD下载口：STM32下载调试电压开关：启动系统电源复位按键：系统复位BOOT开关：USB接口下载，拨到SYSTEM;SWD下载拨到FLASHArduino接口：引出Arduino接口晶振：32.768实时时钟晶振SPI接口：预留SPI接口，二次开发8M晶振：高速晶振 程序下载开发工具采用keil实现程序开发与下载，具体keil的设置不再详述，参考用户手册 Keil4 Download Now 程序下载在keil中采用TS-Link下载，具体设置用户手册与网上资料较多，不再详述 ST-Link V2 Download Now 下载验证通过keil打开提供的微信宠物屋MCU源码,可成功利用ST-Link将源码程序下载入IOTKOT。 实验源码 Download Now 开发板连接路由有关开发板连接路由用户手册有详细步骤，仅简单总结一下步骤： 下载Demo APP，并将手机连接路由 注册机智云后添加设备，选择对应WIFI模组，例如庆科 长按开发板KEY2按键，知道RGB灯亮绿灯，继续下一步 在网络良好情况下，会自动搜索设备并完成配置，并在主界面点击绑定进入控制界面，在手机关掉wifi，连接3,4G网络依然可以实现远程控制备注：由于配置时网络连接不好，利用移动热点进行的配置，依然可以实现远程控制。 后记刚刚收到IOTKOT开发套件，仅仅只是测试了开发板，后续再针对源码进行学习。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[IOTKOT源码分析(1)]]></title>
      <url>%2F2017%2F03%2F30%2FIOTKOT%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90(1)%2F</url>
      <content type="text"><![CDATA[前言针对宠物屋MCU源码，进行相关分析与理解。 目录结构 源码过程分析SystemInit()系统时钟初始化，配置时钟72MHZ HW_Init()用户相关初始化，包括要使用的外设初始化，串口初始化，定时器初始化等。如下： Delay_Init(72); UARTx_Init(); RGB_KEY_GPIO_Init(); RGB_LED_Init(); LED_GPIO_Init(); KEY_GPIO_Init(); TIM3_Int_Init(7199,9); Motor_Init(); DHT11_Init(); IR_Init(); Printf_SystemRccClocks()时钟频率打印，包括SYSCLK,HCLK,PCLK1,PLCK2,SADCCLK时钟频率 SW_Init()机智云平台初始化，包含数据点的初始化，协议处理初始化 GizWits_init(sizeof(ReadTypeDef_t))形参ReadTypeDef_t为结构体 ，数据类型所占字节数不能大于MAX_P0_LEN(128),结构体声明具体如下： _packed typedef struct { uint8_t LED_Cmd; uint8_t LED_R; uint8_t LED_G; uint8_t LED_B; MOTOR_T Motor; uint8_t Infrared; uint8_t Temperature; uint8_t Humidity; uint8_t Alert; uint8_t Fault; }ReadTypeDef_t; 涉及到的几个结构体如下： WIFI模组请求设备信息: _packed typedef struct { Pro_HeadPartTypeDef Pro_HeadPart; uint8_t Pro_ver[8]; uint8_t P0_ver[8]; uint8_t Hard_ver[8]; uint8_t Soft_ver[8]; uint8_t Product_Key[32]; uint16_t Binable_Time; uint8_t Sum; } Pro_M2W_ReturnInfoTypeDef; 协议标准头: _packed typedef struct { uint8_t Head[2]; uint16_t Len; uint8_t Cmd; uint8_t SN; uint8_t Flags[2]; } Pro_HeadPartTypeDef; P0报文标准头: _packed typedef struct { Pro_HeadPartTypeDef Pro_HeadPart; P0_ActionTypeDef Action; } Pro_HeadPartP0CmdTypeDef; 函数中主要完成WIFI模组请求设备信息与P0报文标准头的初始化，主要是对其中的协议标准头等赋值。对于WIFI模组设备请求信息： Pro_M2W_ReturnInfoStruct Pro_HeadPart.Head[0] = 0xFF; Pro_HeadPart.Head[1] = 0xFF; Pro_HeadPart.Len=exchangeBytes(sizeof(Pro_M2W_ReturnInfoStruct) - 4)； Pro_HeadPart.Cmd=Pro_D2W__GetDeviceInfo_Ack_Cmd； //命令码0x02; Pro_M2W_ReturnInfoStruct.Pro_ver=00000004； Pro_M2W_ReturnInfoStruct.P0_ver=00000004； Pro_M2W_ReturnInfoStruct.Hard_ver=00000001； Pro_M2W_ReturnInfoStruct.Soft_ver=00000001； Pro_M2W_ReturnInfoStruct.Product_Key=6f3074fe43894547a4f1314bd7e3ae0b； 对于P0报文标准头：Pro_HeadPartP0Cmd Pro_HeadPart.Head[0] = 0xFF； Pro_HeadPart.Head[1] = 0xFF; Pro_HeadPart.Len = exchangeBytes(sizeof(Pro_HeadPartP0CmdTypeDef) - 4); Pro_HeadPart.Cmd = 0x0; Pro_HeadPart.SN = 0; Pro_HeadPart.Flags[0] = 0x0; Pro_HeadPart.Flags[1] = 0x0; While(1)循环KEY_Handle()按键处理函数，主要判断相应按键是否按下以及事件处理 ReadKeyValue()键值读取函数 static uint8_t Key_Check; static uint8_t Key_State; static uint16_t Key_LongCheck; static uint8_t Key_Prev = 0; //上一次按键 uint8_t Key_press; uint8_t Key_return = 0; if(KeyCountTime &gt;= 10) //按键消抖10ms { KeyCountTime = 0; Key_Check = 1; } if(Key_Check == 1) { Key_Check = 0; Key_press = Get_Key();//KEY1按下为0x01,KEY2按下为0x02,KEY3按下为0x04 switch (Key_State) { case 0: if(Key_press != 0)//有按键按下 { Key_Prev = Key_press;记录上个时间点按下的按键，然后下次程序读取按键是否有按键按下，并跟上个时间点的按下的按键比较 Key_State = 1;//程序往case 1进行 } break; case 1: if(Key_press == Key_Prev)//按下的按键没有抬起 { Key_State = 2;//往case 2进行 Key_return= Key_Prev | KEY_DOWN;返回值，如按键按下，0x01|0x10 返回0x11 } else //按键抬起为抖动，不是相应按键 { Key_State = 0; } break; case 2: if(Key_press != Key_Prev)//判断是否是短按 { Key_State = 0; Key_LongCheck = 0; Key_return = Key_Prev | KEY_UP;0x01|0x20 返回0x21 return Key_return; } if(Key_press == Key_Prev) { Key_LongCheck++; if(Key_LongCheck &gt;= 100) //长按2S { Key_LongCheck = 0; Key_State = 3; Key_return= Key_press | KEY_LONG; return Key_return; } } break; case 3: if(Key_press != Key_Prev) { Key_State = 0; } break; } } return NO_KEY; } LED_RGB_Control(255, 0, 0)RGB等控制函数 void LED_RGB_Control(uint8_t R, uint8_t G, uint8_t B) { GPIO_SetBits(GPIO_RGB_PORT,GPIO_RGB_PIN); Send32Zero(); DataDealWithAndSend(R, G, B); // display red } GizWits_D2WConfigCmd(SoftAp_Mode)MCU通知wifi模组进入配置模式，形参代表SoftAp_Mod模式，0x01 Pro_D2W_ConfigWifiTypeDef Pro_D2WConfigWiFiMode; Pro_D2WConfigWiFiMode.Pro_HeadPart.Head[0] = 0xFF; Pro_D2WConfigWiFiMode.Pro_HeadPart.Head[1] = 0xFF; Pro_D2WConfigWiFiMode.Pro_HeadPart.Len = exchangeBytes(sizeof(Pro_D2W_ConfigWifiTypeDef) - 4); Pro_D2WConfigWiFiMode.Pro_HeadPart.Cmd = Pro_D2W_ControlWifi_Config_Cmd;//0x09 Pro_D2WConfigWiFiMode.Pro_HeadPart.SN = SN++; Pro_D2WConfigWiFiMode.Pro_HeadPart.Flags[0] = 0x00; Pro_D2WConfigWiFiMode.Pro_HeadPart.Flags[1] = 0x00; Pro_D2WConfigWiFiMode.Config_Method = WiFi_Mode; Pro_D2WConfigWiFiMode.Sum = CheckSum((uint8_t *)&amp;Pro_D2WConfigWiFiMode, sizeof(Pro_D2W_ConfigWifiTypeDef)); Pro_UART_SendBuf((uint8_t *)&amp;Pro_D2WConfigWiFiMode, sizeof(Pro_D2W_ConfigWifiTypeDef), 1); #ifdef PROTOCOL_DEBUG printf(&quot;[%d] MCU : &quot;, SystemTimeCount); for(uint16_t i=0; i&lt;sizeof(Pro_D2W_ConfigWifiTypeDef); i++) { printf(&quot;%2x &quot;, *((uint8_t *)&amp;Pro_D2WConfigWiFiMode + i)); } printf(&quot;\r\n&quot;); #endif 其中Pro_UART_SendBuf()为串口发送函数形参： buf:数据起始地址； packLen:数据长度； tag=0,不等待ACK；tag=1,等待ACK功能：若等待ACK，按照协议失败重发3次；数据区出现FF，在其后增加55 static void Pro_UART_SendBuf(uint8_t *Buf, uint16_t PackLen, uint8_t Tag) { uint16_t i; for(i=0; i&lt;PackLen; i++) { UART2_Send_DATA(Buf[i]); if(i &gt;=2 &amp;&amp; Buf[i] == 0xFF) { UART2_Send_DATA(0x55); } } //需要实现重发的报文 if(Tag == 1) { Wait_AckStruct.SendTime = SystemTimeCount; Wait_AckStruct.SendNum = 0; Wait_AckStruct.Flag = 1; memcpy(Wait_AckStruct.Cmd_Buff, Buf, PackLen); } } GizWits_D2WResetCmd()若按键1长按，则进入复位状态，发送复位命令 void GizWits_D2WResetCmd(void) { Pro_CommonCmdTypeDef Pro_D2WReset; Pro_D2WReset.Pro_HeadPart.Head[0] = 0xFF; Pro_D2WReset.Pro_HeadPart.Head[1] = 0xFF; Pro_D2WReset.Pro_HeadPart.Len = exchangeBytes(sizeof(Pro_CommonCmdTypeDef) - 4); Pro_D2WReset.Pro_HeadPart.Cmd = Pro_D2W_ResetWifi_Cmd; Pro_D2WReset.Pro_HeadPart.SN = SN++; Pro_D2WReset.Pro_HeadPart.Flags[0] = 0x00; Pro_D2WReset.Pro_HeadPart.Flags[1] = 0x00; Pro_D2WReset.Sum = CheckSum((uint8_t *)&amp;Pro_D2WReset, sizeof(Pro_CommonCmdTypeDef)); Pro_UART_SendBuf((uint8_t *)&amp;Pro_D2WReset, sizeof(Pro_CommonCmdTypeDef), 1); #ifdef PROTOCOL_DEBUG printf(&quot;[%d] MCU : &quot;, SystemTimeCount); for(uint16_t i=0; i&lt;sizeof(Pro_CommonCmdTypeDef); i++) { printf(&quot;%2x &quot;, *((uint8_t *)&amp;Pro_D2WReset + i)); } printf(&quot;\r\n&quot;); #endif } GizWits_D2WConfigCmd(AirLink_Mode)若KEY2长按，则控制RGB灯变绿灯，同时进入Airlink_Mode设置模式，函数如同GizWits_D2WConfigCmd(SoftAp_Mode) GizWits_MessageHandle(p0_control_buf, sizeof(WirteTypeDef_t))消息处理函数 u8 GizWits_MessageHandle(u8 * Message_Buf, u8 Length_buf) { uint8_t ret = 0; Pro_HeadPartTypeDef *Recv_HeadPart = NULL; /*抓取一包*/ Pro_GetFrame(); memset(&amp;Recv_HeadPart, 0, sizeof(Recv_HeadPart)); /*重发机制*/ GizWits_D2W_Resend_AckCmdHandle(); if(packageFlag) { /*验证校验码*/ if(CheckSum(UART_HandleStruct.Message_Buf, UART_HandleStruct.Message_Len) != UART_HandleStruct.Message_Buf[UART_HandleStruct.Message_Len - 1]) { Pro_W2D_ErrorCmdHandle(Error_AckSum); packageFlag = 0; return 1; } /*判断ACK*/ ret = GizWits_W2D_AckCmdHandle(); #ifdef DEBUG if(ret == 0) { printf(&quot;ACK: SUCCESS! ...\r\n&quot;); } #endif Recv_HeadPart = (Pro_HeadPartTypeDef *)UART_HandleStruct.Message_Buf; switch (Recv_HeadPart-&gt;Cmd) { case Pro_W2D_GetDeviceInfo_Cmd: Pro_W2D_GetMcuInfo(); break; case Pro_W2D_P0_Cmd: { switch(UART_HandleStruct.Message_Buf[sizeof(Pro_HeadPartTypeDef)]) { case P0_W2D_Control_Devce_Action: { Pro_W2D_CommonCmdHandle(); memcpy(Message_Buf, UART_HandleStruct.Message_Buf+sizeof(Pro_HeadPartP0CmdTypeDef), Length_buf); p0Flag = 1; break; } case P0_W2D_ReadDevStatus_Action: Pro_W2D_ReadDevStatusHandle(); break; default: break; } } break; case Pro_W2D_P0_Ack_Cmd: break; case Pro_W2D_Heartbeat_Cmd: Pro_W2D_CommonCmdHandle(); break; case Pro_W2D_ControlWifi_Config_Ack_Cmd: break; case Pro_W2D_ResetWifi_Ack_Cmd: break; case Pro_W2D_ReportWifiStatus_Cmd: Pro_W2D_WifiStatusHandle(); break; case Pro_W2D_ReportMCUReset_Cmd: Pr0_W2D_RequestResetDeviceHandle(); break; case Pro_W2D_ErrorPackage_Cmd: //Pro_W2D_ErrorCmdHandle(Error_AckSum);//bug break; default: Pro_W2D_ErrorCmdHandle(Error_Cmd); break; } memset(&amp;UART_HandleStruct.Message_Buf, 0, UART_HandleStruct.Message_Len); packageFlag = 0; } return 1; } Pro_GetFrame()抓包函数 static uint8_t Pro_GetFrame() { if(rb_can_read(&amp;u_ring_buff) &gt;= 1) { if(packageFlag ==0) { rb_read(&amp;u_ring_buff, &amp;curValue, 1); if((lastValue == 0xFF)&amp;&amp;(curValue == 0xFF)) { tmp_buf[0] = 0xFF; tmp_buf[1] = 0xFF; count = 2; return 1; } if((lastValue == 0xFF)&amp;&amp;(curValue == 0x55)) { lastValue = curValue; return 1; } tmp_buf[count] = curValue; count ++ ; lastValue = curValue; if(count ==4) { dataLen = tmp_buf[2]*256+ tmp_buf[3]; } if(count == (dataLen + 4)) { //把rb的数据，拷贝到UART_HandleStruct memcpy(UART_HandleStruct.Message_Buf, tmp_buf, dataLen + 4); UART_HandleStruct.Message_Len = dataLen + 4; #ifdef PROTOCOL_DEBUG printf(&quot;GAgentToMCU: &quot;); for(uint8_t i=0; i&lt;dataLen+4; i++) { printf(&quot;%2x &quot;, UART_HandleStruct.Message_Buf[i]); } printf(&quot;\r\n&quot;); #endif memset(tmp_buf, 0, (dataLen + 4)); packageFlag = 1; lastValue = curValue =0; return 0; } } } return 1; } 环形缓冲区RingBuffertypedef struct { size_t rb_capacity;/缓冲区容量 char *rb_head;//用于读出的指针 char *rb_tail;//用于写入的指针 char rb_buff[256];//缓冲区实体 }RingBuffer; rb_new():创建环形缓冲区，head与tail指针都指向rb_buff的首地址 void rb_new(RingBuffer* rb) { //RingBuffer *rb = (RingBuffer *)buff;//malloc(sizeof(RingBuffer) + capacity); //if (rb == NULL) return NULL; rb-&gt;rb_capacity = MAX_RINGBUFFER_LEN;//-sizeof(RingBuffer);//capacity; //rb-&gt;rb_buff = buff+sizeof(RingBuffer);//(char*)rb + sizeof(RingBuffer); rb-&gt;rb_head = rb-&gt;rb_buff; rb-&gt;rb_tail = rb-&gt;rb_buff; //return rb;}; rb_capacity：缓冲区容量 size_t rb_capacity(RingBuffer *rb) { //assert(rb != NULL); return rb-&gt;rb_capacity; } 获得缓冲区可读区域，返回可读区域大小：三种情况：1、head与tail都指向同一个地方时，可读区域大小为0。这种情况只会在缓冲区还未使用时出现，开始使用之后，不会出现head/tail重合的现象，即tail永远不会等于head，否则head指向的数据还未读走就被覆盖了2、head &lt; tail ，说明tail没有写到缓冲区末尾，从缓冲区开头重新开始。可读的区域自然为(tail - head)3、head &gt; tail ，说明tail已经从缓冲区末尾写完，并从开头处重新准备写了。获得可读区域： size_t rb_can_read(RingBuffer *rb) { if (rb-&gt;rb_head == rb-&gt;rb_tail) return 0; if (rb-&gt;rb_head &lt; rb-&gt;rb_tail) return rb-&gt;rb_tail - rb-&gt;rb_head; return rb_capacity(rb) - (rb-&gt;rb_head - rb-&gt;rb_tail); } 获得可写区域： size_t rb_can_write(RingBuffer *rb) { return rb_capacity(rb) - rb_can_read(rb); } 读数据，从head指向的地址开始，读到data指向的地址处，读count个数据,返回读的个数三种情况： head &lt; tail ，此时要从count 和”可读区域大小”中选一个较小的值，作为读操作的次数。避免了count 大于“可读区域”的错误。 head &gt; tail 且 count 的个数 小于“从head到缓冲区末尾的数据个数”图中蓝色。直接复制内存，再修改head 指针即可。 head &gt; tail 且 count 的个数 大于“从head到缓冲区末尾的数据个数”。此时，先把从head到缓冲区末尾的值蓝色复制到data处，再把剩余的绿色复制过去。注意两个值：copy_sz 和*(data + copy_sz)写数据，把数据从data指向的地址，写到tail 指向的地址，写count个,返回写的个数。这里进来直接判断，要写入的内容大小 要小于可写区域大小，防止造成数据覆盖。写入合法。下面写入分了三种情况： 需要计算tail_avail_sz，这个值为tail 到缓冲区末尾的数据区域大小。 head &lt; tail ，count &lt; tail_avail_sz 。直接复制内容。假如tail 到了缓冲区末尾，让tail 回到缓冲区首地址。 head &lt; tail ，count &gt; tail_avail_sz 。先写入 tail_avail_sz 个数据，tail 回到缓冲区首地址，再写入剩余的部分。 head &gt; tail ，这种情况最简单，由于已经做了写入合法判断，所以直接复制内容，修改tail 即可。 读环形缓冲区：size_t rb_read(RingBuffer rb, void data, size_t count) size_t rb_read(RingBuffer *rb, void *data, size_t count) { //assert(rb != NULL); //assert(data != NULL); if (rb-&gt;rb_head &lt; rb-&gt;rb_tail) { int copy_sz = min(count, rb_can_read(rb)); memcpy(data, rb-&gt;rb_head, copy_sz); rb-&gt;rb_head += copy_sz; return copy_sz; } else { if (count &lt; rb_capacity(rb)-(rb-&gt;rb_head - rb-&gt;rb_buff)) { int copy_sz = count; memcpy(data, rb-&gt;rb_head, copy_sz); rb-&gt;rb_head += copy_sz; return copy_sz; } else { int copy_sz = rb_capacity(rb) - (rb-&gt;rb_head - rb-&gt;rb_buff); memcpy(data, rb-&gt;rb_head, copy_sz); rb-&gt;rb_head = rb-&gt;rb_buff; copy_sz += rb_read(rb, (char*)data+copy_sz, count-copy_sz); return copy_sz; } } } 写环形缓冲区：size_t rb_write(RingBuffer rb, const void data, size_t count) size_t rb_write(RingBuffer *rb, const void *data, size_t count) { //assert(rb != NULL); //assert(data != NULL); if (count &gt;= rb_can_write(rb)) return -1; if (rb-&gt;rb_head &lt;= rb-&gt;rb_tail) { int tail_avail_sz = rb_capacity(rb) - (rb-&gt;rb_tail - rb-&gt;rb_buff); if (count &lt;= tail_avail_sz) { memcpy(rb-&gt;rb_tail, data, count); rb-&gt;rb_tail += count; if (rb-&gt;rb_tail == rb-&gt;rb_buff+rb_capacity(rb)) rb-&gt;rb_tail = rb-&gt;rb_buff; return count; } else { memcpy(rb-&gt;rb_tail, data, tail_avail_sz); rb-&gt;rb_tail = rb-&gt;rb_buff; return tail_avail_sz + rb_write(rb, (char*)data+tail_avail_sz, count-tail_avail_sz); } } else { memcpy(rb-&gt;rb_tail, data, count); rb-&gt;rb_tail += count; return count; } } GizWits_D2W_Resend_AckCmdHandle()重发机制，Wait_AckStruct.Flag == 1则重发 static uint8_t GizWits_D2W_Resend_AckCmdHandle(void) { if(Wait_AckStruct.Flag == 1)//在Pro_UART_SendBuf()中设置Flag { if(Wait_AckStruct.SendNum &lt; Send_MaxNum) { if((SystemTimeCount - Wait_AckStruct.SendTime) &gt; Send_MaxTime) { Pro_UART_SendBuf((uint8_t *)&amp;Wait_AckStruct.Cmd_Buff, Wait_AckStruct.ResendBufLen, 0); printf(&quot;Send again\r\n&quot;); Wait_AckStruct.SendTime = SystemTimeCount; Wait_AckStruct.SendNum++; return 2; } } else { memset(&amp;Wait_AckStruct, 0, sizeof(Wait_AckStruct)); //Wait_AckStruct.Flag = 0; return 1; } } return 0; } 在Pro_UART_SendBuf()中，单个参数tag代表是否等待ACK,里面会对Wait_AckStruct进行赋值 //需要实现重发的报文 if(Tag == 1) { Wait_AckStruct.SendTime = SystemTimeCount;//重发时记录的时间戳 Wait_AckStruct.SendNum = 0;//重发次数 Wait_AckStruct.Flag = 1;//1,表示有需要等待的ACk,0表示无需等待的ACK memcpy(Wait_AckStruct.Cmd_Buff, Buf, PackLen);重发数据缓冲区 } GizWits_W2D_AckCmdHandle()判断ACK,但是函数返回值ret并没有利用起来，应该利用ret返回值来判断是否启动重发机制，返回值ret=0,则表示ACK成功 /*判断ACK*/ static uint8_t GizWits_W2D_AckCmdHandle(void) { Pro_HeadPartTypeDef * Wait_Ack_HeadPart = (Pro_HeadPartTypeDef *)Wait_AckStruct.Cmd_Buff; Pro_HeadPartTypeDef * Recv_HeadPart = (Pro_HeadPartTypeDef *)UART_HandleStruct.Message_Buf; if(Wait_AckStruct.Flag == 1)//在Pro_UART_SendBuf()中设置Flag { /*判断收到的报文命令码和报文序号,是否是需要等到的ACK*/ if((Wait_Ack_HeadPart-&gt;Cmd == (Recv_HeadPart-&gt;Cmd - 1)) &amp;&amp; (Wait_Ack_HeadPart-&gt;SN == Recv_HeadPart-&gt;SN)) { memset(&amp;Wait_AckStruct, 0, sizeof(Wait_AckStruct)); //Wait_AckStruct.Flag = 0; return 0; //允许重新reprot } } return 1; } switch (Recv_HeadPart-&gt;Cmd)根据对应的命令码进行对应操作 switch (Recv_HeadPart-&gt;Cmd) { //wifi模组请求信息，获取MUC信息 case Pro_W2D_GetDeviceInfo_Cmd: Pro_W2D_GetMcuInfo(); break; case Pro_W2D_P0_Cmd: { switch(UART_HandleStruct.Message_Buf[sizeof(Pro_HeadPartTypeDef)]) { case P0_W2D_Control_Devce_Action: { Pro_W2D_CommonCmdHandle(); memcpy(Message_Buf, UART_HandleStruct.Message_Buf+sizeof(Pro_HeadPartP0CmdTypeDef), Length_buf); p0Flag = 1; break; } case P0_W2D_ReadDevStatus_Action: Pro_W2D_ReadDevStatusHandle(); break; default: break; } } break; case Pro_W2D_P0_Ack_Cmd: break; case Pro_W2D_Heartbeat_Cmd: Pro_W2D_CommonCmdHandle(); break; case Pro_W2D_ControlWifi_Config_Ack_Cmd: break; case Pro_W2D_ResetWifi_Ack_Cmd: break; case Pro_W2D_ReportWifiStatus_Cmd: Pro_W2D_WifiStatusHandle(); break; case Pro_W2D_ReportMCUReset_Cmd: Pr0_W2D_RequestResetDeviceHandle(); break; case Pro_W2D_ErrorPackage_Cmd: //Pro_W2D_ErrorCmdHandle(Error_AckSum);//bug break; default: Pro_W2D_ErrorCmdHandle(Error_Cmd); break; } Pro_W2D_GetMcuInfo()条件：case Pro_W2D_GetDeviceInfo_Cmd://0x01,设备信息命令码WIFI模组请求设备信息，获取mcu信息 static void Pro_W2D_GetMcuInfo(void) { memcpy(&amp;Pro_CommonCmdStruct, UART_HandleStruct.Message_Buf, sizeof(Pro_CommonCmdStruct)); Pro_M2W_ReturnInfoStruct.Pro_HeadPart.SN = Pro_CommonCmdStruct.Pro_HeadPart.SN; Pro_M2W_ReturnInfoStruct.Sum = CheckSum((uint8_t *)&amp;Pro_M2W_ReturnInfoStruct, sizeof(Pro_M2W_ReturnInfoStruct)); Pro_UART_SendBuf((uint8_t *)&amp;Pro_M2W_ReturnInfoStruct,sizeof(Pro_M2W_ReturnInfoStruct), 0); #ifdef PROTOCOL_DEBUG printf(&quot;[%d] MCU : &quot;, SystemTimeCount); for(uint16_t i=0; i&lt;sizeof(Pro_M2W_ReturnInfoStruct); i++) { printf(&quot;%2x &quot;, *((uint8_t *)&amp;Pro_M2W_ReturnInfoStruct + i)); } printf(&quot;\r\n&quot;); #endif } 其中涉及的到结构体Pro_M2W_ReturnInfoTypeDef如下: __packed typedef struct { Pro_HeadPartTypeDef Pro_HeadPart;//2B uint8_t Pro_ver[8]; uint8_t P0_ver[8]; uint8_t Hard_ver[8]; uint8_t Soft_ver[8]; uint8_t Product_Key[32]; uint16_t Binable_Time; uint8_t Sum; } Pro_M2W_ReturnInfoTypeDef Pro_HeadPartTypeDef如下： __packed typedef struct { uint8_t Head[2]; uint16_t Len; uint8_t Cmd; uint8_t SN; uint8_t Flags[2]; } Pro_HeadPartTypeDef; Pro_W2D_CommonCmdHandle()回复通用协议帧条件：Pro_W2D_P0_Cmd &amp;&amp; P0_W2D_Control_Devce_Action static void Pro_W2D_CommonCmdHandle(void) { memcpy(&amp;Pro_CommonCmdStruct, UART_HandleStruct.Message_Buf, sizeof(Pro_CommonCmdStruct)); Pro_CommonCmdStruct.Pro_HeadPart.Len = exchangeBytes(sizeof(Pro_CommonCmdTypeDef) - 4); Pro_CommonCmdStruct.Pro_HeadPart.Cmd = Pro_CommonCmdStruct.Pro_HeadPart.Cmd + 1; Pro_CommonCmdStruct.Sum = CheckSum((uint8_t *)&amp;Pro_CommonCmdStruct, sizeof(Pro_CommonCmdStruct)); Pro_UART_SendBuf((uint8_t *)&amp;Pro_CommonCmdStruct, sizeof(Pro_CommonCmdStruct), 0); #ifdef PROTOCOL_DEBUG printf(&quot;[%d] MCU : &quot;, SystemTimeCount); for(uint16_t i=0; i&lt;sizeof(Pro_CommonCmdStruct); i++) { printf(&quot;%2x &quot;, *((uint8_t *)&amp;Pro_CommonCmdStruct + i)); } printf(&quot;\r\n&quot;); #endif memset(&amp;Pro_CommonCmdStruct, 0, sizeof(Pro_CommonCmdStruct)); } 协议通用数据帧 _packed typedef struct { Pro_HeadPartTypeDef Pro_HeadPart; uint8_t Sum; } Pro_CommonCmdTypeDef; Pro_W2D_ReadDevStatusHandle()读取设备状态条件：Pro_W2D_P0_Cmd &amp;&amp; P0_W2D_ReadDevStatus_Action函数中调用Pro_D2W_ReportDevStatusHandle() static void Pro_D2W_ReportDevStatusHandle(void) { Pro_HeadPartP0CmdTypeDef *Pro_HeadPartP0Cmd = (Pro_HeadPartP0CmdTypeDef *)g_DevStatus; memcpy(Pro_HeadPartP0Cmd, UART_HandleStruct.Message_Buf, sizeof(Pro_HeadPartTypeDef)); Pro_HeadPartP0Cmd-&gt;Pro_HeadPart.Cmd = Pro_D2W_P0_Ack_Cmd; Pro_HeadPartP0Cmd-&gt;Pro_HeadPart.Len = exchangeBytes((sizeof(Pro_HeadPartP0CmdTypeDef)+g_P0DataLen+1) - 4); Pro_HeadPartP0Cmd-&gt;Action = P0_D2W_ReadDevStatus_Action_ACK; g_DevStatus[sizeof(Pro_HeadPartP0CmdTypeDef)+g_P0DataLen] = CheckSum(g_DevStatus, sizeof(Pro_HeadPartP0CmdTypeDef)+g_P0DataLen+1); Pro_UART_SendBuf((uint8_t *)Pro_HeadPartP0Cmd, sizeof(Pro_HeadPartP0CmdTypeDef)+g_P0DataLen+1, 0); #ifdef PROTOCOL_DEBUG printf(&quot;[%d] MCU : &quot;, SystemTimeCount); for(uint16_t i=0; i&lt;(sizeof(Pro_HeadPartP0CmdTypeDef)+g_P0DataLen+1); i++) { printf(&quot;%2x &quot;, *((uint8_t *)Pro_HeadPartP0Cmd + i)); } printf(&quot;\r\n&quot;); #endif } 其中P0报文标准头结构Pro_HeadPartP0Cmd __packed typedef struct { Pro_HeadPartTypeDef Pro_HeadPart; P0_ActionTypeDef Action; } Pro_HeadPartP0CmdTypeDef; Pro_W2D_WifiStatusHandle()条件：case Pro_W2D_ReportWifiStatus_Cmdwifi状态处理函数 void (*callBackFunc)(uint16_t); static void Pro_W2D_WifiStatusHandle(void) { memcpy(&amp;Pro_W2D_WifiStatusStruct, UART_HandleStruct.Message_Buf, sizeof(Pro_W2D_WifiStatusStruct)); Pro_W2D_CommonCmdHandle(); callBackFunc = GizWits_WiFiStatueHandle; (*callBackFunc)(exchangeBytes(Pro_W2D_WifiStatusStruct.Wifi_Status)); } Pr0_W2D_RequestResetDeviceHandle()请求复位设备条件：case Pro_W2D_ReportMCUReset_Cmd void Pr0_W2D_RequestResetDeviceHandle(void) { Pro_W2D_CommonCmdHandle(); uint32_t timeDelay = SystemTimeCount; /*Wait 600ms*/ while((SystemTimeCount - timeDelay) &lt;= 600); printf(&quot;W2D_RequestResetDevice...\r\n&quot;); printf(&quot;MCU Restart...\r\n&quot;); /****************************MCU RESTART****************************/ __set_FAULTMASK(1); NVIC_SystemReset(); /******************************************************************************/ } GizWits_ControlDeviceHandle()设备控制处理在GizWits_MessageHandle()中的命令码解析中解析到P0_W2D_Control_Devce_Action，置P0标志p0Flag=1，执行设备控制处理函数 void GizWits_ControlDeviceHandle() { if( (WirteTypeDef.Attr_Flags &amp; (1&lt;&lt;0)) == (1&lt;&lt;0)) { if(Set_LedStatus != 1) { //根据wifi写入命令执行相应动作 if(WirteTypeDef.LED_Cmd == LED_OnOff)//灯灭命令 { LED_RGB_Control(0,0,0);//控制灯灭 ReadTypeDef.LED_Cmd = LED_OnOff;//将该命令赋值到wifi读取命令中 printf(&quot;SetLED_Off \r\n&quot;); } if(WirteTypeDef.LED_Cmd == LED_OnOn) { ReadTypeDef.LED_Cmd = LED_OnOn;//灯亮 LED_RGB_Control(254,0,0); printf(&quot;SetLED_On \r\n&quot;); } } } if( (WirteTypeDef.Attr_Flags &amp; (1&lt;&lt;1)) == (1&lt;&lt;1)) { if(WirteTypeDef.LED_Cmd == LED_Costom) { ReadTypeDef.LED_Cmd = LED_Costom; ReadTypeDef.LED_R = 0; ReadTypeDef.LED_G = 0; ReadTypeDef.LED_B = 0; Set_LedStatus = 0; LED_RGB_Control(0, 0, 0); printf(&quot;SetLED LED_Costom \r\n&quot;); } if(WirteTypeDef.LED_Cmd == LED_Yellow) { Set_LedStatus = 1; ReadTypeDef.LED_Cmd = LED_Yellow; ReadTypeDef.LED_R = 254; ReadTypeDef.LED_G = 254; ReadTypeDef.LED_B = 0; LED_RGB_Control(254, 254, 0); printf(&quot;SetLED LED_Yellow \r\n&quot;); } if(WirteTypeDef.LED_Cmd == LED_Purple) { ReadTypeDef.LED_Cmd = LED_Purple; ReadTypeDef.LED_R = 254; ReadTypeDef.LED_G = 0; ReadTypeDef.LED_B = 70; Set_LedStatus = 1; LED_RGB_Control(254, 0, 70); printf(&quot;SetLED LED_Purple \r\n&quot;); } if(WirteTypeDef.LED_Cmd == LED_Pink) { ReadTypeDef.LED_Cmd = LED_Pink; ReadTypeDef.LED_R = 238; ReadTypeDef.LED_G = 30; ReadTypeDef.LED_B = 30; Set_LedStatus = 1; LED_RGB_Control(238 ,30 ,30); printf(&quot;SetLED LED_Pink \r\n&quot;); } } if( (WirteTypeDef.Attr_Flags &amp; (1&lt;&lt;2)) == (1&lt;&lt;2)) { if(Set_LedStatus != 1) { ReadTypeDef.LED_R = WirteTypeDef.LED_R; printf(&quot;W2D Control LED_R = %d \r\n&quot;,WirteTypeDef.LED_R); LED_RGB_Control(ReadTypeDef.LED_R,ReadTypeDef.LED_G,ReadTypeDef.LED_B); } } if( (WirteTypeDef.Attr_Flags &amp; (1&lt;&lt;3)) == (1&lt;&lt;3)) { if(Set_LedStatus != 1) { ReadTypeDef.LED_G = WirteTypeDef.LED_G; printf(&quot;W2D Control LED_G = %d \r\n&quot;,WirteTypeDef.LED_G); LED_RGB_Control(ReadTypeDef.LED_R,ReadTypeDef.LED_G,ReadTypeDef.LED_B); } } if( (WirteTypeDef.Attr_Flags &amp; (1&lt;&lt;4)) == (1&lt;&lt;4)) { if(Set_LedStatus != 1) { ReadTypeDef.LED_B = WirteTypeDef.LED_B; printf(&quot;W2D Control LED_B = %d \r\n&quot;,WirteTypeDef.LED_B); LED_RGB_Control(ReadTypeDef.LED_R,ReadTypeDef.LED_G,ReadTypeDef.LED_B); } } if( (WirteTypeDef.Attr_Flags &amp; (1&lt;&lt;5)) == (1&lt;&lt;5)) { ReadTypeDef.Motor = WirteTypeDef.Motor; #ifdef MOTOR_16 printf(&quot;W2D Control Motor = %d \r\n&quot;,exchangeBytes(WirteTypeDef.Motor)); Motor_status(exchangeBytes(WirteTypeDef.Motor)); #else printf(&quot;W2D Control Motor = %d \r\n&quot;,WirteTypeDef.Motor); Motor_status(WirteTypeDef.Motor); #endif } } 其中wifi写入的数据结构WirteTypeDef_t,传入消息处理GizWits_MessageHandle()的形参p0_control_buf复制到WirteTypeDef __packed typedef struct { uint8_t Attr_Flags; uint8_t LED_Cmd; uint8_t LED_R; uint8_t LED_G; uint8_t LED_B; MOTOR_T Motor; }WirteTypeDef_t; 其中wifi写入的数据结构readTypeDef_t __packed typedef struct { uint8_t LED_Cmd; uint8_t LED_R; uint8_t LED_G; uint8_t LED_B; MOTOR_T Motor; uint8_t Infrared; uint8_t Temperature; uint8_t Humidity; uint8_t Alert; uint8_t Fault; }ReadTypeDef_t; GizWits_DevStatusUpgrade（）设备状态更新 void GizWits_DevStatusUpgrade(uint8_t *P0_Buff, uint32_t Time, uint8_t flag) { uint8_t Report_Flag = 0; Pro_HeadPartP0CmdTypeDef *Pro_HeadPartP0Cmd = (Pro_HeadPartP0CmdTypeDef *)g_DevStatus; if(Wait_AckStruct.Flag == 1) { return; } if(flag == 1) { Report_Flag = 1; goto Report; } if((2 * 1000) &lt; (SystemTimeCount - Last_ReportTime)) { if(memcmp(g_DevStatus + sizeof(Pro_HeadPartP0CmdTypeDef), P0_Buff, g_P0DataLen) != 0) { Report_Flag = 1; } } if(Time &lt; (SystemTimeCount-Last_Report_10_Time)) { Report_Flag = 1; Last_Report_10_Time = SystemTimeCount; } Report: if(Report_Flag == 1) { memcpy(g_DevStatus + sizeof(Pro_HeadPartP0CmdTypeDef), P0_Buff, g_P0DataLen); Pro_HeadPartP0Cmd-&gt;Pro_HeadPart.Len = exchangeBytes(sizeof(Pro_HeadPartP0CmdTypeDef) + 1 + g_P0DataLen - 4); Pro_HeadPartP0Cmd-&gt;Pro_HeadPart.Cmd = Pro_D2W_P0_Cmd; Pro_HeadPartP0Cmd-&gt;Pro_HeadPart.SN = SN++; Pro_HeadPartP0Cmd-&gt;Action = P0_D2W_ReportDevStatus_Action; g_DevStatus[sizeof(Pro_HeadPartP0CmdTypeDef) + g_P0DataLen] = CheckSum(g_DevStatus, sizeof(Pro_HeadPartP0CmdTypeDef) + g_P0DataLen + 1); Pro_UART_SendBuf((uint8_t *)Pro_HeadPartP0Cmd, sizeof(Pro_HeadPartP0CmdTypeDef) + g_P0DataLen + 1, 1);//×¢£º×îºóÒ»ÏîÎªÖ÷¶¯ÉÏ±¨Ê±ÖÃÎª1 ÊÊÓÃÓÚÐ­Òé4.3¡¢4.4¡¢4.9 Last_ReportTime = SystemTimeCount; #ifdef DEBUG printf(&quot;Report Sensor Data \r\n&quot;); #endif #ifdef PROTOCOL_DEBUG printf(&quot;[%d] MCU : &quot;, SystemTimeCount); for(uint16_t i = 0; i &lt; (sizeof(Pro_HeadPartP0CmdTypeDef) + g_P0DataLen + 1); i++) { printf(&quot;%2x &quot;, g_DevStatus[i]); } printf(&quot;\r\n&quot;); #endif } return; } GizWits_GatherSensorData()获取传感器数据 void GizWits_GatherSensorData(void) { ReadTypeDef.Infrared = IR_Handle(); DHT11_Read_Data(&amp;curTem, &amp;curHum); ReadTypeDef.Temperature = (curTem + lastTem) /2; ReadTypeDef.Humidity = (curHum + lastHum)/2; ReadTypeDef.Temperature = ReadTypeDef.Temperature + 13;//Temperature Data Correction lastTem = curTem; lastHum = curHum; }]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Hexo+Github搭建个人博客（二）]]></title>
      <url>%2F2017%2F03%2F29%2Fhexo-github-two%2F</url>
      <content type="text"><![CDATA[安装NEXT主题下载主题Hexo 安装主题的方式非常简单，只需要将主题文件拷贝至站点目录的 themes 目录下， 然后修改下配置文件即可。&gt; cd bloggit clone https://github.com/iissnan/hexo-theme-next themes/next 启用next主题在站点配置文件_config.yml中： theme: next 验证主题 hexo shttp://localhost:4000 NEXT主题设置Hexo 中有两份主要的配置文件，其名称都是 _config.yml 。其中，一份位于站点根目录下，主要包含 Hexo 本身的配置；另一份位于主题目录下，主要用于配置主题相关的选项。前者称为 站点配置文件，后者称为 主题配置文件 基本设置关于NEXT主题的基本设置可参考NEXT在线文档，包含NEXT主题的详细使用介绍。 其他设置添加High一下打开博客根目录 \themes\next\layout\_partials\header.swig ，在&lt;ul&gt; ... /ul&gt; 标签之间加入以下代码：&lt;li&gt; &lt;a title="把这个链接拖到你的Chrome收藏夹工具栏中" href='javascript:(function() &#123; function c() &#123; var e = document.createElement("link"); e.setAttribute("type", "text/css"); e.setAttribute("rel", "stylesheet"); e.setAttribute("href", f); e.setAttribute("class", l); document.body.appendChild(e) &#125; function h() &#123; var e = document.getElementsByClassName(l); for (var t = 0; t &lt; e.length; t++) &#123; document.body.removeChild(e[t]) &#125; &#125; function p() &#123; var e = document.createElement("div"); e.setAttribute("class", a); document.body.appendChild(e); setTimeout(function() &#123; document.body.removeChild(e) &#125;, 100) &#125; function d(e) &#123; return &#123; height : e.offsetHeight, width : e.offsetWidth &#125; &#125; function v(i) &#123; var s = d(i); return s.height &gt; e &amp;&amp; s.height &lt; n &amp;&amp; s.width &gt; t &amp;&amp; s.width &lt; r &#125; function m(e) &#123; var t = e; var n = 0; while (!!t) &#123; n += t.offsetTop; t = t.offsetParent &#125; return n &#125; function g() &#123; var e = document.documentElement; if (!!window.innerWidth) &#123; return window.innerHeight &#125; else if (e &amp;&amp; !isNaN(e.clientHeight)) &#123; return e.clientHeight &#125; return 0 &#125; function y() &#123; if (window.pageYOffset) &#123; return window.pageYOffset &#125; return Math.max(document.documentElement.scrollTop, document.body.scrollTop) &#125; function E(e) &#123; var t = m(e); return t &gt;= w &amp;&amp; t &lt;= b + w &#125; function S() &#123; var e = document.createElement("audio"); e.setAttribute("class", l); e.src = i; e.loop = false; e.addEventListener("canplay", function() &#123; setTimeout(function() &#123; x(k) &#125;, 500); setTimeout(function() &#123; N(); p(); for (var e = 0; e &lt; O.length; e++) &#123; T(O[e]) &#125; &#125;, 15500) &#125;, true); e.addEventListener("ended", function() &#123; N(); h() &#125;, true); e.innerHTML = " &lt;p&gt;If you are reading this, it is because your browser does not support the audio element. We recommend that you get a new browser.&lt;/p&gt; &lt;p&gt;"; document.body.appendChild(e); e.play() &#125; function x(e) &#123; e.className += " " + s + " " + o &#125; function T(e) &#123; e.className += " " + s + " " + u[Math.floor(Math.random() * u.length)] &#125; function N() &#123; var e = document.getElementsByClassName(s); var t = new RegExp("\\b" + s + "\\b"); for (var n = 0; n &lt; e.length; ) &#123; e[n].className = e[n].className.replace(t, "") &#125; &#125; var e = 30; var t = 30; var n = 350; var r = 350; var i = "//7xuupy.com1.z0.glb.clouddn.com/tongxingSibel%20-%20Im%20Sorry.mp3"; var s = "mw-harlem_shake_me"; var o = "im_first"; var u = ["im_drunk", "im_baked", "im_trippin", "im_blown"]; var a = "mw-strobe_light"; var f = "//s3.amazonaws.com/moovweb-marketing/playground/harlem-shake-style.css"; var l = "mw_added_css"; var b = g(); var w = y(); var C = document.getElementsByTagName("*"); var k = null; for (var L = 0; L &lt; C.length; L++) &#123; var A = C[L]; if (v(A)) &#123; if (E(A)) &#123; k = A; break &#125; &#125; &#125; if (A === null) &#123; console.warn("Could not find a node of the right size. Please try a different page."); return &#125; c(); S(); var O = []; for (var L = 0; L &lt; C.length; L++) &#123; var A = C[L]; if (v(A)) &#123; O.push(A) &#125; &#125; &#125;)() '&gt;High一下&lt;/a&gt; &lt;/li&gt; 添加最近访客 在主题配置文件中menu项添加guestbook菜单 在Hexo的source文件夹下，利用hexo new page guestbook创建guestbook页面,对应的index文件中添加如下代码：最近访客 &lt;div class=&quot;ds-recent-visitors&quot; data-num-items=&quot;39&quot; data-avatar-size=&quot;40&quot; id=&quot;ds-recent-visitors&quot;&gt;&lt;/div&gt; 修改文章内链接文本样式将链接文本设置为蓝色，鼠标划过时文字颜色加深，并显示下划线。找到文件 themes\next\source\css\_custom\custom.styl ，添加如下 css 样式：.post-body p a &#123; color: #0593d3; border-bottom: none; &amp;:hover &#123; color: #0477ab; text-decoration: underline; &#125;&#125; 给 Github 添加 README默认情况下，Github中每一个项目，我们希望有一份 README.md 的文件来作为项目的说明，但是我们在项目根目录下的 blog\source 目录下创建一份 README.md 文件，写好说明介绍，部署的时候，这个 README.md 会被 hexo 解析掉，而不会被解析到 Github 中去的。正确的解决方法其实很简单： 把 README.md 文件的后缀名改成 “MDOWN” 然后扔到blog/source文件夹下即可，这样 hexo 不会解析，Github 也会将其作为 MD 文件解析。 插入网易云音乐如果只加入单曲，只需要搜索歌曲，点开歌曲名，点击生成外链播放器，复制html代码将html代码无需任何修改放入markdown文章里就OK了。 如果想要加入歌单，就需要自己创建歌单，然后分享歌单，找到自己的分享动态，点进去可以看到有“生成外链播放器”这些字眼，其余操作就和上面一样了。 参考Never_yu’s Blog]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Hexo+github搭建个人博客（一）]]></title>
      <url>%2F2017%2F03%2F29%2Fhexo-github-one%2F</url>
      <content type="text"><![CDATA[简介Hexo 是一个快速、简洁且高效的静态站点生成框架，它基于 Node.js 。 它有以下特点： 超快速度：Node.js 所带来的超快生成速度，让上百个页面在几秒内瞬间完成渲染。 支持Markdown：Hexo 支持 GitHub Flavored Markdown 的所有功能，甚至可以整合 Octopress 的大多数插件。 一件部署：只需一条指令即可部署到Github Pages，或其他网站 丰富的插件：Hexo 拥有强大的插件系统，安装插件可以让 Hexo 支持 Jade,CoffeeScript。 安装准备工作安装 Hexo 相当简单。然而在安装前，您必须检查电脑中是否已安装下列应用程序: Node.jsGit 安装 Git Windows： git下载地址： 官网Download Now 安装：在Git Setup中选择Use Git from the windows Command Prompt,除此之外一路Next完成安装 安装 Node.js Windos:Node.js v0.12.5 x64 :下载地址： 百度云Download Now Node.js官网Download Now 安装：一路NExt即可，等待完成安装 ##软件验证运行窗口CMD,输入一下命令，会显示相应版本信息： git --version node -v npm -v申请GITHUB申请地址：Github方法简述： 申请账号（用户名+密码),并进行邮箱验证 创建repository，名字与用户名一致。例如我的用户名BlueSky-chamo,Repository name为BlueSky-chamo.github.io 在创建的repository中settings中的Github pages中选择theme,启用Github page## 安装 Hexohexo是基于node.js的静态博客，官网也是搭建在GitHub上安装方法： 新建文件夹blog,右键选择Git Bash 安装hexo为了避免出现被“墙”，使用淘宝NPM镜像npm install -g cnpm --registry=https://registry.npm.taobao.org 安装hexo:cnpm install -g hexo-clicnpm install hexo --save 验证：hexo -v 本地运行：初始化命令：hexo init安装生成器：cnpm install浏览器本地访问：hexo s,本地浏览器输入http://localhost:4000/即可本地访问 hexo基本管理目录结构.├── _config.yml├── package.json├── scaffolds├── source| ├── _drafts| └── _posts└── _config.yml：站点配置文件，即博客基本设置source:资源文件，即自定义的页面与推送的博客文件 ###_config.yml文件关键配置： url: 博客地址，与github申请的repository一致 如：http://BlueSky-chamo.github.io theme: 博客主题。默认下为landscape deploy: 发布设置。两种方式如下，可自行选择repository: https://github.com/BlueSky-chamo/BlueSky-chamo.github.io.gitrepository: git@github.com:BlueSky-chamo/BlueSky-chamo.github.io.git source文件资源文件 新建文章hexo new &quot;hello&quot;2.新建页面hexo new page hello Github与hexo创建联系配置SSH KEY 生成SSH KEY：ssh-keygen -t rsa -C &quot;邮件地址@youremail.com&quot; 按提示输入密码后在C:\Documents and Settings\Administrator.ssh\id_rsa.pub文件的内容即为秘钥 登陆github系统，点击右上角的 Account Settings—&gt;SSH Public keys —&gt; add another public keys把你本地生成的密钥复制到里面（key文本框中） 设置git身份信息git config --global user.name &quot;你的用户名&quot;git config --global user.email &quot;你的邮箱&quot; 验证git信息SSH -T git@github.com 发布博客安装hexo git插件cnpm install hexo-deployer-git --save 发布更新博客hexo d -g ##参考零基础免费搭建个人博客]]></content>
    </entry>

    
  
  
</search>
