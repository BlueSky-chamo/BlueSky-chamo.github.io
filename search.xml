<?xml version="1.0" encoding="utf-8"?>
<search>
  
    
    <entry>
      <title></title>
      <url>%2F2017%2F07%2F22%2Fhexo%E9%85%8D%E7%BD%AE%2F</url>
      <content type="text"><![CDATA[title: hexo个人配置date: 2017-03-30categories: hexotags: [hexo] 实现fork me 点击这里 挑选自己喜欢的样式，并复制代码到 themes/next/layout/_layout.swig 文件中div class=”headband”下面，并把 href 改为你的github地址。 &lt;a href=&quot;https://github.com/you&quot;&gt;&lt;img style=&quot;position: absolute; top: 0; right: 0; border: 0;&quot; src=&quot;https://camo.githubusercontent.com/ a6677b08c955af8400f44c6298f40e7d19cc5b2d/68747470733a2f2f73332e616d617a6f6e6177732e636f6d2f6769746875622f726962626f6e732f666f726b6d655f72696768745f677261795f3664366436642e706e67&quot; alt=&quot;Fork me on GitHub&quot; data-canonical-src=&quot;https://s3.amazonaws.com/github/ribbons/forkme_right_gray_6d6d6d.png&quot;&gt;&lt;/a&gt; 添加RSS安装 Hexo 插件：(这个插件会放在 node_modules 这个文件夹里) npm install --save hexo-generator-feed 站点配置文件末尾添加： # Extensions ## Plugins: http://hexo.io/plugins/ plugins: hexo-generate-feed next主题配置文件添加： # Set rss to false to disable feed link. # Leave rss as empty to use site&apos;s feed link. # Set rss to specific value if you have burned your feed already. rss: /atom.xml 配置完之后运行： hexo g 重新生成一次，你会在 ./public 文件夹中看到 atom.xml 文件。然后启动服务器查看是否有效，之后再部署到 Github 中。 添加动态背景打开 next/layout/_layout.swig在 &lt; /body&gt;之前添加代码(注意不要放在&lt; /head&gt;的后面) &lt;!-- 背景动画 --&gt; &lt;script type=&quot;text/javascript&quot; src=&quot;/js/src/particle.js&quot;&gt;&lt;/script&gt; &lt;!-- 页面点击小红心 --&gt; &lt;script type=&quot;text/javascript&quot; src=&quot;/js/src/love.js&quot;&gt;&lt;/script&gt; 想设置动画线条颜色可改为： &lt;script type=&quot;text/javascript&quot; color=&quot;255,0,0&quot; opacity=&quot;0.3&quot; count=&quot;99&quot; src=&quot;/js/src/particle.js&quot;&gt;&lt;/script&gt; color ：线条颜色, 默认: ‘0,0,0’；三个数字分别为(R,G,B)opacity: 线条透明度（0~1）, 默认: 0.5count: 线条的总数量, 默认: 150zIndex: 背景的z-index属性，css属性用于控制所在层的位置, 默认: -1 文章底部的那个带#号的标签修改模板 /themes/next/layout/_macro/post.swig ，搜索 rel=”tag”&gt;# ，将 # 换成 文章末尾统一添加“本文结束”标记在路径 \themes\next\layout_macro 中新建 passage-end-tag.swig 文件,并添加以下内容： &lt;div&gt; {% if not is_index %} -------------本文结束感谢您的阅读------------- {% endif %} &lt;/div&gt; 接着打开 \themes\next\layout_macro\post.swig 文件，在 post-body 之后， post-footer 之前添加如下画红色部分代码（post-footer之前两个DIV）： &lt;div&gt; {% if not is_index %} {% include 'passage-end-tag.swig' %} {% endif %} &lt;/div&gt; 在主题配置文件 _config.yml 中添加以下字段开启此功能： # 文章末尾添加“本文结束”标记 passage_end_tag: enabled: true 修改作者头像并旋转打开 \themes\next\source\css_common\components\sidebar\sidebar-author.styl ，在里面添加如下代码： .site-author-image { display: block; margin: 0 auto; padding: $site-author-image-padding; max-width: $site-author-image-width; height: $site-author-image-height; border: $site-author-image-border-width solid $site-author-image-border-color; /* 头像圆形 */ border-radius: 80px; -webkit-border-radius: 80px; -moz-border-radius: 80px; box-shadow: inset 0 -1px 0 #333sf; /* 设置循环动画 [animation: (play)动画名称 (2s)动画播放时长单位秒或微秒 (ase-out)动画播放的速度曲线为以低速结束 (1s)等待1秒然后开始动画 (1)动画播放次数(infinite为循环播放) ]*/ /* 鼠标经过头像旋转360度 */ -webkit-transition: -webkit-transform 1.0s ease-out; -moz-transition: -moz-transform 1.0s ease-out; transition: transform 1.0s ease-out; } img:hover { /* 鼠标经过停止头像旋转 -webkit-animation-play-state:paused; animation-play-state:paused;*/ /* 鼠标经过头像旋转360度 */ -webkit-transform: rotateZ(360deg); -moz-transform: rotateZ(360deg); transform: rotateZ(360deg); } /* Z 轴旋转动画 */ @-webkit-keyframes play { 0% { -webkit-transform: rotateZ(0deg); } 100% { -webkit-transform: rotateZ(-360deg); } } @-moz-keyframes play { 0% { -moz-transform: rotateZ(0deg); } 100% { -moz-transform: rotateZ(-360deg); } } @keyframes play { 0% { transform: rotateZ(0deg); } 100% { transform: rotateZ(-360deg); } } 作者头像变成圆形打开自定义CSS： \themes\next\source\css_custom\custom.styl 加入 .site-author-image { border-radius: 100%; padding: 2px; border: 2px dashed #fff; animation: cycle 2s 0.5s forwards; transition: border-radius 2s; } 博主名字号大小,也在 custom.styl 文件: .site-author-name { font-size: 16px; } 网站底部加上访问量打开 \themes\next\layout_partials\footer.swig 文件,在copyright前加上 然后在该文件添加显示统计的代码： &lt;div class=&quot;powered-by&quot;&gt; &lt;i class=&quot;fa fa-user-md&quot;&gt;&lt;/i&gt;&lt;span id=&quot;busuanzi_container_site_uv&quot;&gt; 本站访客数:&lt;span id=&quot;busuanzi_value_site_uv&quot;&gt;&lt;/span&gt; &lt;/span&gt; &lt;/div&gt; footer.swig完整代码 &lt;script async src=&quot;https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js&quot;&gt;&lt;/script&gt; &lt;div class=&quot;copyright&quot; &gt; {% set current = date(Date.now(), "YYYY") %} &amp;copy; {% if theme.since and theme.since != current %} {{ theme.since }} - {% endif %} {{ current }} {{ config.author }} {% if theme.copyright %} 本站访客数: {{ __('footer.powered', 'Hexo') }} {{ __('footer.theme') }} - NexT.{{ theme.scheme }} {% endif %} 在这里有两中不同计算方式的统计代码： pv的方式，单个用户连续点击n篇文章，记录n次访问量 &lt;span id=&quot;busuanzi_container_site_pv&quot;&gt; 本站总访问量&lt;span id=&quot;busuanzi_value_site_pv&quot;&gt;&lt;/span&gt;次 &lt;/span&gt; uv的方式，单个用户连续点击n篇文章，只记录1次访客数 &lt;span id=&quot;busuanzi_container_site_uv&quot;&gt; 本站总访问量&lt;span id=&quot;busuanzi_value_site_uv&quot;&gt;&lt;/span&gt;次 &lt;/span&gt; 添加热度主题配置文件 leancloud_visitors: enable: true next主题集成 leanCloud ，打开 /themes/next/layout/_macro/post.swig ,在画红线的区域添加 ℃ ： {% if theme.leancloud_visitors.enable %} | {% if theme.post_meta.item_text %} {{__('post.visitors')}} {% endif %} &lt;span class=&quot;leancloud-visitors-count&quot;&gt;&lt;/span&gt; &lt;span&gt;℃&lt;/span&gt; &lt;/span&gt; {% endif %} 然后打开/themes/next/languages/zh-Hans.yml 更改如下: visitors: 热度 网站底部字数统计切换到根目录下，然后运行如下代码 npm install hexo-wordcount --save 然后在 /themes/next/layout/_partials/footer.swig 文件尾部加上： &lt;div class=&quot;theme-info&quot;&gt; &lt;div class=&quot;powered-by&quot;&gt;&lt;/div&gt; &lt;span class=&quot;post-count&quot;&gt;博客全站共{{ totalcount(site) }}字&lt;/span&gt; &lt;/div&gt; 设置网站的图标Favicon在EasyIcon 中找一张（32*32）的 ico 图标,或者去别的网站下载或者制作，并将图标名称改为 favicon.ico ，然后把图标放在 /themes/next/source/images 里，并且修改主题配置文件： favicon: /favicon.ico 实现统计功能切换到根目录下，然后运行如下代码 npm install hexo-wordcount --save 主题配置文件： post_wordcount: item_text: true wordcount: true min2read: true 添加顶部加载条打开 /themes/next/layout/_partials/head.swig 文件，顶部加入： &lt;meta charset=&quot;UTF-8&quot;/&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot; /&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1, maximum-scale=1&quot;/&gt; &lt;script src=&quot;//cdn.bootcss.com/pace/1.0.2/pace.min.js&quot;&gt;&lt;/script&gt; &lt;link href=&quot;//cdn.bootcss.com/pace/1.0.2/themes/pink/pace-theme-flash.css&quot; rel=&quot;stylesheet&quot;&gt; &lt;style&gt; .pace .pace-progress { background: #1E92FB; /*进度条颜色*/ height: 3px; } .pace .pace-progress-inner { box-shadow: 0 0 10px #1E92FB, 0 0 5px #1E92FB; /*阴影颜色*/ } .pace .pace-activity { border-top-color: #1E92FB; /*上边框颜色*/ border-left-color: #1E92FB; /*左边框颜色*/ } &lt;/style&gt; 添加sitemap网站地图进入 hexo 根目录，打开 git npm install hexo-generator-sitemap --save npm install hexo-generator-baidu-sitemap --save hexo站点的_config.yml添加下面的代码 sitemap: path: sitemap.xml baidusitemap: path: baidusitemap.xml 主要参考Hexo-next主题个性化配置hexo的next主题个性化配置教程]]></content>
    </entry>

    
    <entry>
      <title></title>
      <url>%2F2017%2F07%2F22%2Fmarkdown%E8%AF%AD%E6%B3%95%2F</url>
      <content type="text"><![CDATA[title: markdown语法date: 2017-03-30categories: 软件工具tags: [markdown] #标题设置#第一种：通过在文字下方添加“=”和“-”，分别表示一级标题和二级标题。 第二种：在文字开头加上 “#”，通过“#”数量表示几级标题。 #块注释#文字开头添加“&gt;”表示块注释(&gt;和文字之间添加五个空格） 块注释 #引用#行首使用&gt;加上一个空格表示引用段落，内部可以嵌套多个引用。 引用 #斜体#设置为斜体的文字两端使用1个“*”或者“_”夹起来 #粗体#设置为粗体的文字两端使用2个“*”或者“_”夹起来 #无序列表#文字开头添加(, +, and -)实现无序列表。但是要注意在(, +, and -)和文字之间需要添加空格。例如： * 1 * 2 * 3 * 4 #有序列表#使用数字后面跟上英文句号，与文字间要有空格）。例如： 1. 首先 2. 其次 3. 然后 4. 最后 #链接#形式：方括号+括号方括号中为文字，括号中为链接地址 内联方式：This is an example link.引用方式：I get 10 times more traffic from Google than from Yahoo or MSN. #图片#图片的处理方式和链接的处理方式类似形式：感叹号+方括号+括号 ![name](url) #代码#方式1：简单文字出现一个代码框ESC下面~中的`，夹住代码 `#include &lt;stdio.h&gt;` 方式2：大片文字需要实现代码框使用Tab或四个空格 #include &lt;stdio.h&gt; #下划线#在空白行下方添加三条“-”横线 --- #换行#在文字的末尾使用两个或两个以上的空格来表示换行。 #分隔线#在一行中使用三个或三个以上的*、-或_可以添加分隔线，其中可以有空白，但是不能有其他字符。 *** --- ___ #表格#语法说明： Markdown 写的表格最终会被解析成 HTML 代码，如果使用的编辑器支持自定义 CSS，就能方便的调整样式。如果可以引入 JavaScript，样式自适应也能较好地实现。 基础概念 &lt;table&gt;: 表格 &lt;thead&gt;: table header 表头区 &lt;th&gt;: table headings 表头单元格内容 &lt;tbody&gt;: 表格内容区 &lt;tr&gt;: table row 表行 &lt;td&gt;: table data 单元格内容 基本样式 table { width: 100%; /*表格宽度*/ max-width: 65em; /*表格最大宽度，避免表格过宽*/ border: 1px solid #dedede; /*表格外边框设置*/ margin: 15px auto; /*外边距*/ border-collapse: collapse; /*使用单一线条的边框*/ empty-cells: show; /*单元格无内容依旧绘制边框*/ } table th, table td { height: 35px; /*统一每一行的默认高度*/ border: 1px solid #dedede; /*内部边框样式*/ padding: 0 10px; /*内边距*/ } 表头样式 table th { font-weight: bold; /*加粗*/ text-align: center !important; /*内容居中，加上 !important 避免被 Markdown 样式覆盖*/ background: rgba(158,188,226,0.2); /*背景色*/ } 隔行变色 使用选择器选取复数行设置背景色。一般 Markdown 表格编译后都有 &lt;tbody&gt; 包裹内容，那下面就相当于从表格第二行开始计数 table tbody tr:nth-child(2n) { background: rgba(158,188,226,0.12); } 悬浮变色 鼠标悬浮时该行改变背景色 table tr:hover { background: #efefef; } 表头不换行 设置表头单元格内容不换行，这样可以通过表头控制该列的最小宽度，避免浏览器窗口缩小时内容被压缩得太紧 table th { white-space: nowrap; /*表头内容强制在一行显示*/ } ##表格背景色## 方法说明颜色名称颜色 此处实现方法利用 CSDN-markdown 内嵌 html 语言的优势Hotpinkrgb(240, 248, 255) 借助 table, tr, td 等表格标签的 bgcolor 属性实现背景色设置AntiqueWhitergb(255, 192, 203) 方法说明颜色名称颜色 此处实现方法利用 CSDN-markdown 内嵌 html 语言的优势Hotpinkrgb(240, 248, 255) 借助 table, tr, td 等表格标签的 bgcolor 属性实现背景色设置AntiqueWhitergb(255, 192, 203) 颜色列表查看##字体字号## 我是黑体字 我是微软雅黑 我是华文彩云 color=#0099ff size=72 face=”黑体” color=#00ffff color=gray##跨行表格## 我占了三行 第一列 第二列 第三列 第一列 第二列 第三列 第一列 第二列 第三列 我占了三行 第一列 第二列 第三列 第一列 第二列 第三列 第一列 第二列 第三列 #参考文章#markdown的11中基本语法 markdown语法示例 markdown样式调整]]></content>
    </entry>

    
    <entry>
      <title></title>
      <url>%2F2017%2F07%2F22%2Fgit%E7%94%A8%E6%B3%95%E4%B9%8B%E5%88%9B%E5%BB%BA%E7%89%88%E6%9C%AC%E5%BA%93%2F</url>
      <content type="text"><![CDATA[title: git创建版本库date: 2017-03-30categories: hgithubtags: [github] #前言#版本库即repository，可以简单理解成一个目录，目录里面的所有文件都可以被Git管理起来，每个文件的修改、删除，Git都能跟踪，以便任何时刻都可以追踪历史，或者在将来某个时刻可以“还原”。 #创建版本库# ##版本库初始化## git init 目录下会产生.git的隐藏目录，是Git来跟踪管理版本库的。用ls -ah命令就可以看到该目录。 ##添加文件## git add filegit add只是将文件file暂存，这是提交文件之前的必要步骤。 ##查看状态## git statusgit status可查看版本库下是否有变更。 ##提交文件## git commit -m “日志消息”]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[回顾51单片机之enum用法]]></title>
      <url>%2F2017%2F04%2F21%2F%E5%9B%9E%E9%A1%BE%E5%8D%95%E7%89%87%E6%9C%BA%E4%B9%8Benum%E7%94%A8%E6%B3%95%2F</url>
      <content type="text"><![CDATA[前言在单片机工程中使用enum来替代define，增加代码的可读性 enum简介enum定义enum DAY { MON=1, TUE, WED, THU, FRI, SAT, SUN }; (1) 枚举型是一个集合，集合中的元素(枚举成员)是一些命名的整型常量，元素之间用逗号隔开。(2) DAY是一个标识符，可以看成这个集合的名字，是一个可选项，即是可有可无的项。(3) 第一个枚举成员的默认值为整型的0，后续枚举成员的值在前一个成员上加1。(4) 可以人为设定枚举成员的值，从而自定义某个范围内的整数。(5) 枚举型是预处理指令#define的替代。(6) 类型定义以分号结束。在实际使用中，更倾向于利用Typedef进行定义，定以后Day=enum DAY，方便枚举对象的声明与赋值 typedef enum DAY { MON=1, TUE, WED, THU, FRI, SAT, SUN }Day; enum变量声明与赋值以typedef为例: Day day=MON; 单片机应用实例在单片机工程中的Led.h头文件中，定义以下结构体表面led灯号 /************************************************************ ***结构体名称：Led_Num ***简述：led灯号结构体，表面属于哪个led *************************************************************/ typedef enum LedNum { LED_ALL=0, LED1=1, LED2=2, LED3=3, LED4=4, LED5=5, LED6=6, LED7=7, LED8=8 }Led_Num; /************************************************************ ***结构体名称：Led_Status ***简述：led灯状态，亮或熄灭 *************************************************************/ typedef enum LedStatus { OFF=0, ON=1 }Led_Status; 在Led.c源文件中，Led_ON_OFF()用来点亮或熄灭指定led灯，如下： /************************************************************** // 作者:chamo // 日期:2017-4-20 // 函数名:Led_ON_OFF // 功能:指定led灯亮熄 // 输入参数 // 参数1:led等号LedNum // 参数2:led状态 // 参数3:LedStatus，ON or OFF // 参数4: // 返回值:无 **************************************************************/ void Led_ON_OFF(int LedNum,int LedStatus) { switch(LedNum) { case LED_ALL: if(LedStatus) { GPIO_LED=GPIO_LED&amp;0x00; } else { GPIO_LED=GPIO_LED|0xFF; } break; case LED1: if(LedStatus) { GPIO_LED=GPIO_LED&amp;0xFE; } else { GPIO_LED=GPIO_LED|0x01; } break; case LED2: if(LedStatus) { GPIO_LED=GPIO_LED&amp;0xFD; } else { GPIO_LED=GPIO_LED|0x02; } break; case LED3: if(LedStatus) { GPIO_LED=GPIO_LED&amp;0xFB; } else { GPIO_LED=GPIO_LED|0x04; } break; case LED4: if(LedStatus) { GPIO_LED=GPIO_LED&amp;0xF7; } else { GPIO_LED=GPIO_LED|0x08; } break; case LED5: if(LedStatus) { GPIO_LED=GPIO_LED&amp;0xEF; } else { GPIO_LED=GPIO_LED|0x10; } break; case LED6: if(LedStatus) { GPIO_LED=GPIO_LED&amp;0xDF; } else { GPIO_LED=GPIO_LED|0x20; } break; case LED7: if(LedStatus) { GPIO_LED=GPIO_LED&amp;0xBF; } else { GPIO_LED=GPIO_LED|0x40; } break; case LED8: if(LedStatus) { GPIO_LED=GPIO_LED&amp;0x7F; } else { GPIO_LED=GPIO_LED|0x80; } break; } 在main.c中，调用led接口函数即可实现指定led的亮熄 #include &lt;stdio.h&gt; #include &quot;common.h&quot; #include &quot;Led.h&quot; int main() { Led_Num LedNum=LED1;//1号灯 Led_Status LedStatus=ON;//亮 Initial_Peripheral();//初始化外设 while(1) { Led_ON_OFF(LedNum,LedStatus); } return 0; } 总结enum与define比较enum:缺点：只能为整型值，不仅占用空间，还消耗cpu资源优点：多个相关值一组，程序更容易维护，代码更加清晰，范围内有效，不会和其他定义冲突 define:缺点：没有范围限制，全局有效，容易产生冲突优点：可为多种类型之，如字符串，整型，浮点型 在一般情况下尽量选择enum,增加代码的可读性和维护性。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[回顾51单片机之定时器简介]]></title>
      <url>%2F2017%2F04%2F21%2F%E5%9B%9E%E9%A1%BE%E5%8D%95%E7%89%87%E6%9C%BA%E4%B9%8B%E5%AE%9A%E6%97%B6%E5%99%A8%E7%AE%80%E4%BB%8B%2F</url>
      <content type="text"><![CDATA[时钟周期单片机外接晶振的振荡周期就是时钟周期。80C51单片机外接了一个11.0592M的晶体振荡器，单片机系统的时钟周期是1/11.0592M，周期是频率的倒数。51单片机时钟频率范围是1.MHZ-12MHZ，把一个时钟周期定义为一个节拍（P）,二个节拍定义为一个状态周期（S）。 机器周期单片机执行指令所消耗的最小时间单位。51单片机采用的CISC(复杂指令指令集)，各条指令执行的时间可能不一样，但是它们执行的时间必须是机器周期的整数倍。51系列单片机将一个机器周期划分为6个状态周期，即S1-S6，每个状态周期又由两个节拍组成，P1和P2，而P1=P2=时钟周期。因此，51单片机的机器周期=6个状态周期=12个时钟周期。这也就是经常说的51单片机的的时钟频率是晶振频率的12分频，或者是1/12。 指令周期指令周期执行某一条指令所消耗的时间，它等于机器周期的整数倍。指令不同，所需的机器周期数也不同。简单的单字节指令。在取指令周期中，指令取出到指令寄存器后立即译码执行；复杂的指令如转移指令，乘法指令，则需要两个或以上的机器周期。 定时器C51单片机内部设有两个16位的可编程定时器/计数器，分别由两个8位专用寄存器组成，即：T0由TH0和TL0构成；T1由TH1和TL1构成，其访问地址依次为8AH-8DH。此外，其内部还有一个8位的定时器方式寄存器TMOD和一个8位的定时控制寄存器TCON，TMOD主要是用于选定定时器的工作方式；TCON主要是用于控制定时器的启动停止，此外TCON还可以保存T0、T1的溢出和中断标志。当定时器工作在计数方式时，外部事件通过引脚T0（P3.4）和T1（P3.5）输入。 定时计数原理16位的定时器/计数器实质上就是一个加1计数器,当定时器/计数器为定时工作方式时，计数器的加1信号由振荡器的12分频信号产生，即每过一个机器周期，计数器加1，直至计满溢出为止。显然，定时器的定时时间与系统的振荡频率有关。因一个机器周期等于12个振荡周期，所以计数频率fcount=1/12osc。如果晶振为12MHz，则计数周期为： T=1/（12×106）Hz×1/12=1μs 当定时器/计数器为计数工作方式时，通过引脚T0和T1对外部信号计数，外部脉冲的下降沿将触发计数。计数器在每个机器周期的S5P2期间采样引脚输入电平。若一个机器周期采样值为1，下一个机器周期采样值为0，则计数器加1。此后的机器周期S3P1期间，新的计数值装入计数器。所以检测一个由1至0的跳变需要两个机器周期，故外部事件的最高计数频率为振荡频率的1/24。例如，如果选用12MHz晶振，则最高计数频率为0.5MHz。为了确保某给定电平在变化前至少被采样一次，外部计数脉冲的高电平与低电平保持时间均需在一个机器周期以上。 定时器/计数器方式寄存器TMOD定时器方式控制寄存器TMOD在特殊功能寄存器中，字节地址为89H，无位地址。 C／T：定时器／计数器选择位。C/T＝1，为计数器方式；C／T＝0，为定时器方式。 M1M0：工作方式选择位，定时器／计数器的4种工作方式由M1M0设定。 0 0 工作方式0 13位计数器 0 1 工作方式1 16位计数器 1 0 工作方式2 自动再装入8位计数器 1 1 工作方式3 定时器0：分成两个8位计数器，定时器1：停止计数 定时器/计数器控制寄存器TCON TCON在特殊功能寄存器中，字节地址为88H，位地址(由低位到高位)为88H一8FH TF1：定时器1溢出标志位。当字时器1计满溢出时，由硬件使TF1置“1”，并且申请中断。进入中断服务程序后，由硬件自动清“0”，在查询方式下用软件清“0”。 TR1：定时器1运行控制位。由软件清“0”关闭定时器1。当GATE=1，且INT1为高电平时，TR1置“1”启动定时器1；当GATE=0，TR1置“1”启动定时器1。 TF0：定时器0溢出标志。其功能及操作情况同TF1。 TR0：定时器0运行控制位。其功能及操作情况同TR1。 IE1：外部中断1请求标志。 IT1：外部中断1触发方式选择位。 IE0：外部中断0请求标志。 IT0：外部中断0触发方式选择位。 定时器初始化确定工作方式方式0：13位定时计数方式，最大计数值为2^13=8192,定时8192个机器周期。 方式1：16位定时计数方式，最大计数值为2^16=65536,定时65536个机器周期。此方式可实现最大的定时时间和最大计数次数。是最常用方式之一。 方式2：8位自动重装计数方式，最大计数值为2^8=256,定时256个机器周期。此方式工作时定时或计数到了不用重装初值，精度较高。另外在串口通讯时常用此方式。是最常用方式之一。 方式3：特殊工作方式。将定时器0分成两个8位功能不全的定时计数器，要占用T1部分功能。 定时器初值定时时间=（最大计数值-初值）X 晶振周期 X 12或 定时时间=（最大计数值-初值）X 机器周期 定时器寄存器为16为，分高8位TH0和低8位TL0,以8位为单位进行封装，将TH0装入初值N/256,低8位TL0装入初值N%256。即定时器初值计算公式为：TH0=(最大计数值M-初值N)/256TL0=(最大计数值M-初值N)%256 机器周期=12时钟周期，12MHZ晶振下，机器周期=1us,定时1s=1000000机器周期，初值=最大机器周期-初值机器周期 例如：10MS定时器初值的计算：1.晶振12M12MHz除12为1MHz，也就是说一秒=1000000次机器周期。10ms=10000次 机器周期。65536-10000=55536(d8f0)TH0=0xd8，TL0=0xf0 2.晶振11.0592M11.0592MHz除12为921600Hz，就是一秒921600次机器周期，10ms=9216次机器周期。65536-9216=56320(dc00)TH0=0xdc，TL0=0x00 启动定时器根据需要打开定时器中断，启动定时器。 EA = 1; //打开总中断 ET0 = 1; //定时器0中断 TR0 = 1; //打开定时器0]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[github创建本地仓库]]></title>
      <url>%2F2017%2F04%2F12%2Fgithub%E5%88%9B%E5%BB%BA%E6%9C%AC%E5%9C%B0%E4%BB%93%E5%BA%93%2F</url>
      <content type="text"><![CDATA[创建远程仓库在github上创建新仓库new repository,取名为Demo。勾选Initialize this repository with a README，可以省略本地创建README的步骤。 创建本地仓库新建文件夹后右键选择git bash here,进入git控制台 配置git创建ssh keyssh-keygen -t rsa -C &quot;your_email@youremail.com&quot; 之后会要求确认路径和输入密码，我们这使用默认的一路回车就行。成功的话会在c/Users/Administator下生成.ssh文件夹，打开id_rsa.pub，复制里面的key。回到github，进入Account Settings，左边选择SSH Keys，Add SSH Key,title随便填，粘贴key 验证ssh keyssh -T git@github.com 如出现You’ve successfully authenticated, but GitHub does not provide shell access ，则就表示已成功连上github。 关联本地仓库与远程仓库git config --global user.name &quot;your name&quot; git config --global user.email &quot;your_email@youremail.com&quot; git remote add origin https://github.com/yourName/yourRepo.git 后面的yourName和yourRepo表示你再github的用户名和刚才新建的仓库，加完之后进入.git，打开config，这里会多出一个remote “origin”内容，这就是刚才添加的远程地址，也可以直接修改config来配置远程地址。如果执行git remote add origin https://github.com/findingsea/myRepoForBlog.git，出现错误：fatal: remote origin already exists则执行以下语句： git remote rm origin 添加文件git add text.txt //添加指定文件 git add . //添加所有文件 提交文件git commit -m &quot;first add&quot; //提交，后面为当前提交说明 上传文件git push origin master //本地仓库推送到远程服务器。 在执行git push origin master时，报错：error:failed to push som refs to……. git pull origin master]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[linux下FTP配置]]></title>
      <url>%2F2017%2F03%2F30%2Flinux%E4%B8%8Bftp%E9%85%8D%E7%BD%AE%2F</url>
      <content type="text"><![CDATA[FTP原理文件传输协议（FTP）是一种传统的网络协议，主要功能是实现服务器端与客户端直接的文件传送。FTP以TCP封装包的模式进行服务器与客户的连接，当连接建立后，使用者可以通过客户端程序连接服务器端，并进行文件的下载和上传。此外，还可以直接管理用户在服务器上的文件。 FTP功能1）不同等级的使用者。FTP预设情况下提供三种主要的身份：实体账号（real user）访客（guest）匿名登入者（anonymous）分成三种身份可以提高主机管理的便利性。例如，实体用户可以进行的动作比较多，而匿名登入者仅提供一个下载功能。 2）命令记录与登入文件记录。FTP可以利用系统的syslogd进行数据的记录。记录的数据包括了使用者曾经下达的命令与使用者传输的数据的记录 3）限制或解除使用者所在的根目录。为了避免使用者进入到linux系统的其他目录。这有利于提高系统的安全性。 FTP的用户类型匿名用户（anonymous）：常说的匿名登录，ftp服务器支持匿名登录时通常当用户匿名访问可以使用ftp/anoymous这两个用户匿名登录。本地用户(Real user)：这类用户是指在FTP服务上拥有帐号，账号名称，密码信息存放在passwd,shadow文件中。当这类用户登录FTP服务器的时候，其默认的主目录就是其帐号命名的目录。但是，其还可以变更到其他目录中去。虚拟用户(Guest)：使用独立的账号/密码数据文件，只能够访问自己的主目录。服务器通过这种方式来保障FTP服务上其他文件的安全性。 安装VSFTPDsudo apt-get install vsftpd 配置VSFTPD/etc/vsftpd.conf:主要配置文件：关于主机的设置：connect_from_port_20=YES ftp-data启动主动联机的port 20listen_port=20 ftp访问端口dirmessage_enable=YES 当使用者进入某个目录时，会显示该目录需要注意的内容。显示的文件预设是.messagewrite_enable=YES 是否允许使用者具有写入的权限idle_session_timeout=600 空闲会话的超时限制。默认600s.空闲600s后自动断开连接data_connection_timeout=120 数据超时限制，默认120s。 实体用户登入者的配置：local_enable=YES 实体用户允许登入local_umask=022 用户的权限（把本该是777权限的文件夹改为了755）如果注释了该参数，该参数会启用默认权限掩码077，那么上传的文件权限将会变为600，文件夹权限变为700chroot_local_user=YES 是否将使用者限制在自己的主目录中chroot_list_enable=YES 是否启用将某些实体用户限制在主目录chroot_list_fiel=/etc/vsftpd.chroot_list 被限制的实体用户主目录路径 匿名用户登入的配置anonymous_enable=YES 允许匿名用户登入anon_upload_enable=YES 允许匿名用户上传anon_mkdir_write_enable=YES 允许匿名用户创建文件夹deny_email_file=/etc/vsftpd.banned_emails 被拒绝的email地址async_abor_enable=YES 是否认可异步的ABOR命令xferlog_enable=YES 是否记录上传及下载日志xferlog_fiel=/ver/log/vsftpd.log 上传和下载日志路径xferlog_std_format=YES 是否设定为wu ftp相同的登入格式nopriv_user=ftpsecure 以nobody作为此一服务执行者的权限，安全性较高pam_service_name=vsftpd pam模块的名称 /etc/pam.d/vsftpd:pam模块进行身份确认/etc/ftpusers:限制使用的ftp用户列表/usr/shin/vsftpd:vsftpd的主要执行文件 重启VSFTPDudo service vsftpd restart 匿名用户登入在/etc/vsftpd.conf中配置允许匿名用户登入 （一般不允许） 实体用户登入在/etc/vsftpd.conf中配置运行实体用户登入]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[linux下telnet远程登入]]></title>
      <url>%2F2017%2F03%2F30%2Flinux%E4%B8%8Btelnet%E8%BF%9C%E7%A8%8B%E7%99%BB%E5%85%A5%2F</url>
      <content type="text"><![CDATA[telnet原理当用Telnet登录进入远程计算机系统时，事实上启动了两个程序，一个 叫Telnet客户程序，它运行在你的本地机上；另一个叫Telnet服务器程序，它运行在你要登录的远程计算机上。本地机上的客户程序要完成如下功能：1 、建立与服务器的TCP 联接；2 、从键盘上接收你输入的字符；3 、把你输入的字符串变成标准格式并送给远程服务器；4 、从远程服务器接收输出的信息；5 、把该信息显示在你的屏幕上。 远程计算机的“服务”程序通常被称为“精灵”，它平时不声不响地候在远程计算机上，一接到你的请求，就马上活跃起来，并完成如下功能：1 、通知你的计算机，远程计算机已经准备好了；2 、等候你输入命令；3 、对你的命令作出反应（如显示目录内容，或执行某个程序等）；4 、把执行命令的结果送回给你的计算机；5 、重新等候你的命令。 客户机上装一个telnet的客户端，服务器上装一个telnet的监听程序（精灵），一般这个监听程序监听的是23号端口。把这个过程简单抽象一下，就是客户端使用telnet工具发送一个命令到服务器端，服务器端监听到了之后就调用系统相关API来执行这些命令，从而达到了客户机远程操作服务器主机的目的。 这里需要注意一点，“把你输入的字符串变成标准格式并送给远程服务器”，指的是接受的字符，要按照一定的协议格式传送到服务器端，而这些字符是通过TCP连接传输的，跟Http有点像。Http是通过TCP连接传输字符，但是数据格式是HTTP协议规定的格式。简单来说，所谓的HTTP协议，FTP协议，SMTP协议，就是各自规定了以什么样的数据包方式在网络上通过TCP管道传输数据。 其实，telnet是以TCP为基础与服务器进行通信，所以它的功能远不止远程登录服务器（远程操纵服务器）。不管是什么协议，如果它基于 tcp/ip，那么你使用 TcpClient（或者 Socket）连接它，然后发点信息，依然能连通。Telnet可以看作是一种TCP的连接工具。 安装telnet在Ubuntu下的telnet服务需要安装xinetd服务和telnetd服务 apt-get install xinetd apt-get install telnetd 配置telnet1.gedit /etc/inetd.conf没有则添加如下注释依次为：服务名称。和xinetd一样，inetd通过查询/etc/service获得该服务的相关信息。套接口类型。TCP用stream，UDP用dgram。该服务使用的通信日志相关参数协议。inetd是否等到守护进程结束才继续接管端口。wait表示等待（相当于xinetd的wait = yes），nowait表示不等待，inetd每次接到一个请求就启动守护进程的新副本（相当于xinetd的wait = no）。运行该守护进程的用户身份。守护进程二进制文件的完整路径及其命令行参数 2.gedit /etc/xinetd.conf注释：instances = 60：表示最大连接进程数为60个。log_type = SYSLOG daemon info：表示使用syslog进行服务登记。log_on_success= HOST PID：表示设置成功后记录客户机的IP地址的进程ID。log_on_failure = HOST：表示设置失败后记录客户机的IP地址。cps = 25 30：表示每秒25个入站连接，如果超过限制，则等待30秒。主要用于对付拒绝服务攻击。 3.gedit /etc/xinetd.d/telnet注释：disable = no：表示启用这个服务。socket_type = stream：表示服务的数据包类型为stream。wait = no：表示不需等待，即服务将以多线程的方式运行。user = root：表示执行此服务进程的用户是root。server = /usr/bin/in.telnetd：启动程序的位置。log_on_failure += USERID：表示设置失败时，在/etc/xinetd.conf中设置的default值基础之上还把UID添加到系统登记表 重启xinetd 查看telnet状态 telnet端口telnet端口默认23，一般不做修改，在/etc/services中查看，如果需要从其他端口启动该服务，则可收到配置 telnet远程登入使用putty进行telnet远程登入，默认端口是23，主机IP是linux下的IP地址，通过ifconfig查看。 备注xinetd 配置参数 日志相关参数]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[linux下VNC远程访问]]></title>
      <url>%2F2017%2F03%2F30%2Flinux%E4%B8%8Bvnc%E8%BF%9C%E7%A8%8B%E6%A1%8C%E9%9D%A2%E8%AE%BF%E9%97%AE%2F</url>
      <content type="text"><![CDATA[VNC远程桌面原理 vnc访问流程如下：1，vnc客户端通过浏览器或者vnc viewer 连接至vnc server2,vnc server 传送一个对话框至客户端，要求输入连接密码，以及存取的vnc server显示装置3，在客户端输入联机密码后，vnc server验证客户端是否具有存取权限。4，若是客户端通过vnc server的验证，客户端即要求vnc server显示桌面环境5，vnc server通过x xprotocol协议要求x server将画面显示控制权交给vnc server6，vnc server将来自x server的桌面环境利用vnc通信协议送至客户端，并且允许客户端控制vnc server的桌面环境及输入装置。 安装vncsudo apt-get install vnc4server 启动vncvncserver第一次启动时会提示输入密码注：创建一个指定会话号的vnc桌面vncserver :2 创建一个指定会话号为2的桌面 编辑启动脚本sudo gedit ~/.vnc/xstartup若有twm,则注释掉，添加如下 重启vnc结束之前的vnc线程vncserver -kill :1然后再启动vnc服务输入vncserver vnc viewer登入ifconfig查询linux的ip地址，ok后填入vncserver启动时设置的密码登入后发现只出现控制台界面，无法显示桌面将脚本中改为如下，关闭vncservervncserver -kill :1再重启vncserver]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[linux命令学习之文件压缩命令-gzip命令]]></title>
      <url>%2F2017%2F03%2F30%2Flinux%E5%91%BD%E4%BB%A4%E5%AD%A6%E4%B9%A0-%E6%96%87%E4%BB%B6%E5%8E%8B%E7%BC%A9%E4%B9%8Bgzip%E5%91%BD%E4%BB%A4%2F</url>
      <content type="text"><![CDATA[gzip简介 减少文件大小有两个明显的好处，一是可以减少存储空间，二是通过网络传输文件时，可以减少传输的时间。gzip是在Linux系统中经常使用的一个对文件进行压缩和解压缩的命令，既方便又好用。gzip不仅可以用来压缩大的、较少使用的文件以节省磁盘空间，还可以和tar命令一起构成Linux操作系统中比较流行的压缩文件格式。据统计，gzip命令对文本文件有60%～70%的压缩率。 命令学习命令格式：gzip[参数][文件或者目录]命令参数：-a或–ascii 使用ASCII文字模式。-c或–stdout或–to-stdout 把压缩后的文件输出到标准输出设备，不去更动原始文件。-d或–decompress或—-uncompress 解开压缩文件。-f或–force 强行压缩文件。不理会文件名称或硬连接是否存在以及该文件是否为符号连接。-h或–help 在线帮助。-l或–list 列出压缩文件的相关信息。-L或–license 显示版本与版权信息。-n或–no-name 压缩文件时，不保存原来的文件名称及时间戳记。-N或–name 压缩文件时，保存原来的文件名称及时间戳记。-q或–quiet 不显示警告信息。-r或–recursive 递归处理，将指定目录下的所有文件及子目录一并处理。-S&lt;压缩字尾字符串&gt;或—-suffix&lt;压缩字尾字符串&gt; 更改压缩字尾字符串。-t或–test 测试压缩文件是否正确无误。-v或–verbose 显示指令执行过程。-V或–version 显示版本信息。-num 用指定的数字num调整压缩的速度，-1或–fast表示最快压缩方法（低压缩比），-9或–best表示最慢压缩方法（高压缩比）。系统缺省值为6。 命令功能：gzip是个使用广泛的压缩程序，文件经它压缩过后，名称后面会多出”.gz”的扩展名。 常用范例例1：把test1目录下的每个文件压缩成.gz文件gzip *原文件会被打包，tar下-c选型会新建打包文件，原文件存在 例2：把每个压缩的文件解压，并列出详细的信息gzip -dv * 例3：详细显示每个压缩的文件的信息，并不解压gzip -l * 例4：压缩一个tar文件，此时压缩文件的扩展名为.tar.gzgzip -r log.tar 例5：递归的压缩目录gzip -rv test1test1下面的文件都变成了.gz，目录依然存在只是目录里面的文件相应变成了.gz. 例6：递归地解压目录gzip -dr test1]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[linux命令学习之文件打包解压命令-tar命令]]></title>
      <url>%2F2017%2F03%2F30%2Flinux%E5%91%BD%E4%BB%A4%E5%AD%A6%E4%B9%A0-%E6%96%87%E4%BB%B6%E6%89%93%E5%8C%85%E8%A7%A3%E5%8E%8B%E4%B9%8Btar%E5%91%BD%E4%BB%A4%2F</url>
      <content type="text"><![CDATA[tar简介tar命令可以为linux的文件和目录创建档案。利用tar，可以为某一特定文件创建档案（备份文件），也可以在档案中改变文件，或者向档案中加入新的文件。tar最初被用来在磁带上创建档案，现在，用户可以在任何设备上创建档案。利用tar命令，可以把一大堆的文件和目录全部打包成一个文件，这对于备份文件或将几个文件组合成为一个文件以便于网络传输是非常有用的。两个概念：打包和压缩。打包是指将一大堆文件或目录变成一个总的文件；压缩则是将一个大的文件通过一些压缩算法变成一个小文件。 Linux中很多压缩程序只能针对一个文件进行压缩，当你想要压缩一大堆文件时，得先将这一大堆文件先打成一个包（tar命令），然后再用压缩程序进行压缩（gzip bzip2命令）。linux下最常用的打包程序就是tar了，使用tar程序打出来的包我们常称为tar包，tar包文件的命令通常都是以.tar结尾的。生成tar包后，就可以用其它的程序来进行压缩。 命令学习命令格式：tar[必要参数][选择参数][文件]命令参数：必要参数有如下：-A 新增压缩文件到已存在的压缩-B 设置区块大小-c 建立新的压缩文件 -d 记录文件的差别-r 添加文件到已经压缩的文件-u 添加改变了和现有的文件到已经存在的压缩文件-x 从压缩的文件中提取文件 -t 显示压缩文件的内容-z 支持gzip解压文件-j 支持bzip2解压文件-Z 支持compress解压文件-v 显示操作过程-l 文件系统边界设置-k 保留原有文件不覆盖-m 保留文件不被覆盖-W 确认压缩文件的正确性 可选参数如下：-b 设置区块数目-C 切换到指定目录-f 指定压缩文件–help 显示帮助信息–version 显示版本信息 命令功能：用来压缩和解压文件。tar本身不具有压缩功能。他是调用压缩功能实现的 常见解压/压缩命令tar解包：tar xvf FileName.tar打包：tar cvf FileName.tar DirName（注：tar是打包，不是压缩！） .gz 解压1：gunzip FileName.gz解压2：gzip -d FileName.gz压缩：gzip FileName .tar.gz 和 .tgz解压：tar zxvf FileName.tar.gz压缩：tar zcvf FileName.tar.gz DirName .bz2解压1：bzip2 -d FileName.bz2解压2：bunzip2 FileName.bz2压缩： bzip2 -z FileName .tar.bz2解压：tar jxvf FileName.tar.bz2压缩：tar jcvf FileName.tar.bz2 DirName .bz解压1：bzip2 -d FileName.bz解压2：bunzip2 FileName.bz压缩：未知 .tar.bz解压：tar jxvf FileName.tar.bz压缩：未知 .Z解压：uncompress FileName.Z压缩：compress FileName .tar.Z解压：tar Zxvf FileName.tar.Z压缩：tar Zcvf FileName.tar.Z DirName .zip解压：unzip FileName.zip压缩：zip FileName.zip DirName .rar解压：rar x FileName.rar压缩：rar a FileName.rar DirName 常用范例例1：将文件全部打包成tar包tar -cvf log.tar log2012.logtar -zcvf log.tar.gz log2012.logtar -jcvf log.tar.bz2 log2012.logtar -cvf log.tar log2012.log 仅打包，不压缩！tar -zcvf log.tar.gz log2012.log 打包后，以 gzip 压缩tar -zcvf log.tar.bz2 log2012.log 打包后，以 bzip2 压缩在参数 f 之后的文件档名是自己取的，习惯上都用 .tar 来作为辨识。 如果加 z 参数，则 以 .tar.gz 或 .tgz 来代表 gzip 压缩过的 tar包； 如果加 j 参数，则以 .tar.bz2 来作为tar包名。 例2：查阅上述 tar包内有哪些文件tar -ztvf log.tar.gz由于使用 gzip 压缩的log.tar.gz，所以要查阅log.tar.gz包内的文件时，就得加上 z 这个参数。 例3：将tar 包解压缩tar -zxvf log.tar.gz 例4：只将 /tar 内的 部分文件解压出来tar -zxvf log.tar.gz 1.log 例5：文件备份下来，并且保存其权限(-p 的属性)tar -zcvpf log.tar.gz 1.log 2.log 3.log 例6：在 文件夹当中，比某个日期新的文件才备份tar -N “2012/11/13” -zcvf log.tar.gz test1 例7：备份文件夹内容是排除部分文件tar –exclude test1 -zcvf Test.tar.gz *除了test1外，其他都打包]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[linux命令学习之文件权限命令-chgrp命令]]></title>
      <url>%2F2017%2F03%2F30%2Flinux%E5%91%BD%E4%BB%A4%E5%AD%A6%E4%B9%A0-%E6%96%87%E4%BB%B6%E6%9D%83%E9%99%90%E4%B9%8Bchgrp%E5%91%BD%E4%BB%A4%2F</url>
      <content type="text"><![CDATA[chgrp简介 在lunix系统里，文件或目录的权限的掌控以拥有者及所属群组来管理。可以使用chgrp指令取变更文件与目录所属群组，这种方式采用群组名称或群组识别码都可以。Chgrp命令就是change group的缩写！要被改变的组名必须要在/etc/group文件内存在才行。 命令学习 命令格式：chgrp [选项] [组] [文件]命令功能：chgrp命令可采用群组名称或群组识别码的方式改变文件或目录的所属群组。使用权限是超级用户。命令参数：必要参数:-c 当发生改变时输出调试信息-f 不显示错误信息-R 处理指定目录以及其子目录下的所有文件-v 运行时显示详细的处理信息–dereference 作用于符号链接的指向，而不是符号链接本身–no-dereference 作用于符号链接本身选择参数:–reference=&lt;文件或者目录&gt;–help 显示帮助信息–version 显示版本信息 常用范例 例1：改变文件的群组属性chgrp -v test 1.log先建立test工作组，将1.log文件群组改为test群组例2：根据指定文件改变文件的群组属性chgrp –reference=1.log 2.log改变文件2.log 的群组属性，使得文件2.log的群组属性和参考文件1.log的群组属性相同例3：改变指定目录以及其子目录下的所有文件的群组属性chgrp -R test test1改变指定目录以及其子目录下的所有文件的群组属性 例4：通过群组识别码改变文件群组属性chgrp -R 1001 1.log通过群组识别码改变文件群组属性，1001为test群组的识别码，具体群组和群组识别码可以cat /etc/group查看]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[linux命令学习之文件目录命令-chown命令]]></title>
      <url>%2F2017%2F03%2F30%2Flinux%E5%91%BD%E4%BB%A4%E5%AD%A6%E4%B9%A0-%E6%96%87%E4%BB%B6%E6%9D%83%E9%99%90%E4%B9%8Bchown%E5%91%BD%E4%BB%A4%2F</url>
      <content type="text"><![CDATA[chown简介 chown将指定文件的拥有者改为指定的用户或组，用户可以是用户名或者用户ID；组可以是组名或者组ID； 文件是以空格分开的要改变权限的文件列表，支持通配符。系统管理员经常使用chown命令，在将文件拷贝到另一个用户的名录下之后，让用户拥有使用该文件的权限。 命令学习 命令格式： chown [选项] [所有者][:[组]] 文件… 命令功能：通过chown改变文件的拥有者和群组。在更改文件的所有者或所属群组时，可以使用用户名称和用户识别码设置。普通用户不能将自己的文件改变成其他的拥有者。其操作权限一般为管理员。 命令参数：必要参数:-c 显示更改的部分的信息-f 忽略错误信息-h 修复符号链接-R 处理指定目录以及其子目录下的所有文件-v 显示详细的处理信息-deference 作用于符号链接的指向，而不是链接文件本身 选择参数:–reference=&lt;目录或文件&gt; 把指定的目录/文件作为参考，把操作的文件/目录设置成参考文件/目录相同拥有者和群组–from=&lt;当前用户：当前群组&gt; 只有当前用户和群组跟指定的用户和群组相同时才进行改变–help 显示帮助信息–version 显示版本信息 常用范例 例1：改变拥有者和群组 chown root:jiangbiao 1.log当为root: 以及jiangbiao: 形式时，工作组默认与拥有者一样例3：改变文件群组 例4：改变指定目录以及其子目录下的所有文件的拥有者和群组chown -R -v root:test test1]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[linux命令学习之文件目录命令-chmod命令]]></title>
      <url>%2F2017%2F03%2F30%2Flinux%E5%91%BD%E4%BB%A4%E5%AD%A6%E4%B9%A0-%E6%96%87%E4%BB%B6%E6%9D%83%E9%99%90%E4%B9%8Bchmod%E5%91%BD%E4%BB%A4%2F</url>
      <content type="text"><![CDATA[chmod简介chmod命令用于改变linux系统文件或目录的访问权限。用它控制文件或目录的访问权限。该命令有两种用法。一种是包含字母和操作符表达式的文字设定法；另一种是包含数字的数字设定法。Linux系统中的每个文件和目录都有访问许可权限，用它来确定谁可以通过何种方式对文件和目录进行访问和操作。 文件或目录的访问权限分为只读，只写和可执行三种。以文件为例，只读权限表示只允许读其内容，而禁止对其做任何的更改操作。可执行权限表示允许将该文件作为一个程序执行。文件被创建时，文件所有者自动拥有对该文件的读、写和可执行权限，以便于对文件的阅读和修改。用户也可根据需要把访问权限设置为需要的任何组合。 有三种不同类型的用户可对文件或目录进行访问：文件所有者，同组用户、其他用户。所有者一般是文件的创建者。所有者可以允许同组用户有权访问文件，还可以将文件的访问权限赋予系统中的其他用户。在这种情况下，系统中每一位用户都能访问该用户拥有的文件或目录。 每一文件或目录的访问权限都有三组，每组用三位表示，分别为文件属主的读、写和执行权限；与属主同组的用户的读、写和执行权限；系统中其他用户的读、写和执行权限。当用ls -l命令显示文件或目录的详细信息时，最左边的一列为文件的访问权限列表的列定义如下：[权限属性信息] [连接数] [拥有者] [拥有者所属用户组] [大小] [最后修改时间] [文件名] 权限属性列表为10个字符：第一个字符表示文件类型，d为目录 -为普通文件 l为连接 b为可存储的接口设备 c为键盘鼠标等输入设备2、3、4个字符表示所有者权限，5、6、7个字符表示所有者同组用户权限，8、9、10为其他用户权限第二个字符表示所有者读权限，如果有权限则为r，没有权限则为-第三个字符表示所有者写权限，如果有权限则为w，没有权限则为-第四个字符表示所有者执行权限，如果有权限则为x，没有权限则为-第五个字符表示所有者同组用户读权限，如果有权限则为r，没有权限则为-第六个字符表示所有者同组用户写权限，如果有权限则为w，没有权限则为-第七个字符表示所有者同组用户执行权限，如果有权限则为x，没有权限则为-第八个字符表示其他非同组读权限，如果有权限则为r，没有权限则为-第九个字符表示其他非同组写权限，如果有权限则为w，没有权限则为-第十个字符表示其他非同组执行权限，如果有权限则为x，没有权限则为- 命令学习命令格式:chmod [-cfvR] [–help] [–version] mode file命令功能：用于改变文件或目录的访问权限，用它控制文件或目录的访问权限。命令参数：必要参数：-c 当发生改变时，报告处理信息-f 错误信息不输出-R 处理指定目录以及其子目录下的所有文件-v 运行时显示详细处理信息 选择参数：–reference=&lt;目录或者文件&gt; 设置成具有指定目录或者文件具有相同的权限–version 显示版本信息 &lt;权限范围&gt;+&lt;权限设置&gt; 使权限范围内的目录或者文件具有指定的权限&lt;权限范围&gt;-&lt;权限设置&gt; 删除权限范围的目录或者文件的指定权限 &lt;权限范围&gt;=&lt;权限设置&gt; 设置权限范围内的目录或者文件的权限为指定的值 权限范围：u ：目录或者文件的当前的用户g ：目录或者文件的当前的群组o ：除了目录或者文件的当前用户或群组之外的用户或者群组a ：所有的用户及群组 权限设置：r ：读权限，用数字4表示w ：写权限，用数字2表示x ：执行权限，用数字1表示- ：删除权限，用数字0表示s ：特殊权限 Linux 文件的基本属性有9个，分别是 owner/group/others组别的read/write/excute属性。该命令有两种用法。一种是包含字母和操作符表达式的文字设定法；另一种是包含数字的数字设定法。1）文字设定法:如果想把一个文件属性设置为 -rwxr-xr–，可以这样： chmod u=rwx,g=rx,o=r filename如果不知道文件的原先属性，但想增加其的每人均可写入的权限，可以这样：chmod a+w filename去掉所有人的x属性：chmod a-x filename2）数字设定法 数字表示：r:4 w:2 x:1例子：将同一组(owner/group/others)的3个属性(r/w/x)累加，如当前属性为[-rwxrwx—]，则是：owner=rwx=4+2+1=7group=rwx=4+2+1=7others= — =0+0+0=0该属性为770.chmod 777 filename 常用范例例1：增加文件所有用户组可执行权限chmod a+x 1.loga ：所有的用户及群组即：文件属主（u） 增加执行权限；与文件属主同组用户（g） 增加执行权限；其他用户（o） 增加执行权限 例2：同时修改不同用户权限chmod ug+r,o-w 2.log文件属主（u） 增加读权限;与文件属主同组用户（g） 增加读权限;其他用户（o） 删除写权限 例3：删除文件权限chmod a-r 2.log删除所有用户的读权限 例4：使用“=”设置权限chmod u=rwx,g=rwx,o=rwz 2.log撤销原来所有的权限，然后使其具有新的权限 例5：对一个目录及其子目录所有文件添加权限chmod -R u+x test1]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[linux命令学习之文件查找命令-locate命令]]></title>
      <url>%2F2017%2F03%2F30%2Flinux%E5%91%BD%E4%BB%A4%E5%AD%A6%E4%B9%A0-%E6%96%87%E4%BB%B6%E6%9F%A5%E6%89%BE%E4%B9%8Blocate%E5%91%BD%E4%BB%A4%2F</url>
      <content type="text"><![CDATA[locate简介locate让使用者可以很快速的搜寻档案系统内是否有指定的档案。其方法是先建立一个包括系统内所有档案名称及路径的数据库，之后当寻找时就只需查询这个数据库，而不必实际深入档案系统之中了。在一般的 distribution 之中，数据库的建立都被放在 crontab 中自动执行。 命令学习命令格式：Locate [选择参数] [样式] 命令功能：locate命令可以在搜寻数据库时快速找到档案，数据库由updatedb程序来更新，updatedb是由cron daemon周期性建立的，locate命令在搜寻数据库时比由整个由硬盘资料来搜寻资料来得快，但较差劲的是locate所找到的档案若是最近才建立或 刚更名的，可能会找不到，在内定值中，updatedb每天会跑一次，可以由修改crontab来更新设定值。(etc/crontab)locate指定用在搜寻符合条件的档案，它会去储存档案与目录名称的数据库内，寻找合乎范本样式条件的档案或目录录，可以使用特殊字元（如”” 或”?”等）来指定范本样式，如指定范本为kcpaner, locate会找出所有起始字串为kcpa且结尾为ner的档案或目录locate指令和find找寻档案的功能类似，但locate是透过update程序将硬盘中的所有档案和目录资料先建立一个索引数据库，在 执行loacte时直接找该索引，查询速度会较快，索引数据库一般是由操作系统管理，但也可以直接下达update强迫系统立即修改索引数据库。 命令参数：-e 将排除在寻找的范围之外。-1 如果是 1．则启动安全模式。在安全模式下，使用者不会看到权限无法看到的档案。这会使速度减慢，因为 locate 必须至实际的档案系统中取得档案的 权限资料。-f 将特定的档案系统排除在外，例如我们没有到理要把 proc 档案系统中的档案 放在资料库中。-q 安静模式，不会显示任何错误讯息。-n 至多显示 n个输出。-r 使用正规运算式 做寻找的条件。-o 指定资料库存的名称。-d 指定资料库的路径-h 显示辅助讯息-V 显示程式的版本讯息 常用范例例1:查找和pwd相关的所有文件locate pwd 例2： 搜索etc目录下所有以sh开头的文件locate /etc/sh 例3：搜索etc目录下，所有以m开头的文件locate /etc/m]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[linux命令学习之文件查找命令-whereis命令]]></title>
      <url>%2F2017%2F03%2F30%2Flinux%E5%91%BD%E4%BB%A4%E5%AD%A6%E4%B9%A0-%E6%96%87%E4%BB%B6%E6%9F%A5%E6%89%BE%E4%B9%8Bwhereis%E5%91%BD%E4%BB%A4%2F</url>
      <content type="text"><![CDATA[whereis简介whereis命令只能用于程序名的搜索，而且只搜索二进制文件（参数-b）、说明文件（参数-m）和源代码文件（参数-s）。如果省略参数，则返回所有信息。和find相比，whereis查找的速度非常快，这是因为linux系统会将 系统内的所有文件都记录在一个数据库文件中，当使用whereis和locate时，会从数据库中查找数据，而不是像find命令那样，通过遍历硬盘来查找，效率自然会很高。但是该数据库文件并不是实时更新，默认情况下时一星期更新一次，因此，我们在用whereis和locate 查找文件时，有时会找到已经被删除的数据，或者刚刚建立文件，却无法查找到，原因就是因为数据库文件没有被更新。 命令学习命令格式：whereis [-bmsu] [BMS 目录名 -f ] 文件名命令功能：whereis命令是定位可执行文件、源代码文件、帮助文件在文件系统中的位置。这些文件的属性应属于原始代码，二进制文件，或是帮助文件。whereis 程序还具有搜索源代码、指定备用搜索路径和搜索不寻常项的能力。命令参数：-b 定位可执行文件。-m 定位帮助文件。-s 定位源代码文件。-u 搜索默认路径下除可执行文件、源代码文件、帮助文件以外的其它文件-B 指定搜索可执行文件的路径。-M 指定搜索帮助文件的路径。-S 指定搜索源代码文件的路径。 常用范例例1:指令”whereis”查看指令”bash”的位置]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[linux命令学习之文件查找命令-which命令]]></title>
      <url>%2F2017%2F03%2F30%2Flinux%E5%91%BD%E4%BB%A4%E5%AD%A6%E4%B9%A0-%E6%96%87%E4%BB%B6%E6%9F%A5%E6%89%BE%E4%B9%8Bwhich%E5%91%BD%E4%BB%A4%2F</url>
      <content type="text"><![CDATA[which简介经常在linux要查找某个文件，但不知道放在哪里了，可以使用下面的一些命令来搜索： which 查看可执行文件的位置。 whereis 查看文件的位置。 locate 配合数据库查看文件位置。 find 实际搜寻硬盘查询文件名称。which命令在PATH变量指定的路径中，搜索某个系统命令的位置，并且返回第一个搜索结果。也就是说，使用which命令，就可以看到某个系统命令是否存在，以及执行的到底是哪一个位置的命令。 命令学习命令格式：which 可执行文件名称命令功能：which指令会在PATH变量指定的路径中，搜索某个系统命令的位置，并且返回第一个搜索结果。命令参数：-n 指定文件名长度，指定的长度必须大于或等于所有文件中最长的文件名。-p 与-n参数相同，但此处的包括了文件的路径。-w 指定输出时栏位的宽度。-V 显示版本信息 常用范例例1：查找文件、显示命令路径cd 是bash 内建的命令，但是 which 默认是找 PATH 内所规范的目录，所以找不到 查找有别名的命令时会列出具体的别名信息]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[linux命令学习之文件目录命令-cat命令]]></title>
      <url>%2F2017%2F03%2F30%2Flinux%E5%91%BD%E4%BB%A4%E5%AD%A6%E4%B9%A0-%E6%96%87%E4%BB%B6%E7%9B%AE%E5%BD%95%E4%B9%8Bcat%E5%91%BD%E4%BB%A4%2F</url>
      <content type="text"><![CDATA[cat简介cat命令的用途是连接文件或标准输入并打印。常用来显示文件内容，或者将几个文件连接起来显示，或者从标准输入读取内容并显示，它常与重定向符号配合使用。 命令学习命令格式：cat [选项] [文件]命令功能：1.一次显示整个文件:cat filename2.从键盘创建一个文件:cat &gt; filename 只能创建新文件,不能编辑已有文件.3.将几个文件合并为一个文件:cat file1 file2 &gt; file命令参数：-b, –number-nonblank 对非空输出行编号-E, –show-ends 在每行结束处显示 $-n, –number 对输出的所有行编号,由1开始对所有输出的行数编号-s, –squeeze-blank 有连续两行以上的空白行，就代换为一行的空白行-T, –show-tabs 将跳格字符显示为 ^I-v, –show-nonprinting 显示非打印字符 常用范例例一：把 1.log 的文件内容加上行号后附加到2.log 文件里cat -n 1.log 2.log 例二：把1.log 的文件内容加上行号后覆盖2.log 文件（2.log存在）cat -n 1.log &gt; 2.log 2.log不存在时会先创建2.log这里&gt;与》的区别：》是追加，不会覆盖 例三：使用标准输入来创建文件 cat &gt;log.txt &lt;&lt;EOFtac (反向列示)tac log.txt]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[linux命令学习之文件目录命令-cd命令]]></title>
      <url>%2F2017%2F03%2F30%2Flinux%E5%91%BD%E4%BB%A4%E5%AD%A6%E4%B9%A0-%E6%96%87%E4%BB%B6%E7%9B%AE%E5%BD%95%E4%B9%8Bcd%E5%91%BD%E4%BB%A4%2F</url>
      <content type="text"><![CDATA[cd 命令学习命令格式：cd [dirname] 命令功能：切换当前目录至dirName 常用范例例一：进入系统根目录cd / 例一：进入用户主目录cd 或 cd ~ 例三：返回上层目录cd ..cd ../.. （返回上两级目录） 例四：返回进入此目录之前所在的目录cd - 例五：把上个命令的参数作为cd参数使用cd !$（相当于仍然执行上次操作，如果上次cd -,这次也cd -）]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[linux命令学习之文件目录命令-cp命令]]></title>
      <url>%2F2017%2F03%2F30%2Flinux%E5%91%BD%E4%BB%A4%E5%AD%A6%E4%B9%A0-%E6%96%87%E4%BB%B6%E7%9B%AE%E5%BD%95%E4%B9%8Bcp%E5%91%BD%E4%BB%A4%2F</url>
      <content type="text"><![CDATA[cp简介cp命令用来复制文件或者目录，一般情况下，shell会设置一个别名，在命令行下复制文件时，如果目标文件已经存在，就会询问是否覆盖，不管你是否使用-i参数。但是如果是在shell脚本中执行cp时，没有-i参数时不会询问是否覆盖。这说明命令行和shell脚本的执行方式有些不同。 命令学习命令格式：cp [选项] [-T] 源 目的或：cp [选项] 源 目录cp [选项]… -t 目录 源命令功能：将源文件复制至目标文件，或将多个源文件复制至目标目录。命令参数：-a, 为每个已存在的目标文件创建备份-b，类似–backup 但不接受参数，在递归处理是复制特殊文件内容-f, 如果目标文件无法打开则将其移除并重试(当-n选项存在时则不需再选此项)-i, 覆盖前询问(使前面的 -n 选项失效)-H，跟随源文件中的命令行符号链接-l, 链接文件而不复制-L, 总是跟随符号链接-n, 不要覆盖已存在的文件(使前面的 -i 选项失效)-P, 跟随源文件中的符号链接-p，等于–preserve=模式,所有权,时间戳，保持指定的属性(默认：模式,所有权,时间 戳)，如果可能保持附加属性：环境、链接、xattr 等-R, -r, 复制目录及目录内的所有项目 常用范例例一：复制单个文件到目标目录，文件在目标文件中不存在cp l.log test 例二：目标文件存在时，会询问是否覆盖cp 1.log test 例三：复制整个目录目标目录存在时： 整个源目录被复制到目标目录里面cp -a test3 test5目标目录不存在： 类似改名cp -a test3 test4 例四：复制的 log.log 建立一个连结档 log_link.logcp -s log.log log_link.log]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[linux命令学习之文件目录命令-find命令]]></title>
      <url>%2F2017%2F03%2F30%2Flinux%E5%91%BD%E4%BB%A4%E5%AD%A6%E4%B9%A0-%E6%96%87%E4%BB%B6%E7%9B%AE%E5%BD%95%E4%B9%8Bfind%E5%91%BD%E4%BB%A4%2F</url>
      <content type="text"><![CDATA[find简介Linux下find命令在目录结构中搜索文件，并执行指定的操作。find命令提供了相当多的查找条件，功能很强大。即使系统中含有网络文件系统( NFS)，find命令在该文件系统中同样有效，只你具有相应的权限。 在运行一个非常消耗资源的find命令时，很多人都倾向于把它放在后台执行，因为遍历一个大的文件系统可能会花费很长的时间(这里是指30G字节以上的文件系统)。 命令学习命令格式：find pathname -options [-print -exec -ok …] 命令功能：用于在文件树种查找文件，并作出相应的处理 命令参数：pathname: find命令所查找的目录路径。例如用.来表示当前目录，用/来表示系统根目录。-print： find命令将匹配的文件输出到标准输出。-exec： find命令对匹配的文件执行该参数所给出的shell命令。相应命令的形式为’command’ { } \;，注意{ }和\；之间的空格。-ok： 和-exec的作用相同，只不过以一种更为安全的模式来执行该参数所给出的shell命令，在执行每一个命令之前，都会给出提示，让用户来确定是否执行。 命令选项：-name 按照文件名查找文件。-perm 按照文件权限来查找文件。-prune 使用这一选项可以使find命令不在当前指定的目录中查找，如果同时使用-depth选项，那么-prune将被find命令忽略。-user 按照文件属主来查找文件。-group 按照文件所属的组来查找文件。-mtime -n +n 按照文件的更改时间来查找文件， - n表示文件更改时间距现在n天以内，+ n表示文件更改时间距现在n天以前。find命令还有-atime和-ctime 选项，但它们都和-m time选项。-nogroup 查找无有效所属组的文件，即该文件所属的组在/etc/groups中不存在。-nouser 查找无有效属主的文件，即该文件的属主在/etc/passwd中不存在。-newer file1 ! file2 查找更改时间比文件file1新但比文件file2旧的文件。-type 查找某一类型的文件，诸如：b - 块设备文件。d - 目录。c - 字符设备文件。p - 管道文件。l - 符号链接文件。f - 普通文件。-size n：[c] 查找文件长度为n块的文件，带有c时表示文件长度以字节计。-depth：在查找文件时，首先查找当前目录中的文件，然后再在其子目录中查找。-fstype：查找位于某一类型文件系统中的文件，这些文件系统类型通常可以在配置文件/etc/fstab中找到，该配置文件中包含了本系统中有关文件系统的信息。-mount：在查找文件时不跨越文件系统mount点。-follow：如果find命令遇到符号链接文件，就跟踪至链接所指向的文件。-cpio：对匹配的文件使用cpio命令，将这些文件备份到磁带设备中。另外,下面三个的区别:-amin n 查找系统中最后N分钟访问的文件-atime n 查找系统中最后n24小时访问的文件-cmin n 查找系统中最后N分钟被改变文件状态的文件-ctime n 查找系统中最后n24小时被改变文件状态的文件-mmin n 查找系统中最后N分钟被改变文件数据的文件-mtime n 查找系统中最后n*24小时被改变文件数据的文件 常用范例例1：查找指定时间内修改过的文件find -atime -2查找48小时内修改过的文件 例2：根据关键字查找find . -name “*.log”当前目录查找 以.log结尾的文件。 “. “代表当前目录 例3：按照目录或文件的权限来查找文件find ~/Test/ -perm 777 例4：按类型查找find . -type f -name “*.log”查找当前目录，以.log结尾的普通文件 例5：查找当前所有目录并排序find . -type d | sort 例6：按大小查找文件find . -size +1000c -print查找当前目录大于1K的文件]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[linux命令学习之文件目录命令-head命令]]></title>
      <url>%2F2017%2F03%2F30%2Flinux%E5%91%BD%E4%BB%A4%E5%AD%A6%E4%B9%A0-%E6%96%87%E4%BB%B6%E7%9B%AE%E5%BD%95%E4%B9%8Bhead%E5%91%BD%E4%BB%A4%2F</url>
      <content type="text"><![CDATA[head简介head是用来显示开头某个数量的文字区块，显示档案的开头至标准输出中，与tai是查看档案的结尾 命令学习命令格式：head [参数] [文件]命令功能：显示档案的开头至标准输出中，默认head命令打印其相应文件的开头10行。命令参数：-q 隐藏文件名-v 显示文件名-c&lt;字节&gt; 显示字节数-n&lt;行数&gt; 显示的行数 常用范例例1：显示文件的前n行head -n 5 1.log 例2：显示文件前n个字节head -c 20 1.log 例3：文件的除了最后n个字节以外的内容head -c -32 1.log 例4：输出文件除了最后n行的全部内容head -n -6 log2014.log]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[linux命令学习之文件目录命令-less命令]]></title>
      <url>%2F2017%2F03%2F30%2Flinux%E5%91%BD%E4%BB%A4%E5%AD%A6%E4%B9%A0-%E6%96%87%E4%BB%B6%E7%9B%AE%E5%BD%95%E4%B9%8Bless%E5%91%BD%E4%BB%A4%2F</url>
      <content type="text"><![CDATA[less简介less工具也是对文件或其它输出进行分页显示的工具，功能极其强大。less 的用法比起 more 更加的有弹性。在more的时候，没有办法向前面翻，只能往后面看，但若使用了 less 时，就可以使用 [pageup] [pagedown] 等按键的功能来往前往后翻看文件，更容易用来查看一个文件的内容！除此之外，在 less 里头可以拥有更多的搜索功能，不止可以向下搜，也可以向上搜。 命令简介命令格式：less [参数] 文件命令功能：less 与 more 类似，但使用 less 可以随意浏览文件，而 more 仅能向前移动，却不能向后移动，less在查看之前不会加载整个文件命令参数：-b &lt;缓冲区大小&gt; 设置缓冲区的大小-e 当文件显示结束后，自动离开-f 强迫打开特殊文件，例如外围设备代号、目录和二进制文件-g 只标志最后搜索的关键词-i 忽略搜索时的大小写-m 显示类似more命令的百分比-N 显示每行的行号-o &lt;文件名&gt; 将less 输出的内容在指定文件中保存起来-Q 不使用警告音-s 显示连续空行为一行-S 行过长时间将超出部分舍弃-x &lt;数字&gt; 将“tab”键显示为规定的数字空格/字符串：向下搜索“字符串”的功能?字符串：向上搜索“字符串”的功能n：重复前一个搜索（与 / 或 ? 有关）N：反向重复前一个搜索（与 / 或 ? 有关）b 向后翻一页d 向后翻半页h 显示帮助界面Q 退出less 命令u 向前滚动半页y 向前滚动一行空格键 滚动一行回车键 滚动一页[pagedown]： 向下翻动一页[pageup]： 向上翻动一页 常用范例例1：查看文件less 1.log 例2：ps查看进程信息并通过less分页显示ps -ef |less 例3：查看命令历史使用记录并通过less分页显示history | less 例4：浏览多个文件Less 1.log 2.log输入 ：n后，切换到 2.log输入 ：p后, 切换到 1.log 附加备注全屏导航ctrl + F - 向前移动一屏ctrl + B - 向后移动一屏ctrl + D - 向前移动半屏ctrl + U - 向后移动半屏 单行导航j - 向前移动一行k - 向后移动一行 其它导航G - 移动到最后一行g - 移动到第一行q / ZZ - 退出 less 命令 其它有用的命令v - 使用配置的编辑器编辑当前文件h - 显示 less 的帮助文档&amp;pattern - 仅显示匹配模式的行，而不是整个文件 标记导航当使用 less 查看大文件时，可以在任何一个位置作标记，可以通过命令导航到标有特定标记的文本位置：ma - 使用 a 标记文本的当前位置‘a - 导航到标记 a 处]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[linux命令学习之文件目录命令-ls命令]]></title>
      <url>%2F2017%2F03%2F30%2Flinux%E5%91%BD%E4%BB%A4%E5%AD%A6%E4%B9%A0-%E6%96%87%E4%BB%B6%E7%9B%AE%E5%BD%95%E4%B9%8Bls%E5%91%BD%E4%BB%A4%2F</url>
      <content type="text"><![CDATA[ls简介&nbsp;ls用来打印出当前目录的清单，如果ls指定目录那么就会显示指定目录里的文件及文件夹清单。 通过ls 命令不仅可以查看linux文件夹包含的文件，而且可以查看文件权限(包括目录、文件夹、文件权限)，目录信息等等。 命令学习命令格式：ls [选项] [目录名]命令功能：列出目标目录中所有的子目录和文件常用参数：-a 列出目录下的所有文件，包括以 . 开头的隐含文件-b 把文件名中不可输出的字符用反斜杠加字符编号的形式列出。-c 输出文件的 i 节点的修改时间，并以此排序。-d 将目录象文件一样显示，而不是显示其下的文件。-e 输出时间的全部信息，而不是输出简略信息。-i 输出文件的 i 节点的索引信息。-k 以 k 字节的形式表示文件的大小。-l 列出文件的详细信息。-m 横向输出文件名，并以“，”作分格符。-n 用数字的 UID,GID 代替名称。-o 显示文件的除组信息外的详细信息。-p -F 在每个文件名后附上一个字符以说明该文件的类型，“”表示可执行的普通文件；“/”表示目录；“@”表示符号链接；“|”表示FIFOs；“=”表示套接字(sockets)-q 用?代替不可输出的字符。-r 对目录反向排序。-s 在每个文件名后输出该文件的大小。-t 以时间排序。-u 以文件上次被访问的时间排序。-x 按列输出，横向排序。-A 显示除 “.”和“..”外的所有文件。-B 不输出以 “~”结尾的备份文件。-C 按列输出，纵向排序。-G 输出文件的组的信息。-L 列出链接文件名而不是链接到的文件。-N 不限制文件长度。-Q 把输出的文件名用双引号括起来。-R 列出所有子目录下的文件。*-S 以文件大小排序。-X 以文件的扩展名(最后一个 . 后的字符)排序。-1 一行只输出一个文件。–color=no 不显示彩色文件名–help 在标准输出上显示帮助信息。–version 在标准输出上输出版本信息并退出。 常用范例例一：列出/home/文件夹下的所有文件和目录的详细资料ls -l -R /home/Testls -lR /home/peidachang(参数可以一起) 例二：列出当前目录中所有以“t”开头的目录的详细内容ls -l t* 例三：只列出文件下的子目录ls -F /opt/soft |grep /$ 列出 /opt/soft 文件下面的子目录ls -l /opt/soft | grep “^d” 列出 /opt/soft 文件下面的子目录详细情况例四：列出目前工作目录下所有名称是s 开头的档案，愈新的排愈后面命令：ls -ltr s例五：计算当前目录下的文件数和目录数ls -l |grep “^-“|wc -l —文件个数ls -l * |grep “^d”|wc -l —目录个数例七: 在ls中列出文件的绝对路径ls | sed “s:^:pwd/:”例九：列出当前目录下的所有文件（包括隐藏文件）的绝对路径， 对目录不做递归命令：find $PWD -maxdepth 1 | xargs ls -ld例十：递归列出当前目录下的所有文件（包括隐藏文件）的绝对路径find $PWD | xargs ls -ld例十一：指定文件时间输出格式ls -tl –time-style=full-iso扩展： 显示彩色目录列表 打开/etc/bashrc, 加入如下一行: alias ls=”ls –color”下次启动bash时就可以像在Slackware里那样显示彩色的目录列表了, 其中颜色的含义如下: 蓝色–&gt;目录 绿色–&gt;可执行文件 红色–&gt;压缩文件 浅蓝色–&gt;链接文件 灰色–&gt;其他文件]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[linux命令学习之文件目录命令-mkdir命令]]></title>
      <url>%2F2017%2F03%2F30%2Flinux%E5%91%BD%E4%BB%A4%E5%AD%A6%E4%B9%A0-%E6%96%87%E4%BB%B6%E7%9B%AE%E5%BD%95%E4%B9%8Bmkdir%E5%91%BD%E4%BB%A4%2F</url>
      <content type="text"><![CDATA[mkdir简介mkdir命令用来创建指定的名称的目录，要求创建目录的用户在当前目录中具有写权限，并且指定的目录名不能是当前目录中已有的目录。 mkdi学习命令格式：mkdir [选项] 目录…命令功能：mkdir 命令可以实现在指定位置创建以 DirName(指定的文件名)命名的文件夹或目录。要创建文件夹或目录的用户必须对所创建的文件夹的父文件夹具有写权限。并且，所创建的文件夹(目录)不能与其父目录(即父文件夹)中的文件名重名，即同一个目录下不能有同名的(区分大小写)。命令参数：-m,设定权限&lt;模式&gt; (类似 chmod)-p,可以是一个路径名称。此时若路径中的某些目录尚不存在,加上此选项 后,系统将自动建立好那些尚不存在的目录,即一次可以建立多个目录-v, –verbose 每次创建新目录都显示信息–help 显示此帮助信息并退出–version 输出版本信息并退出 常用范例例1：创建一个空目录mkdir test1 例2:递归创建多个目录mkdir -p test2/test22创建test2目录，且在test2目录下创建子目录test22 例3：创建权限为777的目录mkdir -m 777 test3 例4：创建新目录都显示信息mkdir -v test4 例五：一个命令创建项目的目录结构mkdir -vp test2/{test22/,test23/,test24/{test31,test32},test25/test33/{test34,test35}}]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[linux命令学习之文件目录命令-more命令]]></title>
      <url>%2F2017%2F03%2F30%2Flinux%E5%91%BD%E4%BB%A4%E5%AD%A6%E4%B9%A0-%E6%96%87%E4%BB%B6%E7%9B%AE%E5%BD%95%E4%B9%8Bmore%E5%91%BD%E4%BB%A4%2F</url>
      <content type="text"><![CDATA[more简介more命令，功能类似 cat ，cat命令是整个文件的内容从上到下显示在屏幕上。 more会以一页一页的显示方便使用者逐页阅读，而最基本的指令就是按空白键（space）就往下一页显示，按 b 键就会往回（back）一页显示，而且还有搜寻字串的功能 。more命令从前向后读取文件，因此在启动时就加载整个文件。 命令学习命令格式：more [-dlfpcsu ] [-num ] [+/ pattern] [+ linenum] [file … ]命令功能： more命令和cat的功能一样都是查看文件里的内容，但有所不同的是more可以按页来查看文件的内容，还支持直接跳转行等功能。命令参数：+n 从笫n行开始显示-n 定义屏幕大小为n行+/pattern 在每个档案显示前搜寻该字串（pattern），然后从该字串前两行之后开始显示-c 从顶部清屏，然后显示-d 提示“Press space to continue，’q’ to quit（按空格键继续，按q键退出）”，禁用响铃功能-l 忽略Ctrl+l（换页）字符-p 通过清除窗口而不是滚屏来对文件进行换页，与-c选项相似-s 把连续的多个空行显示为一行-u 把文件内容中的下画线去掉 操作命令Enter 向下n行，需要定义。默认为1行Ctrl+F 向下滚动一屏空格键 向下滚动一屏Ctrl+B 返回上一屏= 输出当前行的行号：f 输出文件名和当前行的行号 V 调用vi编辑器!命令 调用Shell，并执行命令q 退出more 常用范例例1：显示文件中从第3行起的内容more +3 1.log 例2：从文件中查找第一个出现”b”字符串的行，并从该处前两行开始显示输出more +/b 1.log 例3：设定每屏显示行数more -5 1.log 例4：列一个目录下的文件，由于内容太多，会用more来分页显示(和管道 | 结合起来 )ls -l | more -3每页显示3个文件信息，按 Ctrl+F 或者 空格键 将会显示下3条文件信息]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[linux命令学习之文件目录命令-mv命令]]></title>
      <url>%2F2017%2F03%2F30%2Flinux%E5%91%BD%E4%BB%A4%E5%AD%A6%E4%B9%A0-%E6%96%87%E4%BB%B6%E7%9B%AE%E5%BD%95%E4%B9%8Bmv%E5%91%BD%E4%BB%A4%2F</url>
      <content type="text"><![CDATA[mv简介mv命令可以用来移动文件或者将文件改名（move (rename) files），经常用来备份文件或者目录 命令学习命令格式：mv [选项] 源文件或目录 目标文件或目录命令功能：根据mv命令中第二个参数类型（是目标文件还是目标目录），mv命令将文件重命名或将其移至一个新的目录中。当第二个参数类型是文件时，mv命令完成文件重命名，此时，源文件只能有一个（也可以是源目录名），它将所给的源文件或目录重命名为给定的目标文件名。当第二个参数是已存在的目录名称时，源文件或目录参数可以有多个，mv命令将各参数指定的源文件均移至目标目录中。在跨文件系统移动文件时，mv先拷贝，再将原有文件删除，而链至该文件的链接也将丢失。命令参数：-b ：若需覆盖文件，则覆盖前先行备份。-f ：force 强制的意思，如果目标文件已经存在，不会询问而直接覆盖-i ：若目标文件 (destination) 已经存在时，就会询问是否覆盖-u ：若目标文件已经存在，且 source 比较新，才会更新(update)-t ：指定mv的目标目录，该选项适用于移动多个源文件到一个目录的情况，此时目标目录在前，源文件在后。 常用范例例一：文件改名mv test.log test1.txttest.log 改为test1.txt 例二：移动文件mv test1.txt test3将test1.txt文件移到目录test3中 例三：将文件log1.txt,log2.txt,log3.txt移动到目录test3中。mv log1.txt log2.txt log3.txt test3将log1.txt ，log2.txt， log3.txt 三个文件移到 test3目录mv -t /opt/soft/test/test4/ log1.txt log2.txt log3.txt将三个文件移动到test4目录 例五：将文件file1改名为file2，即使file2存在，也是直接覆盖掉。mv -f log3.txt log2.txt 例六：目录的移动mv dir1 dir2如果目录dir2不存在，将目录dir1改名为dir2；否则，将dir1移动到dir2中 例7：移动当前文件夹下的所有文件到上一级目录mv * ../ 例8：把当前目录的一个子目录里的文件移动到另一个子目录里mv test3/*.txt test5]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[linux命令学习之文件目录命令-nl命令]]></title>
      <url>%2F2017%2F03%2F30%2Flinux%E5%91%BD%E4%BB%A4%E5%AD%A6%E4%B9%A0-%E6%96%87%E4%BB%B6%E7%9B%AE%E5%BD%95%E4%B9%8Bnl%E5%91%BD%E4%BB%A4%2F</url>
      <content type="text"><![CDATA[nl简介nl命令在linux系统中用来计算文件中行号。nl 可以将输出的文件内容自动的加上行号。其默认的结果与 cat -n 有点不太一样， nl可以将行号做比较多的显示设计，包括位数与是否自动补齐 0 等的功能。 命令学习命令格式：nl [选项] [文件]命令功能：nl 命令读取 File 参数（缺省情况下标准输入），计算输入中的行号，将计算过的行号写入标准输出。 在输出中，nl 命令根据您在命令行中指定的标志来计算左边的行。 输入文本必须写在逻辑页中。每个逻辑页有头、主体和页脚节（可以有空节）。 除非使用 -p 标志，nl 命令在每个逻辑页开始的地方重新设置行号。 可以单独为头、主体和页脚节设置行计算标志（例如，头和页脚行可以被计算然而文本行不能）。命令参数：-b ：行号指定的方式，主要有两种：-b a ：表示不论是否为空行，也同样列出行号(类似 cat -n)；-b t ：如果有空行，空的那一行不要列出行号(默认值)； -n ：列出行号表示的方法，主要有三种：-n ln ：行号在萤幕的最左方显示；-n rn ：行号在自己栏位的最右方显示，且不加 0 ；-n rz ：行号在自己栏位的最右方显示，且加 0 ； -w ：行号栏位的占用的位数。-p 在逻辑定界符处不重新开始计算。 常用范例例一：用 nl 列出 1.log的内容nl 1.log文件中的空白行，nl 不会加上行号 例二：用 nl 列出 1.log 的内容，空本行也加上行号nl -b a 1.log 例3：让行号前面自动补上0,统一输出格式nl -b a -n rz 1.lognl -b a -n rz -w 3 1.log]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[linux命令学习之文件目录命令-pwd命令]]></title>
      <url>%2F2017%2F03%2F30%2Flinux%E5%91%BD%E4%BB%A4%E5%AD%A6%E4%B9%A0-%E6%96%87%E4%BB%B6%E7%9B%AE%E5%BD%95%E4%B9%8Bpwd%E5%91%BD%E4%BB%A4%2F</url>
      <content type="text"><![CDATA[pwd简介pwd 命令查看”当前工作目录“的完整路径。每当在终端进行操作时，都会有一个当前工作目录。在不太确定当前位置时，使用pwd来判定当前目录在文件系统内的确切位置。 命令学习命令格式：pwd [选项] 目录命令功能：查看”当前工作目录“的完整路径常用参数：一般情况下不带任何参数如果目录是链接时：pwd -P 显示出实际路径，而连接（link）路径。pwd -L：与pwd -P完全相反，显示链接路径 环境变量PWD：显示当前工作路径的环境变量echo $PWD环境变量OLDPWD：显示上一次的工作路径echo $PWD注意：由于是环境变量，使用的时候需要加上$变量标志 内建命令pwd和外部命令/bin/pwd,二者的基本功能是一致的，但是在显示当前目录时，/bin/pwd显示得更准确些，而pwd容易被操作者糊弄常用范例例1：用 pwd 命令查看当前工作目录的完整路径pwd 例2：目录连接链接时，pwd -P 显示出实际路径，而非使用连接（link）路径pwd -p 例3：当前目录被删除了，而pwd命令仍然显示那个目录实例4：/bin/pwd/bin/pwd [选项]选项：-L 目录连接链接时，输出连接路径-P 输出物理路径]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[linux命令学习之文件目录命令-rm命令]]></title>
      <url>%2F2017%2F03%2F30%2Flinux%E5%91%BD%E4%BB%A4%E5%AD%A6%E4%B9%A0-%E6%96%87%E4%BB%B6%E7%9B%AE%E5%BD%95%E4%B9%8Brm%E5%91%BD%E4%BB%A4%2F</url>
      <content type="text"><![CDATA[rm简介rm命令为删除一个目录中的一个或多个文件或目录，也可以某个目录及其下的所有文件及子目录均删除。对于链接文件，只是删除了链接，原有文件均保持不变rm是一个危险的命令，使用的时候要特别当心，否则整个系统就会毁在这个命令（比如在/（根目录）下执行rm * -rf）。所以，在执行rm之前最好先确认一下在哪个目录，到底要删除什么东西。 命令学习命令格式：rm [选项] 文件命令功能：删除一个目录中的一个或多个文件或目录，如果没有使用- r选项，则rm不会删除目录。如果使用 rm 来删除文件，通常仍可以将该文件恢复原状。命令参数：-f,忽略不存在的文件，从不给出提示。-i,进行交互式删除-r, -R,指示rm将参数中列出的全部目录和子目录均递归地删除。-v, –verbose 详细显示进行的步骤–help 显示此帮助信息并退出–version 输出版本信息并退出 常用范例例一：删除文件file，系统会先询问是否删除。rm filename 例二：强行删除file，系统不再提示rm -f filename 例三：删除任何.log文件；删除前逐一询问确认rm -i *.log 例四：将 test1子目录及子目录中所有档案删除rm -r test1 例七：自定义回收站功能myrm(){D=/tmp/$(date +%Y%m%d%H%M%S);//在/tmp文件夹中创建名为“当前日期”的文件//其中“date+%Y%m%d%H%M%S”是规定了日期的输出格式mkdir -p $D;//以变量D中的路径创建文件夹mv “$@” $D &amp;&amp; echo “moved to $D ok”;//将所要删除的文件移入变量D中的文件夹内，移入成功后，输出移动成功}]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[linux命令学习之文件目录命令-touch命令]]></title>
      <url>%2F2017%2F03%2F30%2Flinux%E5%91%BD%E4%BB%A4%E5%AD%A6%E4%B9%A0-%E6%96%87%E4%BB%B6%E7%9B%AE%E5%BD%95%E4%B9%8Btouch%E5%91%BD%E4%BB%A4%2F</url>
      <content type="text"><![CDATA[touch简介linux的touch命令不常用，一般在使用make的时候可能会用到，用来修改文件时间戳，或者新建一个不存在的文件 命令学习命令格式：touch [选项] 文件命令功能：可更改文档或目录的日期时间，包括存取时间和更改时间。命令参数：-a 只更改存取时间。-c 不建立任何文档。-d 使用指定的日期时间，而非现在的时间。参数是年月日-f 此参数将忽略不予处理，仅负责解决BSD版本touch指令的兼容性问题。-m 只更改变动时间。-r 把指定文档或目录的日期时间，统统设成和参考文档或目录的日期时间相同。-t 使用指定的日期时间，而非现在的时间。参数是年月日时分秒 常用范例例一：创建不存在的文件touch 1.log 2.log 例二：更改时间戳touch -r 1.log 2.log将2.log文件的时间改为与1.log相同 例二：修改为当前时间touch filename系统自动将文件修改时间更新为当前时间 例三：设定文件的时间戳touch -t 201211142234.50 1.log测试后发现不管是否为当月时间都是显示形式为年月日]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[linux命令学习之文件目录命令-tail命令]]></title>
      <url>%2F2017%2F03%2F30%2Flinux%E5%91%BD%E4%BB%A4%E5%AD%A6%E4%B9%A0-%E6%96%87%E4%BB%B6%E7%9B%AE%E5%BD%95%E4%B9%8Btail%E5%91%BD%E4%BB%A4%2F</url>
      <content type="text"><![CDATA[tail简介tail命令从指定点开始将文件写到标准输出。使用tail命令的-f选项可以方便的查阅正在改变的日志文件,tail -f filename会把filename里最尾部的内容显示在屏幕上,并且不但刷新,使你看到最新的文件内容. 命令学习命令格式：tail[必要参数][选择参数][文件]命令功能：用于显示指定文件末尾内容，不指定文件时，作为输入信息进行处理。常用查看日志文件。命令参数：-f 循环读取-q 不显示处理信息-v 显示详细的处理信息-c&lt;数目&gt; 显示的字节数-n&lt;行数&gt; 显示行数–pid=PID 与-f合用,表示在进程ID,PID死掉之后结束.-q, –quiet, –silent 从不输出给出文件名的首部-s, –sleep-interval=S 与-f合用,表示在每次反复的间隔休眠S秒 常用实例例1：显示文件末尾内容tail -n 5 1.log显示文件最后5行内容 例3：从第3行开始显示文件tail -n +5 1.log]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[linux命令学习之ifconfig命令]]></title>
      <url>%2F2017%2F03%2F30%2Flinux%E5%91%BD%E4%BB%A4%E5%AD%A6%E4%B9%A0-%E7%BD%91%E7%BB%9C%E5%91%BD%E4%BB%A4%E4%B9%8Bifconfig%E5%91%BD%E4%BB%A4%2F</url>
      <content type="text"><![CDATA[ifconfig简介 通常需要以root身份登录或使用sudo以便在Linux机器上使用ifconfig工具。依赖于ifconfig命令中使用一些选项属性，ifconfig工具不仅可以被用来简单地获取网络接口配置信息，还可以修改这些配置。 用ifconfig命令配置的网卡信息，在网卡重启后机器重启后，配置就不存在。要想配置信息永远的存的电脑里，那就要修改网卡的配置文件了。 命令学习 命令格式：ifconfig [网络设备] [参数] 命令功能：ifconfig 命令用来查看和配置网络设备。当网络环境发生改变时可通过此命令对网络进行相应的配置。 命令参数：up 启动指定网络设备/网卡。down 关闭指定网络设备/网卡。该参数可以有效地阻止通过指定接口的IP信息流，如果想永久地关闭一个接口，我们还需要从核心路由表中将该接口的路由信息全部删除。arp 设置指定网卡是否支持ARP协议。-promisc 设置是否支持网卡的promiscuous模式，如果选择此参数，网卡将接收网络中发给它所有的数据包-allmulti 设置是否支持多播模式，如果选择此参数，网卡将接收网络中所有的多播数据包-a 显示全部接口信息-s 显示摘要信息（类似于 netstat -i）add 给指定网卡配置IPv6地址del 删除指定网卡的IPv6地址&lt;硬件地址&gt; 配置网卡最大的传输单元mtu&lt;字节数&gt; 设置网卡的最大传输单元 (bytes)netmask&lt;子网掩码&gt; 设置网卡的子网掩码。掩码可以是有前缀0x的32位十六进制数，也可以是用点分开的4个十进制数。如果不打算将网络分成子网，可以不管这一选项；如果要使用子网，那么请记住，网络中每一个系统必须有相同子网掩码。tunel 建立隧道dstaddr 设定一个远端地址，建立点对点通信-broadcast&lt;地址&gt; 为指定网卡设置广播协议-pointtopoint&lt;地址&gt; 为网卡设置点对点通讯协议multicast 为网卡设置组播标志address 为网卡设置IPv4地址txqueuelen&lt;长度&gt; 为网卡设置传输列队的长度 常用范例 例1：显示网络设备信息（激活状态的） eth0 表示第一块网卡， 其中硬件地址表示网卡的物理地址，可以看到目前这个网卡的物理地址(MAC地址）是 00:50:56:BF:26:20inet addr 用来表示网卡的IP地址，此网卡的 IP地址是 192.168.120.204广播地址 Bcast:192.168.120.255，掩码地址Mask:255.255.255.0lo 是表示主机的回坏地址，这个一般是用来测试一个网络程序，但又不想让局域网或外网的用户能够查看，只能在此台主机上运行和查看所用的网络接口。比如把 HTTPD服务器的指定到回坏地址，在浏览器输入 127.0.0.1 就能看到你所架WEB网站了。但只是您能看得到，局域网的其它主机或用户无从知道。第一行：连接类型：Ethernet（以太网）HWaddr（硬件mac地址）第二行：网卡的IP地址、子网、掩码第三行：UP（代表网卡开启状态）RUNNING（代表网卡的网线被接上）MULTICAST（支持组播） MTU:1500（最大传输单元）：1500字节第四、五行：接收、发送数据包情况统计第七行：接收、发送数据字节数统计信息。 例2：启动关闭指定网卡ifconfig eth0 upifconfig eth0 downifconfig eth0 up 为启动网卡eth0 ；ifconfig eth0 down 为关闭网卡eth0。ssh登陆linux服务器操作要小心，关闭了就不能开启了，除非你有多网卡。 例4：用ifconfig修改MAC地址 ifconfig eth0 down //关闭网卡ifconfig eth0 hw ether 00:AA:BB:CC:DD:EEifconfig eth0 up //启动网卡 例5：配置IP地址ifconfig eth0 192.168.120.56给eth0网卡配置IP地：192.168.120.56 ifconfig eth0 192.168.120.56 netmask 255.255.255.0给eth0网卡配置IP地址：192.168.120.56 ，并加上子掩码：255.255.255.0ifconfig eth0 192.168.120.56 netmask 255.255.255.0 broadcast 192.168.120.255给eth0网卡配置IP地址：192.168.120.56，加上子掩码：255.255.255.0，加上个广播地址： 192.168.120.255 例6：启用和关闭ARP协议ifconfig eth0 arp 开启网卡eth0 的arp协议ifconfig eth0 -arp 关闭网卡eth0 的arp协议； 例7：设置最大传输单元ifconfig eth0 mtu 1500设置能通过的最大数据包大小为 1500 bytes]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[linux命令学习之网络命令-netstat命令]]></title>
      <url>%2F2017%2F03%2F30%2Flinux%E5%91%BD%E4%BB%A4%E5%AD%A6%E4%B9%A0-%E7%BD%91%E7%BB%9C%E5%91%BD%E4%BB%A4%E4%B9%8Bnetstat%E5%91%BD%E4%BB%A4%2F</url>
      <content type="text"><![CDATA[netstat简介netstat命令用于显示与IP、TCP、UDP和ICMP协议相关的统计数据，一般用于检验本机各端口的网络连接情况。netstat是在内核中访问网络及相关信息的程序，它能提供TCP连接，TCP和UDP监听，进程内存管理的相关报告。如果你的计算机有时候接收到的数据报导致出错数据或故障，你不必感到奇怪，TCP/IP可以容许这些类型的错误，并能够自动重发数据报。但如果累计的出错情况数目占到所接收的IP数据报相当大的百分比，或者它的数目正迅速增加，那么你就应该使用netstat查一查为什么会出现这些情况了。 命令学习命令格式：netstat [-acCeFghilMnNoprstuvVwx][-A&lt;网络类型&gt;][–ip] 命令功能：netstat用于显示与IP、TCP、UDP和ICMP协议相关的统计数据，一般用于检验本机各端口的网络连接情况。 命令参数：-a或–all 显示所有连线中的Socket。-A&lt;网络类型&gt;或–&lt;网络类型&gt; 列出该网络类型连线中的相关地址。-c或–continuous 持续列出网络状态。-C或–cache 显示路由器配置的快取信息。-e或–extend 显示网络其他相关信息。-F或–fib 显示FIB。-g或–groups 显示多重广播功能群组组员名单。-h或–help 在线帮助。-i或–interfaces 显示网络界面信息表单。-l或–listening 显示监控中的服务器的Socket。-M或–masquerade 显示伪装的网络连线。-n或–numeric 直接使用IP地址，而不通过域名服务器。-N或–netlink或–symbolic 显示网络硬件外围设备的符号连接名称。-o或–timers 显示计时器。-p或–programs 显示正在使用Socket的程序识别码和程序名称。-r或–route 显示Routing Table。-s或–statistice 显示网络工作信息统计表。-t或–tcp 显示TCP传输协议的连线状况。-u或–udp 显示UDP传输协议的连线状况。-v或–verbose 显示指令执行过程。-V或–version 显示版本信息。-w或–raw 显示RAW传输协议的连线状况。-x或–unix 此参数的效果和指定”-A unix”参数相同。–ip或–inet 此参数的效果和指定”-A inet”参数相同。 常用范例例1：无参数使用netstat 从整体上看，netstat的输出结果可以分为两个部分：一个是Active Internet connections，称为有源TCP连接，其中”Recv-Q”和”Send-Q”指的是接收队列和发送队列。这些数字一般都应该是0。如果不是则表示软件包正在队列中堆积。这种情况只能在非常少的情况见到。另一个是Active UNIX domain sockets，称为有源Unix域套接口(和网络套接字一样，但是只能用于本机通信，性能可以提高一倍)。Proto显示连接使用的协议,RefCnt表示连接到本套接口上的进程号,Types显示套接口的类型,State显示套接口当前的状态,Path表示连接到套接口的其它进程使用的路径名。套接口类型：-t ：TCP-u ：UDP-raw ：RAW类型–unix ：UNIX域类型–ax25 ：AX25类型–ipx ：ipx类型–netrom ：netrom类型状态说明：LISTEN：侦听来自远方的TCP端口的连接请求SYN-SENT：再发送连接请求后等待匹配的连接请求（如果有大量这样的状态包，检查是否中招了）SYN-RECEIVED：再收到和发送一个连接请求后等待对方对连接请求的确认（如有大量此状态，估计被flood攻击了）ESTABLISHED：代表一个打开的连接FIN-WAIT-1：等待远程TCP连接中断请求，或先前的连接中断请求的确认FIN-WAIT-2：从远程TCP等待连接中断请求CLOSE-WAIT：等待从本地用户发来的连接中断请求CLOSING：等待远程TCP对连接中断的确认LAST-ACK：等待原来的发向远程TCP的连接中断请求的确认（不是什么好东西，此项出现，检查是否被攻击）TIME-WAIT：等待足够的时间以确保远程TCP接收到连接中断请求的确认CLOSED：没有任何连接状态 例2：列出所有端口netstat -a 显示一个所有的有效连接信息列表，包括已建立的连接（ESTABLISHED），也包括监听连接请（LISTENING）的那些连接。 例3：显示当前UDP连接状况netstat -nu 例4：显示UDP端口号的使用情况netstat -apu 例5：显示网卡列表netstat -i 例6：显示组播组的关系netstat -g 例7：显示网络统计信息netstat -s 例8：显示监听的套接口netstat -l 例9：显示所有已建立的有效连接netstat -n 例10：显示关于以太网的统计数据netstat -e 用于显示关于以太网的统计数据。它列出的项目包括传送的数据报的总字节数、错误数、删除数、数据报的数量和广播的数量。这些统计数据既有发送的数据报数量，也有接收的数据报数量。这个选项可以用来统计一些基本的网络流量） 例11：显示关于路由表的信息netstat -r 例12：列出所有 tcp 端口netstat -at 例13：统计机器中网络连接各个状态个数netstat -a | awk ‘/^tcp/ {++S[$NF]} END {for(a in S) print a, S[a]}’ 例14：把状态全都取出来后使用uniq -c统计后再进行排序netstat -nat |awk ‘{print $6}’|sort|uniq -c 例15：查看连接某服务端口最多的的IP地址netstat -nat | grep “192.168.120.20:16067” |awk ‘{print $5}’|awk -F: ‘{print $4}’|sort|uniq -c|sort -nr|head -20 例16：找出程序运行的端口 netstat -ap | grep ssh 例17：在 netstat 输出中显示 PID 和进程名称netstat -pt 例18：找出运行在指定端口的进程netstat -anpt | grep ‘:16064’运行在端口16064的进程id为24596，再通过ps命令就可以找到具体的应用程序了。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[linux命令学习之磁盘命令-df命令]]></title>
      <url>%2F2017%2F03%2F30%2Flinux%E5%91%BD%E4%BB%A4%E5%AD%A6%E4%B9%A0-%E7%A3%81%E7%9B%98%E5%91%BD%E4%BB%A4%E4%B9%8Bdf%E5%91%BD%E4%BB%A4%2F</url>
      <content type="text"><![CDATA[df命令简介 df命令的功能是用来检查linux服务器的文件系统的磁盘空间占用情况。可以利用该命令来获取硬盘被占用了多少空间，目前还剩下多少空间等信息。 命令学习命令格式：df [选项] [文件] 命令功能：显示指定磁盘文件的可用空间。如果没有文件名被指定，则所有当前被挂载的文件系统的可用空间将被显示。默认情况下，磁盘空间将以 1KB 为单位进行显示，除非环境变量 POSIXLY_CORRECT 被指定，那样将以512字节为单位进行显示 命令参数：必要参数：-a 全部文件系统列表-h 方便阅读方式显示-H 等于“-h”，但是计算式，1K=1000，而不是1K=1024-i 显示inode信息-k 区块为1024字节-l 只显示本地文件系统-m 区块为1048576字节–no-sync 忽略 sync 命令-P 输出格式为POSIX–sync 在取得磁盘信息前，先执行sync命令-T 文件系统类型 选择参数：–block-size=&lt;区块大小&gt; 指定区块大小-t&lt;文件系统类型&gt; 只显示选定文件系统的磁盘信息-x&lt;文件系统类型&gt; 不显示选定文件系统的磁盘信息–help 显示帮助信息–version 显示版本信息 常用范例例1：显示磁盘使用情况dflinux中df命令的输出清单的第1列是代表文件系统对应的设备文件的路径名（一般是硬盘上的分区）；第2列给出分区包含的数据块（1024字节）的数目；第3，4列分别表示已用的和可用的数据块数目。用户也许会感到奇怪的是，第3，4列块数之和不等于第2列中的块数。这是因为缺省的每个分区都留了少量空间供系统管理员使用。即使遇到普通用户空间已满的情况，管理员仍能登录和留有解决问题所需的工作空间。第5列已用% 列表示普通用户空间使用的百分比，即使这一数字达到100％，分区仍然留有系统管理员使用的空间。第6列挂载点列表示文件系统的挂载点。 例2：以inode模式来显示磁盘使用情况 df -i 例3：列出各文件系统的i节点使用情况 例5：列出文件系统的类型df -T 例6：以更易读的方式显示目前磁盘空间和使用情况 例7：显示所有的信息df –total]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[linux命令学习之网络命令-ping命令]]></title>
      <url>%2F2017%2F03%2F30%2Flinux%E5%91%BD%E4%BB%A4%E5%AD%A6%E4%B9%A0-%E7%BD%91%E7%BB%9C%E5%91%BD%E4%BB%A4%E4%B9%8Bping%E5%91%BD%E4%BB%A4%2F</url>
      <content type="text"><![CDATA[ping简介Linux系统的ping命令是常用的网络命令，它通常用来测试与目标主机的连通性。我们经常会说“ping一下某机器，看是不是开着”、不能打开网页时会说“你先ping网关地址192.168.1.1试试”。它通过发送ICMP ECHO_REQUEST数据包到网络主机（send ICMP ECHO_REQUEST to network hosts），并显示响应情况，这样我们就可以根据它输出的信息来确定目标主机是否可访问（但这不是绝对的）。有些服务器为了防止通过ping探测到，通过防火墙设置了禁止ping或者在内核参数中禁止ping，这样就不能通过ping确定该主机是否还处于开启状态。linux下的ping和windows下的ping稍有区别,linux下ping不会自动终止,需要按ctrl+c终止或者用参数-c指定要求完成的回应次数。 命令学习命令格式：ping [参数] [主机名或IP地址] 命令功能：ping命令用于：确定网络和各外部主机的状态；跟踪和隔离硬件和软件问题；测试、评估和管理网络。如果主机正在运行并连在网上，它就对回送信号进行响应。每个回送信号请求包含一个网际协议（IP）和 ICMP 头，后面紧跟一个 tim 结构，以及来填写这个信息包的足够的字节。缺省情况是连续发送回送信号请求直到接收到中断信号（Ctrl-C）。ping 命令每秒发送一个数据报并且为每个接收到的响应打印一行输出。ping 命令计算信号往返时间和(信息)包丢失情况的统计信息，并且在完成之后显示一个简要总结。ping 命令在程序超时或当接收到 SIGINT 信号时结束。Host 参数或者是一个有效的主机名或者是因特网地址。 命令参数：-d 使用Socket的SO_DEBUG功能。-f 极限检测。大量且快速地送网络封包给一台机器，看它的回应。-n 只输出数值。-q 不显示任何传送封包的信息，只显示最后的结果。-r 忽略普通的Routing Table，直接将数据包送到远端主机上。通常是查看本机的网络接口是否有问题。-v 详细显示指令的执行过程。 -c 数目：在发送指定数目的包后停止。-i 秒数：设定间隔几秒送一个网络封包给一台机器，预设值是一秒送一次。-I 网络界面：使用指定的网络界面送出数据包。-l 前置载入：设置在送出要求信息之前，先行发出的数据包。-p 范本样式：设置填满数据包的范本样式。-s 字节数：指定发送的数据字节数，预设值是56，加上8字节的ICMP头，一共是64ICMP数据字节。-t 存活数值：设置存活数值TTL的大小。 常用范例例1：ping的通的情况ping 192.168.120.205 例2：ping不通的情况ping 192.168.120.202 例3：ping网关ping -b 192.168.120.1 例4：ping指定次数ping -c 10 192.168.120.206 例5：时间间隔和次数限制的pingping -c 10 -i 0.5 192.168.120.206 例6：通过域名ping公网上的站点ping -c 5 www.58.com 例7：多参数使用ping -i 3 -s 1024 -t 255 192.168.120.206-i 3 发送周期为 3秒 -s 设置发送包的大小为1024 -t 设置TTL值为 255]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[linux命令学习之route命令]]></title>
      <url>%2F2017%2F03%2F30%2Flinux%E5%91%BD%E4%BB%A4%E5%AD%A6%E4%B9%A0-%E7%BD%91%E7%BB%9C%E5%91%BD%E4%BB%A4%E4%B9%8Broute%E5%91%BD%E4%BB%A4%2F</url>
      <content type="text"><![CDATA[route简介route命令用于显示和操作IP路由表。要实现两个不同的子网之间的通信，需要一台连接两个网络的路由器，或者同时位于两个网络的网关来实现。在Linux系统中，设置路由通常是为了解决以下问题：该Linux系统在一个局域网中，局域网中有一个网关，能够让机器访问Internet，那么就需要将这台机器的IP地址设置为Linux机器的默认路由。直接在命令行下执行route命令来添加路由，不会永久保存，当网卡重启或者机器重启之后，该路由就失效了。可以在/etc/rc.local中添加route命令来保证该路由设置永久有效。 命令学习命令格式：route [-f] [-p] [Command [Destination] [mask Netmask] [Gateway] [metric Metric]] [if Interface]] 命令功能：Route命令是用于操作基于内核ip路由表，它的主要作用是创建一个静态路由让指定一个主机或者一个网络通过一个网络接口，如eth0。当使用”add”或者”del”参数时，路由表被修改，如果没有参数，则显示路由表当前的内容。 命令参数：-c 显示更多信息-n 不解析名字-v 显示详细的处理信息-F 显示发送信息-C 显示路由缓存-f 清除所有网关入口的路由表。-p 与 add 命令一起使用时使路由具有永久性。 add:添加一条新路由。del:删除一条路由。-net:目标地址是一个网络。-host:目标地址是一个主机。netmask:当添加一个网络路由时，需要使用网络掩码。gw:路由数据包通过网关。注意，你指定的网关必须能够达到。metric：设置路由跳数。 Command 指定您想运行的命令 (Add/Change/Delete/Print)。Destination 指定该路由的网络目标。mask Netmask 指定与网络目标相关的网络掩码（也被称作子网掩码）。Gateway 指定网络目标定义的地址集和子网掩码可以到达的前进或下一跃点 IP 地址。metric Metric 为路由指定一个整数成本值标（从 1 至 9999），当在路由表(与转发的数据包目标地址最匹配)的多个路由中进行选择时可以使用。if Interface 为可以访问目标的接口指定接口索引。若要获得一个接口列表和它们相应的接口索引，使用 route print 命令的显示功能。可以使用十进制或十六进制值进行接口索引。 常用范例例1：显示当前路由routeroute -n route -n (-n 表示不解析名字,列出速度会比route 快) 第一行表示主机所在网络的地址为192.168.120.0，若数据传送目标是在本局域网内通信，则可直接通过eth0转发数据包;第四行表示数据传送目的是访问Internet，则由接口eth0，将数据包发送到网关192.168.120.240其中Flags为路由标志，标记当前网络节点的状态。Flags标志说明：U Up表示此路由当前为启动状态H Host，表示此网关为一主机G Gateway，表示此网关为一路由器R Reinstate Route，使用动态路由重新初始化的路由D Dynamically,此路由是动态性地写入M Modified，此路由是由路由守护程序或导向器动态修改! 表示此路由当前为关闭状态 例2：添加网关/设置网关route add -net 224.0.0.0 netmask 240.0.0.0 dev eth0增加一条 到达244.0.0.0的路由 例3：屏蔽一条路由route add -net 224.0.0.0 netmask 240.0.0.0 reject 例4：删除路由记录route del -net 224.0.0.0 netmask 240.0.0.0route del -net 224.0.0.0 netmask 240.0.0.0 reject 例5：删除和添加设置默认网关 route del default gw 192.168.120.240route add default gw 192.168.120.240]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[linux命令学习之网络命令-ss命令]]></title>
      <url>%2F2017%2F03%2F30%2Flinux%E5%91%BD%E4%BB%A4%E5%AD%A6%E4%B9%A0-%E7%BD%91%E7%BB%9C%E5%91%BD%E4%BB%A4%E4%B9%8Bss%E5%91%BD%E4%BB%A4%2F</url>
      <content type="text"><![CDATA[ss简介ss是Socket Statistics的缩写。ss命令可以用来获取socket统计信息，它可以显示和netstat类似的内容。但ss的优势在于它能够显示更多更详细的有关TCP和连接状态的信息，而且比netstat更快速更高效。当服务器的socket连接数量变得非常大时，无论是使用netstat命令还是直接cat /proc/net/tcp，执行速度都会很慢。当服务器维持的连接达到上万个的时候，使用netstat等于浪费 生命，而用ss才是节省时间。 ss快的秘诀在于，它利用到了TCP协议栈中tcp_diag。tcp_diag是一个用于分析统计的模块，可以获得Linux 内核中第一手的信息，这就确保了ss的快捷高效。当然，如果你的系统中没有tcp_diag，ss也可以正常运行，只是效率会变得稍慢。（但仍然比 netstat要快。） 命令学习命令格式:ss [参数]ss [参数] [过滤] 命令功能：ss(Socket Statistics的缩写)命令可以用来获取 socket统计信息，此命令输出的结果类似于 netstat输出的内容，但它能显示更多更详细的 TCP连接状态的信息，且比 netstat 更快速高效。它使用了 TCP协议栈中 tcp_diag（是一个用于分析统计的模块），能直接从获得第一手内核信息，这就使得 ss命令快捷高效。在没有 tcp_diag，ss也可以正常运行。 命令参数：-h, –help 帮助信息-V, –version 程序版本信息-n, –numeric 不解析服务名称-r, –resolve 解析主机名-a, –all 显示所有套接字（sockets）-l, –listening 显示监听状态的套接字（sockets）-o, –options 显示计时器信息-e, –extended 显示详细的套接字（sockets）信息-m, –memory 显示套接字（socket）的内存使用情况-p, –processes 显示使用套接字（socket）的进程-i, –info 显示 TCP内部信息-s, –summary 显示套接字（socket）使用概况-4, –ipv4 仅显示IPv4的套接字（sockets）-6, –ipv6 仅显示IPv6的套接字（sockets）-0, –packet 显示 PACKET 套接字（socket）-t, –tcp 仅显示 TCP套接字（sockets）-u, –udp 仅显示 UCP套接字（sockets）-d, –dccp 仅显示 DCCP套接字（sockets）-w, –raw 仅显示 RAW套接字（sockets）-x, –unix 仅显示 Unix套接字（sockets）-f, –family=FAMILY 显示 FAMILY类型的套接字（sockets），FAMILY可选，支持 unix, inet, inet6, link, netlink-A, –query=QUERY, –socket=QUERY QUERY := {all|inet|tcp|udp|raw|unix|packet|netlink}[,QUERY]-D, –diag=FILE 将原始TCP套接字（sockets）信息转储到文件 -F, –filter=FILE 从文件中都去过滤器信息 FILTER : = [ state TCP-STATE ] [ EXPRESSION ] 常用范例例1：显示TCP连接ss -t -a 例2：显示 Sockets 摘要ss -s 列出当前的established, closed, orphaned and waiting TCP sockets 例3：列出所有打开的网络连接端口ss -l 例4：查看进程使用的socketss -pl 例5：找出打开套接字/端口应用程序ss -lp | grep 3306 例6：显示所有UDP Socketsss -u -a 例7：显示所有状态为established的SMTP连接ss -o state established ‘( dport = :smtp or sport = :smtp )’ 例8：显示所有状态为Established的HTTP连接ss -o state established ‘( dport = :http or sport = :http )’ 例9：列举出处于 FIN-WAIT-1状态的源端口为 80或者 443，目标网络为 193.233.7/24所有 tcp套接字ss -o state fin-wait-1 ‘( sport = :http or sport = :https )’ dst 193.233.7/24 例10：用TCP 状态过滤Sockets:ss -4 state FILTER-NAME-HEREss -6 state FILTER-NAME-HERE FILTER-NAME-HERE 可以代表以下任何一个：establishedsyn-sentsyn-recvfin-wait-1fin-wait-2time-waitclosedclose-waitlast-acklistenclosing all : 所有以上状态connected : 除了listen and closed的所有状态synchronized :所有已连接的状态除了syn-sentbucket : 显示状态为maintained as minisockets,如：time-wait和syn-recv.big : 和bucket相反. 例11：匹配远程地址和端口号ss dst ADDRESS_PATTERNss dst 192.168.1.5ss dst 192.168.119.113:httpss dst 192.168.119.113:smtpss dst 192.168.119.113:443 例12：匹配本地地址和端口号ss src ADDRESS_PATTERNss src 192.168.119.103ss src 192.168.119.103:httpss src 192.168.119.103:80ss src 192.168.119.103:smtpss src 192.168.119.103:25 例13：将本地或者远程端口和一个数比较ss dport OP PORTss sport OP PORT ss dport OP PORT 远程端口和一个数比较；ss sport OP PORT 本地端口和一个数比较。OP 可以代表以下任意一个:&lt;= or le : 小于或等于端口号&gt;= or ge : 大于或等于端口号&gt;== or eq : 等于端口号!= or ne : 不等于端口号&lt; or gt : 小于端口号&gt; or lt : 大于端口号 例14：ss 和 netstat 效率对比time netstat -attime ss 用time 命令分别获取通过netstat和ss命令获取程序和概要占用资源所使用的时间。在服务器连接数比较多的时候，netstat的效率完全没法和ss比。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[linux命令学习之网络命令-traceroute命令]]></title>
      <url>%2F2017%2F03%2F30%2Flinux%E5%91%BD%E4%BB%A4%E5%AD%A6%E4%B9%A0-%E7%BD%91%E7%BB%9C%E5%91%BD%E4%BB%A4%E4%B9%8Btraceroute%E5%91%BD%E4%BB%A4%2F</url>
      <content type="text"><![CDATA[traceroute简介通过traceroute可以知道信息从你的计算机到互联网另一端的主机是走的什么路径。每次数据包由某一同样的出发点（source）到达某一同样的目的地(destination)走的路径可能会不一样，但基本上来说大部分时候所走的路由是相同的。linux系统中，我们称之为traceroute,在MS Windows中为tracert。 traceroute通过发送小的数据包到目的设备直到其返回，来测量其需要多长时间。一条路径上的每个设备traceroute要测3次。输出结果中包括每次测试的时间(ms)和设备的名称（如有的话）及其IP地址。在大多数情况下，在linux主机系统下，直接执行命令行：traceroute hostname而在Windows系统下是执行tracert的命令：tracert hostname traceroute工作原理Traceroute程序的设计是利用ICMP及IP header的TTL（Time To Live）栏位（field）。 首先，traceroute送出一个TTL是1的IP datagram（其实，每次送出的为3个40字节的包，包括源地址，目的地址和包发出的时间标签）到目的地，当路径上的第一个路由器（router）收到这个datagram时，它将TTL减1。此时，TTL变为0了，所以该路由器会将此datagram丢掉，并送回一个「ICMP time exceeded」消息（包括发IP包的源地址，IP包的所有内容及路由器的IP地址），traceroute 收到这个消息后，便知道这个路由器存在于这个路径上，接着traceroute 再送出另一个TTL是2 的datagram，发现第2 个路由器。 traceroute 每次将送出的datagram的TTL 加1来发现另一个路由器，这个重复的动作一直持续到某个datagram 抵达目的地。当datagram到达目的地后，该主机并不会送回ICMP time exceeded消息，因为它已是目的地了，那么traceroute如何得知目的地到达了呢？ Traceroute在送出UDP datagrams到目的地时，它所选择送达的port number 是一个一般应用程序都不会用的号码（30000 以上），所以当此UDP datagram 到达目的地后该主机会送回一个「ICMP port unreachable」的消息，而当traceroute 收到这个消息时，便知道目的地已经到达了。所以traceroute 在Server端也是没有所谓的Daemon 程式。 Traceroute提取发 ICMP TTL到期消息设备的IP地址并作域名解析。每次 ，Traceroute都打印出一系列数据,包括所经过的路由设备的域名及 IP地址,三个包每次来回所花时间。 命令学习命令格式：traceroute[参数][主机] 命令功能：traceroute指令让你追踪网络数据包的路由途径，预设数据包大小是40Bytes，用户可另行设置。具体参数格式：traceroute [-dFlnrvx][-f&lt;存活数值&gt;][-g&lt;网关&gt;…][-i&lt;网络界面&gt;][-m&lt;存活数值&gt;][-p&lt;通信端口&gt;][-s&lt;来源地址&gt;][-t&lt;服务类型&gt;][-w&lt;超时秒数&gt;][主机名称或IP地址][数据包大小] 命令参数：-d 使用Socket层级的排错功能。-f 设置第一个检测数据包的存活数值TTL的大小。-F 设置勿离断位。-g 设置来源路由网关，最多可设置8个。-i 使用指定的网络界面送出数据包。-I 使用ICMP回应取代UDP资料信息。-m 设置检测数据包的最大存活数值TTL的大小。-n 直接使用IP地址而非主机名称。-p 设置UDP传输协议的通信端口。-r 忽略普通的Routing Table，直接将数据包送到远端主机上。-s 设置本地主机送出数据包的IP地址。-t 设置检测数据包的TOS数值。-v 详细显示指令的执行过程。-w 设置等待远端主机回报的时间。-x 开启或关闭数据包的正确性检验。 常用范例例1：traceroute 用法简单、最常用的用法traceroute www.baidu.com 记录按序列号从1开始，每个纪录就是一跳 ，每跳表示一个网关，我们看到每行有三个时间，单位是 ms，其实就是-q的默认参数。探测数据包向每个网关发送三个数据包后，网关响应后返回的时间；如果您用 traceroute -q 4 www.58.com ，表示向每个网关发送4个数据包。有时我们traceroute 一台主机时，会看到有一些行是以星号表示的。出现这样的情况，可能是防火墙封掉了ICMP的返回信息，所以我们得不到什么相关的数据包返回数据。有时我们在某一网关处延时比较长，有可能是某台网关比较阻塞，也可能是物理设备本身的原因。当然如果某台DNS出现问题时，不能解析主机名、域名时，也会 有延时长的现象；您可以加-n 参数来避免DNS解析，以IP格式输出数据。如果在局域网中的不同网段之间，我们可以通过traceroute 来排查问题所在，是主机的问题还是网关的问题。如果我们通过远程来访问某台服务器遇到问题时，我们用到traceroute 追踪数据包所经过的网关，提交IDC服务商，也有助于解决问题；但目前看来在国内解决这样的问题是比较困难的，就是我们发现问题所在，IDC服务商也不可能帮助我们解决。 例2：跳数设置traceroute -m 10 www.baidu.com 例3：显示IP地址，不查主机名traceroute -n www.baidu.com 例4：探测包使用的基本UDP端口设置6888traceroute -p 6888 www.baidu.com 例5：把探测包的个数设置为值4traceroute -q 4 www.baidu.com 例6：绕过正常的路由表，直接发送到网络相连的主机 traceroute -r www.baidu.com 例7：把对外发探测包的等待响应时间设置为3秒traceroute -w 3 www.baidu.com]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[linux文件类型与扩展名]]></title>
      <url>%2F2017%2F03%2F30%2Flinux%E6%96%87%E4%BB%B6%E7%B1%BB%E5%9E%8B%E4%B8%8E%E6%89%A9%E5%B1%95%E5%90%8D%2F</url>
      <content type="text"><![CDATA[linux文件类型与扩展名文件类型Linux文件类型常见的有：普通文件、目录文件、字符设备文件和块设备文件、符号链接文件等。1. 普通文件我们用 ls -lh 来查看某个文件的属性，可以看到有类似-rwxrwxrwx，值得注意的是第一个符号是 - ，这样的文件在Linux中就是普通文件。这些文件一般是用一些相关的应用程序创建，比如图像工具、文档工具、归档工具或 cp工具等。这类文件的删除方式是用rm 命令。 另外，依照文件的内容，又大略可以分为：1&gt;. 纯文本档(ASCII)：Linux系统中最多的一种文件类型，称为纯文本档是因为内容为我们可以直接读到的数据，例如数字、字母等等。 几乎只要我们可以用来做为设定的文件都属于这一种文件类型。举例来说，你可以用命令： cat ~/.bashrc 来看到该文件的内容。 (cat 是将一个文件内容读出来的指令).2&gt;. 二进制文件(binary)：Linux系统其实仅认识且可以执行二进制文件(binary file)。Linux当中的可执行文件(scripts, 文字型批处理文件不算)就是这种格式的文件。 使用的命令cat就是一个binary file。3&gt;. 数据格式文件(data)：有些程序在运作的过程当中会读取某些特定格式的文件，那些特定格式的文件可以被称为数据文件 (data file)。举例来说，我们的Linux在使用者登录时，都会将登录的数据记录在 /var/log/wtmp那个文件内，该文件是一个data file，能够透过last这个指令读出来！ 但是使用cat时，会读出乱码～因为他是属于一种特殊格式的文件 2. 目录文件当我们在某个目录下执行，看到有类似 drwxr-xr-x ，这样的文件就是目录，目录在Linux是一个比较特殊的文件。注意它的第一个字符是d。创建目录的命令可以用 mkdir 命令，或cp命令，cp可以把一个目录复制为另一个目录。删除用rm 或rmdir命令。 3. 字符设备或块设备文件如时您进入/dev目录，列一下文件，会看到类似如下的:[root@localhost ~]# ls -al /dev/ttycrw-rw-rw- 1 root tty 5, 0 11-03 15:11 /dev/tty[root@localhost ~]# ls -la /dev/sda1brw-r—– 1 root disk 8, 1 11-03 07:11 /dev/sda1我们看到/dev/tty的属性是 crw-rw-rw- ，前面第一个字符是 c ，表示字符设备文件。比如猫等串口设备。我们看到 /dev/sda1 的属性是 brw-r—– ，注意前面的第一个字符是b，这表示块设备，比如硬盘，光驱等设备。这个种类的文件，是用mknode来创建，用rm来删除。目前在最新的Linux发行版本中，我们一般不用自己来创建设备文件。因为这些文件是和内核相关联的。与系统周边及储存等相关的一些文件， 通常都集中在/dev这个目录之下！通常又分为两种：区块(block)设备档 ：就是一些储存数据， 以提供系统随机存取的接口设备。举例来说，硬盘与软盘等就是！ 可以随机的在硬盘的不同区块读写。可以自行查一下/dev/sda看看， 会发现第一个属性为[ b ]！字符(character)设备文件：一些串行端口的接口设备， 例如键盘、鼠标等等！这些设备的特色就是一次性读取，不能够截断输出。 举例来说，你不可能让鼠标跳到另一个画面，而是滑动到另一个地方！第一个属性为 [ c ]。 4. 数据接口文件(sockets)：数据接口文件（套接口文件），这种类型的文件通常被用在网络上的数据承接了。我们可以启动一个程序来监听客户端的要求， 而客户端就可以透过这个socket来进行数据的沟通了。第一个属性为 [ s ]， 最常在/var/run这个目录中看到这种文件类型了。例如：当我们启动MySQL服务器时，会产生一个mysql.sock的文件。[root@localhost ~]# ls -lh /var/lib/mysql/mysql.socksrwxrwxrwx 1 mysql mysql 0 04-19 11:12 /var/lib/mysql/mysql.sock注意这个文件的属性的第一个字符是 s。 5. 符号链接文件：当我们查看文件属性时，会看到有类似 lrwxrwxrwx,注意第一个字符是l，这类文件是链接文件。通过ln -s 源文件名 新文件名 。和Windows操作系统中的快捷方式有点相似。 6. 数据输送文件（FIFO,pipe）FIFO也是一种特殊的文件类型，他主要的目的在解决多个程序同时存取一个文件所造成的错误问题。 FIFO是first-in-first-out的缩写。第一个属性为[p] 。 文件扩展名1. 扩展名类型Linux的文件是没有所谓的扩展名的，一个Linux文件能不能被执行，与他的第一栏的十个属性有关，与文档名根本一点关系也没有。这个观念跟Windows的情况不相同！在Windows底下，能被执行的文件扩展名通常是 .com .exe .bat等等，而在Linux底下，只要你的权限当中具有x的话，例如[ -rwx-r-xr-x ] 即代表这个文件可以被执行。不过，可以被执行跟可以执行成功是不一样的举例来说，在root家目录下的install.log 是一个纯文本档，如果经由修改权限成为 -rwxrwxrwx 后，这个文件能够真的执行成功吗？ 当然不行。因为他的内容根本就没有可以执行的数据。所以说，这个x代表这个文件具有可执行的能力， 但是能不能执行成功，当然就得要看该文件的内容。所以，通常我们还是会以适当的扩展名来表示该文件是什么种类的。底下有数种常用的扩展名：.sh ： 脚本或批处理文件 (scripts)，因为批处理文件为使用shell写成的，所以扩展名就编成 .sh Z, .tar, .tar.gz, .zip, .tgz： 经过打包的压缩文件。这是因为压缩软件分别为 gunzip, tar 等等的，由于不同的压缩软件，而取其相关的扩展名！.html, .php：网页相关文件，分别代表 HTML 语法与 PHP 语法的网页文件。 .html 的文件可使用网页浏览器来直接开启，至于 .php 的文件， 则可以透过 client 端的浏览器来 server 端浏览，以得到运算后的网页结果。基本上，Linux系统上的文件名真的只是让你了解该文件可能的用途而已，真正的执行与否仍然需要权限的规范才行。例如虽然有一个文件为可执行文件，如常见的/bin/ls这个显示文件属性的指令，不过，如果这个文件的权限被修改成无法执行时，那么ls就变成不能执行。上述的这种问题最常发生在文件传送的过程中。例如你在网络上下载一个可执行文件，但是偏偏在你的 Linux系统中就是无法执行！那么就是可能文件的属性被改变了。从网络上传送到你的 Linux系统中，文件的属性与权限确实是会被改变的。 2. Linux文件名长度限制在Linux底下，使用预设的Ext2/Ext3文件系统时，针对文件名长度限制为：单一文件或目录的最大容许文件名为 255 个字符包含完整路径名称及目录 (/) 之完整档名为 4096 个字符 3. Linux文件名的字符的限制由于Linux在文字接口下的一些指令操作关系，一般来说，在设定Linux底下的文件名时， 最好可以避免一些特殊字符比较好！例如这些： ? &gt; &lt; ; &amp; ! [ ] | \ ‘ “ ` ( ) { } 因为这些符号在文字接口下，是有特殊意义的。另外，文件名的开头为小数点“.”时， 代表这个文件为隐藏文件！同时，由于指令下达当中，常常会使用到 -option 之类的选项， 所以最好也避免将文件档名的开头以 - 或 + 来命名。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[linux目录结构]]></title>
      <url>%2F2017%2F03%2F30%2Flinux%E7%9B%AE%E5%BD%95%E7%BB%93%E6%9E%84%2F</url>
      <content type="text"><![CDATA[linux目录结构简介当在使用Linux的时候，如果通过ls –l / 就会发现，在/下包含很多的目录，比如etc、usr、var、bin … … 等目录，而在这些目录中，我们进去看看，发现也有很多的目录或文件。文件系统在Linux下看上去就象树形结构，所以可以把文件系统的结构形象的称为 树形结构。文件系统的是用来组织和排列文件存取的，所以是可见的，在Linux中，可以通过ls等工具来查看其结构，在Linux系统中，我们见到的都是树形结构；比如操作系统安装在一个文件系统中，他表现为由/ 起始的树形结构。linux文件系统的最顶端是/，我们称/为Linux的root，也就是 Linux操作系统的文件系统。 Linux的文件系统的入口就是/，所有的目录、文件、设备都在/之下，/就是Linux文件系统的组织者，也是最上级的领导者。 目录结构学习目录定义成为四种交互作用的形态 ：四中类型:1. 可分享的：可以分享给其他系统挂载使用的目录，所以包括执行文件与用户的邮件等数据， 是能够分享给网络上其他主机挂载用的目录；2. 不可分享的：自己机器上面运作的装置文件或者是与程序有关的socket文件等， 由于仅与自身机器有关，所以当然就不适合分享给其他主机了。3. 不变的：有些数据是不会经常变动的，跟随着distribution而不变动。 例如函式库、文件说明文件、系统管理员所管理的主机服务配置文件等等；4. 可变动的：经常改变的数据，例如登录文件、一般用户可自行收受的新闻组等。 FHS针对目录树架构仅定义出三层目录底下应该放置什么数据而已，分别是底下这三个目录的定义：/ (root, 根目录)：与开机系统有关；/usr (unix software resource)：与软件安装/执行有关；/var (variable)：与系统运作过程有关。 一. 根目录 (/) 的意义与内容：根目录是整个系统最重要的一个目录，因为不但所有的目录都是由根目录衍生出来的， 同时根目录也与开机/还原/系统修复等动作有关。 由于系统开机时需要特定的开机软件、核心文件、开机所需程序、 函式库等等文件数据，若系统出现错误时，根目录也必须要包含有能够修复文件系统的程序才行。 因为根目录是这么的重要，所以在FHS的要求方面，他希望根目录不要放在非常大的分区， 因为越大的分区内你会放入越多的数据，如此一来根目录所在分区就可能会有较多发生错误的机会。因此FHS标准建议：根目录(/)所在分区应该越小越好， 且应用程序所安装的软件最好不要与根目录放在同一个分区内，保持根目录越小越好。 如此不但效能较佳，根目录所在的文件系统也较不容易发生问题。（根目录和Windows的C盘一个样）根据以上原因，FHS认为根目录(/)下应该包含如下子目录：事实上FHS针对根目录所定义的标准就仅限于上表，不过仍旧有些目录也需要了解一下，具体如下： 除了这些目录的内容之外，另外要注意的是，因为根目录与开机有关，开机过程中仅有根目录会被挂载， 其他分区则是在开机完成之后才会持续的进行挂载的行为。就是因为如此，因此根目录下与开机过程有关的目录， 就不能够与根目录放到不同的分区去。有底下这些：/etc：配置文件/bin：重要执行档/dev：所需要的装置文件/lib：执行档所需的函式库与核心所需的模块/sbin：重要的系统执行文件五个目录千万不可与根目录分开在不同的分区。 二. /usr 的意义与内容：依据FHS的基本定义，/usr里面放置的数据属于可分享的与不可变动的，如果你知道如何透过网络进行分区的挂载(例如在服务器篇会谈到的NFS服务器)，那么/usr确实可以分享给局域网络内的其他主机来使用。/usr不是user的缩写，其实usr是Unix Software Resource的缩写， 也就是Unix操作系统软件资源所放置的目录，而不是用户的数据。 FHS建议所有软件开发者，应该将他们的数据合理的分别放置到这个目录下的次目录，而不要自行建立该软件自己独立的目录。因为是所有系统默认的软件(distribution发布者提供的软件)都会放置到/usr底下，因此这个目录有点类似Windows 系统的C:\Windows\ + C:\Program files\这两个目录的综合体，系统刚安装完毕时，这个目录会占用最多的硬盘容量。 一般来说，/usr的次目录建议有底下这些： 三. /var 的意义与内容如果/usr是安装时会占用较大硬盘容量的目录，那么/var就是在系统运作后才会渐渐占用硬盘容量的目录。 因为/var目录主要针对常态性变动的文件，包括缓存(cache)、登录档(log file)以及某些软件运作所产生的文件， 包括程序文件(lock file, run file)，或者例如MySQL数据库的文件等等。常见的次目录有：由于FHS仅是定义出最上层(/)及次层(/usr, /var)的目录内容应该要放置的文件或目录数据， 因此，在其他次目录层级内，就可以随开发者自行来配置了。 四. 目录树(directory tree)在Linux底下，所有的文件与目录都是由根目录开始的。那是所有目录与文件的源头, 然后再一个一个的分支下来，因此，我们也称这种目录配置方式为：目录树(directory tree), 这个目录树的主要特性有：目录树的启始点为根目录 (/, root)；每一个目录不止能使用本地端的 partition 的文件系统，也可以使用网络上的 filesystem 。举例来说， 可以利用 Network File System (NFS) 服务器挂载某特定目录等。每一个文件在此目录树中的文件名(包含完整路径)都是独一无二的。如果我们将整个目录树以图的方法来显示，并且将较为重要的文件数据列出来的话，那么目录树架构就如下图 五. 绝对路径与相对路径除了需要特别注意的FHS目录配置外，在文件名部分也要特别注意。因为根据档名写法的不同，也可将所谓的路径(path)定义为绝对路径(absolute)与相对路径(relative)。 这两种文件名/路径的写法依据是这样的：绝对路径：由根目录(/)开始写起的文件名或目录名称， 例如 /home/dmtsai/.bashrc；相对路径：相对于目前路径的文件名写法。 例如 ./home/dmtsai 或 http://www.cnblogs.com/home/dmtsai/ 等等。反正开头不是 / 就属于相对路径的写法必须要了解，相对路径是以你当前所在路径的相对位置来表示的。举例来说，你目前在 /home 这个目录下， 如果想要进入 /var/log 这个目录时，可以怎么写呢？cd /var/log (absolute)cd ../var/log (relative)因为你在 /home 底下，所以要回到上一层 (../) 之后，才能继续往 /var 来移动的，特别注意这两个特殊的目录：. ：代表当前的目录，也可以使用 ./ 来表示；.. ：代表上一层目录，也可以 ../ 来代表。这个 . 与 .. 目录概念是很重要的，你常常会看到 cd .. 或 ./command 之类的指令下达方式， 就是代表上一层与目前所在目录的工作状态。实例1：如何先进入/var/spool/mail/目录，再进入到/var/spool/cron/目录内？命令：cd /var/spool/mailcd ../cron说明：由于/var/spool/mail与/var/spool/cron是同样在/var/spool/目录中。如此就不需要在由根目录开始写起了。实例2：网络文件常常提到类似./run.sh之类的数据，这个指令的意义为何？说明：由于指令的执行需要变量的支持，若你的执行文件放置在本目录，并且本目录并非正规的执行文件目录(/bin, /usr/bin等为正规)，此时要执行指令就得要严格指定该执行档。./代表本目录的意思，所以./run.sh代表执行本目录下， 名为run.sh的文件。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[linux终端设备-基本类型]]></title>
      <url>%2F2017%2F03%2F30%2Flinux%E7%BB%88%E7%AB%AF%E8%AE%BE%E5%A4%87%E5%AD%A6%E4%B9%A0%E2%80%94%E5%9F%BA%E6%9C%AC%E7%B1%BB%E5%9E%8B%2F</url>
      <content type="text"><![CDATA[linux终端设备类型linux下有多种终端设备类型，包括当前终端，前台控制终断，串口以及虚拟终端主设备。可在linux的/proc/tty下查看各设备的基本信息。将这些终端设备统一由TTY管理，从而屏蔽硬件实现。同时，将所有的设备分别映射成一个文件（设备文件）。因此，可由文件管理函数IO函数操作这些文件，达到控制终端设备的目的。 实际的物理串口串口终端/dev/ttyS[n],ttyS系列指物理串行接口，即ttyS0为COM1,ttyS1为COM2。在/sys下的主次设备号如下：即物理串口设备主设备好为4，次设备号从64开始。相关的资源信息： 可通过如下命令想串口发送数据：echo ttyS1&gt;/dev/ttyS1echo hello world &gt;/dev/ttys1虚拟机下：采用windows的文件来代替串口，然后在window下查看该文件内容。设置：虚拟机下的setting中设置add一个串口设备号（没有要再关机情况下添加）,添加后在底部图标可看到添加的串口号以及window下的文件。 控制台终端tty1-tty6为控制台终端，即非图像界面下的命令行输入模式。控制台终端设备主设备号为4，次设备号从1开始 虚拟终端当下多数使用linux都是通过网络连接到服务器的方式，如telent和ssh工具。如果是在服务器的图像界面下，运行命令一般会打开一个虚拟终端窗口。这两类情况在服务器上显示的是虚拟网络终端。虚拟网络终端有两个虚拟设备：/dev/ptmx和/dev/pts /dev/ptmx虚拟设备/dev/ptmx是一个字符文件，用于创建虚拟网络终端设备master/slave配对设备。要打开一个未使用的虚拟终端，通过调用posix_openpt()函数，来打开/dev/ptmx设备。每次open打开这个文件，返回一个独立的master设备的文件描述符，可通过这个描述符找到关联的slave设备，且slave设备会在/dev/pts/目录下创建。 /dev/pts虚拟终端通过网络telent到linux主机或者windows环境下打开一个终端，将在/dev/pts目录下依次创建一个虚拟终端设备，相应地退出一个虚拟终端，将自动减少一个设备文件。 当前终端当前控制台终端/dev/console/dev/console代表当前系统使用的实际控制台终端（tty1-tty6）。/dev/console设备号信息如下：其主设备号为5，次设备号为1.它始终代表当前主机打开的实际控制台终端 当前终端/dev/tty/dev/tty代表当前终端，无论是通过控制台终端还是虚拟终端，/dev/tty都代表自己。该设备信息如下：在任意终端下。如telent下连接终端执行，即向/dev/tty发送消息，会直接回显]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[linux命令学习之磁盘命令-du命令]]></title>
      <url>%2F2017%2F03%2F30%2Flinux%E5%91%BD%E4%BB%A4%E5%AD%A6%E4%B9%A0-%E7%A3%81%E7%9B%98%E5%91%BD%E4%BB%A4%E4%B9%8Bdu%E5%91%BD%E4%BB%A4%2F</url>
      <content type="text"><![CDATA[du简介 du命令也是查看使用空间的，但是与df命令不同的是du命令是对文件和目录磁盘使用的空间的查看。 命令学习 命令格式：du [选项][文件] 命令功能：显示每个文件和目录的磁盘使用空间。 命令参数：-a或-all 显示目录中个别文件的大小。-b或-bytes 显示目录或文件大小时，以byte为单位。-c或–total 除了显示个别目录或文件的大小外，同时也显示所有目录或文件的总和。-k或–kilobytes 以KB(1024bytes)为单位输出。-m或–megabytes 以MB为单位输出。-s或–summarize 仅显示总计，只列出最后加总的值。-h或–human-readable 以K，M，G为单位，提高信息的可读性。-x或–one-file-xystem 以一开始处理时的文件系统为准，若遇上其它不同的文件系统目录则略过。-L&lt;符号链接&gt;或–dereference&lt;符号链接&gt; 显示选项中所指定符号链接的源文件大小。-S或–separate-dirs 显示个别目录的大小时，并不含其子目录的大小。-X&lt;文件&gt;或–exclude-from=&lt;文件&gt; 在&lt;文件&gt;指定目录或文件。–exclude=&lt;目录或文件&gt; 略过指定的目录或文件。–max-depth=&lt;目录层数&gt; 超过指定层数的目录后，予以忽略。-D或–dereference-args 显示指定符号链接的源文件大小。-H或–si 与-h参数相同，但是K，M，G是以1000为换算单位。 -l或–count-links 重复计算硬件链接的文件。 常用范例 例1：显示目录或者文件所占空间du只显示当前目录下面的子目录的目录大小和当前目录的总的大小，最下面的当前目录的总大小 例2：显示指定文件所占空间du 1.log 例3：查看指定目录的所占空间du test1 例4：显示多个文件所占空间du 1.log 2.log 例5：只显示总和的大小 例6：方便阅读的格式显示 例7：文件和目录都显示du -h test1 例8：显示几个文件或目录各自占用磁盘空间的大小，还统计它们的总和du -c 1.log 2.log 例9：按照空间大小排序 du|sort -nr|more 例10：输出当前目录下各个子目录所使用的空间 du -h –max-depth=1表示深入的目录层数，为0则不深入子目录，1则进入第一层子目录]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[python3面向对象编程]]></title>
      <url>%2F2017%2F03%2F30%2Fpython%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B%2F</url>
      <content type="text"><![CDATA[面向对象编程面向对象编程——Object Oriented Programming，简称OOP，是一种程序设计思想。OOP把对象作为程序的基本单元，一个对象包含了数据和操作数据的函数。 面向过程把函数继续切分为子函数，即把大块函数通过切割成小块函数来降低系统的复杂度。而面向对象的程序设计把计算机程序视为一组对象的集合，而每个对象都可以接收其他对象发过来的消息，并处理这些消息，计算机程序的执行就是一系列消息在各个对象之间传递。 在Python中，所有数据类型都可以视为对象，也可以自定义对象。自定义的对象数据类型就是面向对象中的类（Class）的概念。如果要打印一个学生的成绩，首先必须创建出这个学生对应的对象，然后，给对象发一个print_score消息，让对象自己把自己的数据打印出来。 class Student(object): def __init__(self, name, score): self.name = name self.score = score def print_score(self): print(&apos;%s: %s&apos; % (self.name, self.score)) 给对象发消息实际上就是调用对象对应的关联函数，称之为对象的方法（Method）。面向对象的程序写出来就像这样： bart = Student(&apos;Bart Simpson&apos;, 59) lisa = Student(&apos;Lisa Simpson&apos;, 87) bart.print_score() lisa.print_score() Class是一种抽象概念，比如我们定义的Class——Student，是指学生这个概念，而实例（Instance）则是一个个具体的Student，比如，Bart Simpson和Lisa Simpson是两个具体的Student。 类和实例类是抽象的模板，比如Student类，而实例是根据类创建出来的一个个具体的“对象”，每个对象都拥有相同的方法，但各自的数据可能不同。 定义类是通过class关键字，(object)表示该类是从哪个类继承下来。如果没有合适的继承类，就使用object类，这是所有类最终都会继承的类。 class Student(object): pass 创建实例是通过类名+()实现的： bart = Student() 类可以起到模板的作用，可以在创建实例的时候，把一些认为必须绑定的属性强制填写进去。通过定义一个特殊的init方法，在创建实例的时候，就把name，score等属性绑上去： class Student(object): def __init__(self, name, score): self.name = name self.score = score __init__方法的第一个参数永远是self，表示创建的实例本身，因此，在__init__方法内部，就可以把各种属性绑定到self，因为self就指向创建的实例本身。有了__init__方法，在创建实例的时候，必须传入与init方法匹配的参数，但self不需要传，Python解释器自己会把实例变量传进去： 数据封装封装的另一个好处是可以给Student类增加新的方法。要定义一个方法，除了第一个参数是self外，其他和普通函数一样。要调用一个方法，只需要在实例变量上直接调用，除了self不用传递，其他参数正常传入 class Student(object): def __init__(self,name,score): self.name=name self.score=score def print_score(self): print(&apos;%s:%s&apos;%(self.name,self.score)) def get_grade(self): if self.score&gt;=90: return &apos;A&apos; elif self.score&gt;=60: return &apos;B&apos; else: return &apos;C&apos; bart =Student(&apos;bart simpson&apos;, 59) lisa =Student(&apos;lisa simpson&apos;, 87) print(&apos;bart.name=&apos;, bart.name) print(&apos;bart.score&apos;, bart.score) bart.print_score() print(&apos;grade of bart&apos;, bart.get_grade()) print(&apos;grade of lisa&apos;, bart.get_grade()) #结果： bart.name= bart simpson bart.score 59 bart simpson:59 grade of bart C grade of lisa C 访问限制在Class内部，可以有属性和方法，而外部代码可以通过直接调用实例变量的方法来操作数据。 如果要让内部属性不被外部访问，可以把属性的名称前加上两个下划线__，在Python中，实例的变量名如果以__开头，就变成了一个私有变量（private），只有内部可以访问，外部不能访问.这样就确保了外部代码不能随意修改对象内部的状态，通过访问限制的保护，代码更加健壮。 class Student(object): def __init__(self, name, score): self.__name = name self.__score = score def print_score(self): print(&apos;%s: %s&apos; % (self.__name, self.__score)) 如果又要允许外部代码修改score可以再给Student类增加set_score方法： def set_score(self, score): self.__score = score 在方法中，也可以对参数做检查，避免传入无效的参数： def set_score(self, score): if 0 &lt;= score &lt;= 100: self.__score = score else: raise ValueError(&apos;bad score&apos;) 在Python中，变量名类似__xxx__的，也就是以双下划线开头，并且以双下划线结尾的，是特殊变量，特殊变量是可以直接访问的，不是private变量，所以，不能用__name__、__score__这样的变量名。 &gt;&gt;&gt; bart = Student(&apos;Bart Simpson&apos;, 98) &gt;&gt;&gt; bart.get_name() &apos;Bart Simpson&apos; &gt;&gt;&gt; bart.__name = &apos;New Name&apos; # 设置__name变量！ &gt;&gt;&gt; bart.__name &apos;New Name&apos; &gt;&gt;&gt; bart.get_name() # get_name()内部返回self.__name &apos;Bart Simpson&apos; 表面上看，外部代码“成功”地设置了__name变量，但实际上这个__name变量和class内部的__name变量不是一个变量！内部的__name变量已经被Python解释器自动改成了_Student__name，而外部代码给bart新增了一个__name变量。 继承和多态定义一个class的时候，可以从某个现有的class继承，新的class称为子类（Subclass），而被继承的class称为基类、父类或超类（Base class、Super class）。继承最大的好处是子类获得了父类的全部功能。 继承的另一个好处就是多态。当子类和父类都存在相同的run()方法时，子类的方法会覆盖了父类的方法，在代码运行的时候，总是会调用子类的run()。 在继承关系中，如果一个实例的数据类型是某个子类，那它的数据类型也可以被看做是父类。但是，反过来就不行 多态真正的威力：调用方只管调用，不管细节，而当我们新增一种Animal的子类时，只要确保run()方法编写正确，不用管原来的代码是如何调用的。这就是著名的“开闭”原则：对扩展开放：允许新增Animal子类；对修改封闭：不需要修改依赖Animal类型的run_twice()等函数。 判断对象类型基本类型都可以用type()判断： &gt;&gt;&gt; type(123) &lt;class &apos;int&apos;&gt; &gt;&gt;&gt; type(&apos;str&apos;) &lt;class &apos;str&apos;&gt; &gt;&gt;&gt; 判断一个对象是否是函数：使用types模块中定义的常量 &gt;&gt;&gt; import types &gt;&gt;&gt; type(abs)==types.BuiltinFunctionType True &gt;&gt;&gt; 判断class的类型，可以使用isinstance()函数 isinstance(d, Husky) 实例属性和类属性给实例绑定属性的方法是通过实例变量，或者通过self变量 class Student(object): def __init__(self, name): self.name = name s = Student(&apos;Bob&apos;) s.score = 90 Student类本身可以直接在class中定义属性，这种属性是类属性，归Student类所有，但类的所有实例都可以访问到。不要把实例属性和类属性使用相同的名字，相同名称的实例属性将屏蔽掉类属性，但是当你删除实例属性后，再使用相同的名称，访问到的将是类属性。 class Student(object): name = &apos;Student&apos; __slots__限制实例的属性Python允许在定义class的时候，定义一个特殊的slots变量，来限制该class实例能添加的属性. 除非在子类中也定义__slots__，这样，子类实例允许定义的属性就是自身的__slots__加上父类的__slots__。 class Student(object): __slots__ = (&apos;name&apos;, &apos;age&apos;) # 用tuple定义允许绑定的属性名称 #&apos;score&apos;没有被放到__slots__中，所以不能绑定score属性，试图绑定score将得到AttributeError的错误。 &gt;&gt;&gt; s.score = 99 # 绑定属性&apos;score&apos; Traceback (most recent call last): File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt; AttributeError: &apos;Student&apos; object has no attribute &apos;score&apos; 多重继承class Animal(object): pass # 大类: class Mammal(Animal): pass class Bird(Animal): pass # 各种动物: class Dog(Mammal): pass class Bat(Mammal): pass class Parrot(Bird): pass class Ostrich(Bird): pass 给动物再加上Runnable和Flyable的功能，只需要先定义好Runnable和Flyable的类： class Runnable(object): def run(self): print(&apos;Running...&apos;) class Flyable(object): def fly(self): print(&apos;Flying...&apos;) 对于需要Runnable功能的动物，就多继承一个Runnable，例如Dog： class Dog(Mammal, Runnable): pass 通过多重继承，一个子类就可以同时获得多个父类的所有功能。 为了更好地看出继承关系，把Runnable和Flyable改为RunnableMixIn和FlyableMixIn。MixIn的目的就是给一个类增加多个功能，在设计类的时候，优先考虑通过多重继承来组合多个MixIn的功能，而不是设计多层次的复杂的继承关系。 定制类__str__定义好str()方法，返回一个好看的字符串: &gt;&gt;&gt; class Student(object): ... def __init__(self, name): ... self.name = name ... def __str__(self): ... return &apos;Student object (name: %s)&apos; % self.name ... &gt;&gt;&gt; print(Student(&apos;Michael&apos;)) Student object (name: Michael) __repr__()返回程序开发者看到的字符串，是为调试服务的。通常__str__()和__repr__()代码都是一样的，偷懒的写法: class Student(object): def __init__(self, name): self.name = name def __str__(self): return &apos;Student object (name=%s)&apos; % self.name __repr__ = __str__ __iter__如果一个类想被用于for … in循环，类似list或tuple那样，就必须实现一个iter()方法，该方法返回一个迭代对象，然后，Python的for循环就会不断调用该迭代对象的next()方法拿到循环的下一个值，直到遇到StopIteration错误时退出循环。 class Fib(object): def __init__(self): self.a, self.b = 0, 1 # 初始化两个计数器a，b def __iter__(self): return self # 实例本身就是迭代对象，故返回自己 def __next__(self): self.a, self.b = self.b, self.a + self.b # 计算下一个值 if self.a &gt; 100000: # 退出循环的条件 raise StopIteration() return self.a # 返回下一个值 把Fib实例作用于for循环： &gt;&gt;&gt; for n in Fib(): ... print(n) ###__getitem__ ### Fib实例虽然能作用于for循环，但是把它当成list来使用还是不行，比如，取第5个元素。要表现得像list那样按照下标取出元素，需要实现getitem()方法： class Fib(object): def __getitem__(self, n): a, b = 1, 1 for x in range(n): a, b = b, a + b return a 按下标访问数列的任意一项： &gt;&gt;&gt; f = Fib() &gt;&gt;&gt; f[0] __getattr__正常情况下，当我们调用类的方法或属性时，如果不存在，就会报错。__getattr__()动态返回一个属性 当调用不存在的属性时，比如score，Python解释器会试图调用getattr(self, ‘score’)来尝试获得属性，这样，我们就有机会返回score的值 class Student(object): def __init__(self): self.name = &apos;Michael&apos; def __getattr__(self, attr): if attr==&apos;score&apos;: return 99 ###__call__ ### 一个对象实例可以有自己的属性和方法，任何类只需要定义一个call()方法，就可以直接对实例进行调用。通过callable()函数，我们就可以判断一个对象是否是“可调用”对象。 class Student(object): def __init__(self, name): self.name = name def __call__(self): print(&apos;My name is %s.&apos; % self.name) 调用方式如下： &gt;&gt;&gt; s = Student(&apos;Michael&apos;) &gt;&gt;&gt; s() # self参数不要传入 My name is Michael. 枚举类为枚举类型定义一个class类型，每个常量都是class的一个唯一实例。Python提供了Enum类来实现这个功能，可以直接使用Month.Jan来引用一个常量，或者枚举它的所有成员： from enum import Enum Month = Enum(&apos;Month&apos;, (&apos;Jan&apos;, &apos;Feb&apos;, &apos;Mar&apos;, &apos;Apr&apos;, &apos;May&apos;, &apos;Jun&apos;, &apos;Jul&apos;, &apos;Aug&apos;, &apos;Sep&apos;, &apos;Oct&apos;, &apos;Nov&apos;, &apos;Dec&apos;)) #value属性则是自动赋给成员的int常量，默认从1开始计数。 for name, member in Month.__members__.items(): print(name, &apos;=&gt;&apos;, member, &apos;,&apos;, member.value) 如果需要更精确地控制枚举类型，可以从Enum派生出自定义类,@unique装饰器可以帮助检查保证没有重复值。 from enum import Enum, unique @unique class Weekday(Enum): Sun = 0 # Sun的value被设定为0 Mon = 1 Tue = 2 Wed = 3 Thu = 4 Fri = 5 Sat = 6 访问这些枚举类型,既可以用成员名称引用枚举常量，又可以直接根据value的值获得枚举常量。 &gt;&gt;&gt; print(Weekday.Tue) Weekday.Tue &gt;&gt;&gt; print(Weekday[&apos;Tue&apos;]) Weekday.Tue &gt;&gt;&gt; for name, member in Weekday.__members__.items(): ... print(name, &apos;=&gt;&apos;, member) ... Sun =&gt; Weekday.Sun Mon =&gt; Weekday.Mon Tue =&gt; Weekday.Tue Wed =&gt; Weekday.Wed Thu =&gt; Weekday.Thu Fri =&gt; Weekday.Fri Sat =&gt; Weekday.Sat]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[linux读写串口]]></title>
      <url>%2F2017%2F03%2F30%2Flinux%E8%AF%BB%E5%86%99%E4%B8%B2%E5%8F%A3%2F</url>
      <content type="text"><![CDATA[串口操作串口操作需要的头文件 #include &lt;stdio.h&gt; #include &lt;stdlib.h&gt; #include &lt;unistd.h&gt; #include &lt;sys/types.h&gt; #include &lt;sys/stat.h&gt; #include &lt;fcntl.h&gt; #include &lt;termios.h&gt; #include &lt;errno.&gt; 打开串口在 Linux 下串口文件是位于 /dev 下的串口一 为 /dev/ttyS0串口二 为 /dev/ttyS1打开串口是通过使用标准的文件打开函数操作： int open_port(void) { int fd; fd = open( &quot;/dev/ttyS0&quot;, O_RDWR | O_NOCTTY ); if(-1 == fd) { perror(&quot; 提示错误！&quot;); } return (fd); } O_NOCTTY: 表示当前进程不期望与终端关联，从而避免控制端输入的信息影响当前进程 设置串口最基本的设置串口包括波特率设置，效验位和停止位设置。串口的设置主要是设置 struct termios 结构体的各成员值。 struct termio { unsigned short c_iflag; /* 输入模式标志 */ unsigned short c_oflag; /* 输出模式标志 */ unsigned short c_cflag; /* 控制模式标志*/ unsigned short c_lflag; /* local mode flags */ unsigned char c_line; /* line discipline */ unsigned char c_cc[NCC]; /* control characters */ }; 下面是修改波特率的代码： struct termios Opt; tcgetattr(fd, &amp;Opt); cfsetispeed(&amp;Opt,B19200); /*设置为19200Bps*/ cfsetospeed(&amp;Opt,B19200); tcsetattr(fd,TCANOW,&amp;Opt); 设置波特率的例子函数：/** *@brief 设置串口通信速率 *@param fd 类型 int 打开串口的文件句柄 *@param speed 类型 int 串口速度 *@return void */ int speed_arr[] = { B38400, B19200, B9600, B4800, B2400, B1200, B300, B38400, B19200, B9600, B4800, B2400, B1200, B300, }; int name_arr[] = {38400, 19200, 9600, 4800, 2400, 1200, 300, 38400, 19200, 9600, 4800, 2400, 1200, 300, }; void set_speed(int fd, int speed) { int i; int status; struct termios Opt; tcgetattr(fd, &amp;Opt); for ( i= 0; i &lt; sizeof(speed_arr) / sizeof(int); i++) { if (speed == name_arr[i]) { tcflush(fd, TCIOFLUSH); cfsetispeed(&amp;Opt, speed_arr[i]); cfsetospeed(&amp;Opt, speed_arr[i]); status = tcsetattr(fd1, TCSANOW, &amp;Opt); if (status != 0) { perror(&quot;tcsetattr fd1&quot;); return; } tcflush(fd,TCIOFLUSH); } } } 效验位和停止位的设置：无效验 8位 Option.c_cflag &amp;= ~PARENB; Option.c_cflag &amp;= ~CSTOPB; Option.c_cflag &amp;= ~CSIZE; Option.c_cflag |= ~CS8; 奇效验(Odd) 7位 Option.c_cflag |= ~PARENB; Option.c_cflag &amp;= ~PARODD; Option.c_cflag &amp;= ~CSTOPB; Option.c_cflag &amp;= ~CSIZE; Option.c_cflag |= ~CS7; 偶效验(Even) 7位 Option.c_cflag &amp;= ~PARENB; Option.c_cflag |= ~PARODD; Option.c_cflag &amp;= ~CSTOPB; Option.c_cflag &amp;= ~CSIZE; Option.c_cflag |= ~CS7; Space效验 7位 Option.c_cflag &amp;= ~PARENB; Option.c_cflag &amp;= ~CSTOPB; Option.c_cflag &amp;= &amp;~CSIZE; Option.c_cflag |= CS8; 设置效验的函数： 需要注意的是:如果不是开发终端之类的，只是串口传输数据，而不需要串口来处理，那么使用原始模式(Raw Mode)方式来通讯。设置方式如下： options.c_lflag &amp;= ~(ICANON | ECHO | ECHOE | ISIG); /*Input*/ options.c_oflag &amp;= ~OPOST; /*Output*/ 读写串口设置好串口之后，把串口当作文件读写。发送数据 char buffer[1024]; int Length;int nByte; nByte = write(fd, buffer ,Length) 读取串口数据使用文件操作read函数读取，如果设置为原始模式(Raw Mode)传输数据，那么read函数返回的字符数是实际串口收到的字符数。可以使用操作文件的函数来实现异步读取，如fcntl，或者select等来操作。 char buff[1024];int Len;int readByte = read(fd,buff,Len); 关闭串口关闭串口就是关闭文件。 close(fd);]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[linux命令学习之exec命令]]></title>
      <url>%2F2017%2F03%2F30%2Flinu%E5%91%BD%E4%BB%A4%E5%AD%A6%E4%B9%A0-find%E4%B9%8Bexec%E5%91%BD%E4%BB%A4%2F</url>
      <content type="text"><![CDATA[find之exec简介find一般查找文件，进一步的操作由exec完成。 使用find时，只要把想要的操作写在一个文件里，就可以用exec来配合find查找 命令学习exec解释：-exec 参数后面跟的是command命令，它的终止是以;为结束标志的，考虑到各个系统中分号会有不同的意义，前面加反斜杠。{} 花括号代表前面find查找出来的文件名。在有些操作系统中只允许-exec选项执行诸如l s或ls -l这样的命令。大多数用户使用这一选项是为了查找旧文件并删除它们。建议在真正执行rm命令删除文件之前，最好先用ls命令看一下，确认它们是所要删除的文件exec选项后面跟随着所要执行的命令或脚本，然后是一对儿{ }，一个空格和一个\，最后是一个分号。 为了使用exec选项，必须要同时使用print选项。如果验证一下find命令，会发现该命令只输出从当前路径起的相对路径及文件名。 常用范例例1：ls -l命令放在find命令的-exec选项中find . -type f -exec ls -l {} \;find命令匹配到了当前目录下的所有普通文件，并在-exec选项中使用ls -l命令将它们列出。 例2：在目录中查找更改时间在n日以前的文件并删除它们find . -type f -mtime +14 -exec rm {} \; 例3：在目录中查找更改时间在n日以前的文件并删除它们，在删除之前先给出提示find . -name “*.log” -mtime +5 -ok rm {} \; 例4：-exec中使用grep命令find /etc -name “passwd“ -exec grep “root” {} \;find命令首先匹配所有文件名为“ passwd”的文件，例如passwd、passwd.old、passwd.bak，然后执行grep命令看看在这些文件中是否存在一个root用户。 例5：查找文件移动到指定目录find . -name “*.log” -exec mv {} .. \; 例6：用exec选项执行cp命令find . -name “*.log” -exec cp {} test3 \;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[linux命令学习之文件查找命令——find-exec命令]]></title>
      <url>%2F2017%2F03%2F30%2Flinu%E5%91%BD%E4%BB%A4%E5%AD%A6%E4%B9%A0-%E6%96%87%E4%BB%B6%E6%9F%A5%E6%89%BE%E4%B9%8Bfind-exec%E5%91%BD%E4%BB%A4%2F</url>
      <content type="text"><![CDATA[find之exec简介find一般查找文件，进一步的操作由exec完成。 使用find时，只要把想要的操作写在一个文件里，就可以用exec来配合find查找 命令学习exec解释：-exec 参数后面跟的是command命令，它的终止是以;为结束标志的，考虑到各个系统中分号会有不同的意义，前面加反斜杠。{} 花括号代表前面find查找出来的文件名。在有些操作系统中只允许-exec选项执行诸如l s或ls -l这样的命令。大多数用户使用这一选项是为了查找旧文件并删除它们。建议在真正执行rm命令删除文件之前，最好先用ls命令看一下，确认它们是所要删除的文件exec选项后面跟随着所要执行的命令或脚本，然后是一对儿{ }，一个空格和一个\，最后是一个分号。 为了使用exec选项，必须要同时使用print选项。如果验证一下find命令，会发现该命令只输出从当前路径起的相对路径及文件名。 常用范例例1：ls -l命令放在find命令的-exec选项中find . -type f -exec ls -l {} \;find命令匹配到了当前目录下的所有普通文件，并在-exec选项中使用ls -l命令将它们列出。例2：在目录中查找更改时间在n日以前的文件并删除它们find . -type f -mtime +14 -exec rm {} \; 例3：在目录中查找更改时间在n日以前的文件并删除它们，在删除之前先给出提示find . -name “*.log” -mtime +5 -ok rm {} \; 例4：-exec中使用grep命令find /etc -name “passwd“ -exec grep “root” {} \;find命令首先匹配所有文件名为“ passwd”的文件，例如passwd、passwd.old、passwd.bak，然后执行grep命令看看在这些文件中是否存在一个root用户。 例5：查找文件移动到指定目录find . -name “*.log” -exec mv {} /home/jiangbiao/Test/test4 \; 例6：用exec选项执行cp命令find . -name “*.log” -exec cp {} /home/jiangbiao/Test/test3 \;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[linux命令学习之文件查找命令——find-exec命令]]></title>
      <url>%2F2017%2F03%2F30%2Flinu%E5%91%BD%E4%BB%A4%E5%AD%A6%E4%B9%A0-%E6%96%87%E4%BB%B6%E6%9F%A5%E6%89%BE%E4%B9%8Bfind-xargs%E5%91%BD%E4%BB%A4%2F</url>
      <content type="text"><![CDATA[find之xargs简介在使用 find命令的-exec选项处理匹配到的文件时， find命令将所有匹配到的文件一起传递给exec执行。但有些系统对能够传递给exec的命令长度有限制，这样在find命令运行几分钟之后，就会出现溢出错误。错误信息通常是“参数列太长”或“参数列溢出”。这就是xargs命令的用处所在，特别是与find命令一起使用。find命令把匹配到的文件传递给xargs命令，而xargs命令每次只获取一部分文件而不是全部，这样它可以先处理最先获取的一部分文件，然后是下一批，并如此继续下去。在有些系统中，使用-exec选项会为处理每一个匹配到的文件而发起一个相应的进程，并非将匹配到的文件全部作为参数一次执行；这样在有些情况下就会出现进程过多，系统性能下降的问题，因而效率不高； 而使用xargs命令则只有一个进程。另外，在使用xargs命令时，究竟是一次获取所有的参数，还是分批取得参数，以及每一次获取参数的数目都会根据该命令的选项及系统内核中相应的可调参数来确定。 命令学习-0 当sdtin含有特殊字元时候，将其当成一般字符，/‘空格等-a file 从文件中读入作为sdtin-e flag ，注意有的时候可能会是-E，flag必须是一个以空格分隔的标志，当xargs分析到含有flag这个标志的时候就停止。-p 当每次执行一个argument的时候询问一次用户。-n num 后面加次数，表示命令在执行的时候一次用的argument的个数，默认是用所有的。-t 表示先打印命令，然后再执行。-i 或者是-I，这得看linux支持了，将xargs的每项名称，一般是一行一行赋值给{}，可以用{}代替。-r no-run-if-empty 当xargs的输入为空的时候则停止xargs，不用再去执行了。-s num 命令行的最好字符数，指的是xargs后面那个命令的最大命令行字符数。-L num Use at most max-lines nonblank input lines per command line.-s是含有空格的。-l 同-L-d delim 分隔符，默认的xargs分隔符是回车，argument的分隔符是空格，这里修改的是xargs的分隔符-x exit的意思，主要是配合-s使用。-P 参数会提示让你确认是否执行后面的命令,y执行，n不执行。 常用范例例1： 查找系统中的每一个普通文件，然后使用xargs命令来测试它们分别属于哪类文件find . -type f -print | xargs file 例2:在当前目录下查找所有用户具有读、写和执行权限的文件，并收回相应的写权限find . -perm -7 -print | xargs chmod o-w 例3：用grep命令在所有的普通文件中搜索in这个词find . -type f -print | xargs grep “in” 例4：用grep命令在当前目录下的所有普通文件中搜索hostnames这个词find . -name * -type f -print | xargs grep “hostnames”\用来取消find命令中的*在shell中的特殊含义。 例5：使用xargs执行mvfind . -name “*.log” | xargs -i mv {} test5将当前目录下.log文件移到test5目录下 例6：find后执行xargs提示xargs: argument line too long解决方法find . -type f -atime +0 -print0 | xargs -0 -l1 -t rm -f-l1是一次处理一个；-t是处理之前打印出命令 例7：xargs的-p参数的使用-p参数会提示让你确认是否执行后面的命令,y执行，n不执行。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[linux命令学习之文件查找命令——find参数详解]]></title>
      <url>%2F2017%2F03%2F30%2Flinu%E5%91%BD%E4%BB%A4%E5%AD%A6%E4%B9%A0-%E6%96%87%E4%BB%B6%E6%9F%A5%E6%89%BE%E4%B9%8Bfind%E5%8F%82%E6%95%B0%E8%AF%A6%E8%A7%A3%2F</url>
      <content type="text"><![CDATA[find参数范例1．使用name选项：文件名选项是find命令最常用的选项，要么单独使用该选项，要么和其他选项一起使用。 可以使用某种文件名模式来匹配文件，记住要用引号将文件名模式引起来。用户目录$HOME中查找文件名符合.log的文件，使用~作为 ‘pathname’参数，波浪号~代表了$HOME目录。find ~ -name “.log” -print 想要在当前目录及子目录中查找所有的”.log”文件find . -name “.log” -print 想要的当前目录及子目录中查找文件名以一个大写字母开头的文件find . -name “[A-Z]*” -print 想要在/etc目录中查找文件名以host开头的文件find /etc -name “host*” -print 要想让系统高负荷运行，就从根目录开始查找所有的文件find / -name “*” -print 想在当前目录查找文件名以一个个小写字母开头，最后是4到9加上.log结束的文件find . -name “[a-z]*[4-9].log” -print 2. 用perm选项：按照文件权限模式用-perm选项如在当前目录下查找文件权限位为755的文件，即文件属主可以读、写、执行，其他用户可以读、执行的文件find . -perm 755 -print 数字前面要加一个横杠-，表示都匹配，如-005表示至少005,-757至少757 3．忽略某个目录-prune：如果在查找文件时希望忽略某个目录，因为你知道那个目录中没有你所要查找的文件，那么可以使用-prune选项来指出需要忽略的目录。在使用-prune选项时要当心，因为如果你同时使用了-depth选项，那么-prune选项就会被find命令忽略。find [-path ..] [expression]在路径列表的后面的是表达式-path “test” -prune -o -print 是 -path “test” -a -prune -o -print 的简写表达式按顺序求值, -a 和 -o 都是短路求值，与 shell 的 &amp;&amp; 和 || 类似如果-path “test” 为真，则求值 -prune , -prune 返回真，与逻辑表达式为真；否则不求值 -prune，与逻辑表达式为假。如果 -path “test” -a -prune 为假，则求值 -print ，-print返回真，或逻辑表达式为真；否则不求值 -print，或逻辑表达式为真。这个表达式组合特例可以用伪码写为:if -path “test” then-pruneelse-print 查看Test目录下文件，但不希望在Test/test2目录下查找find Test -path “Test/test2” -prune -o -print 避开多个文件夹:find Test ( -path Test/test2 -o -path Test/test1 ) -prune -o -print圆括号表示表达式的结合。 \ 表示引用，即指示 shell 不对后面的字符作特殊解释，而留给 find 命令去解释其意义。 查找某一确定文件，-name等选项加在-o 之后find Test (-path Test/test2 -o -path test/test1 ) -prune -o -name “*.log” -print 5．使用user和nouser选项：按文件属主查找文件：在$HOME目录中查找文件属主为peida的文件find ~ -user username -print 在/etc目录下查找文件属主为peida的文件:命令：find /etc -user username -print 实例3：为了查找属主帐户已经被删除的文件，可以使用-nouser选项。在/home目录下查找所有的这类文件find /home -nouser -print这样就能够找到那些属主在/etc/passwd文件中没有有效帐户的文件。在使用-nouser选项时，不必给出用户名； find命令能够为你完成相应的工作。 6．使用group和nogroup选项：就像user和nouser选项一样，针对文件所属于的用户组， find命令也具有同样的选项。为了在/apps目录下查找属于gem用户组的文件，可以用：find /apps -group gem -print要查找没有有效所属用户组的所有文件，可以使用nogroup选项。下面的find命令从文件系统的根目录处查找这样的文件:find / -nogroup-print 7．按照更改时间或访问时间等查找文件：如果希望按照更改时间来查找文件，可以使用mtime,atime或ctime选项。如果系统突然没有可用空间了，很有可能某一个文件的长度在此期间增长迅速，这时就可以用mtime选项来查找这样的文件。用减号-来限定更改时间在距今n日以内的文件，而用加号+来限定更改时间在距今n日以前的文件。希望在系统根目录下查找更改时间在5日以内的文件，可以用：find / -mtime -5 -print为了在/var/adm目录下查找更改时间在3日以前的文件，可以用:find /var/adm -mtime +3 -print 8．查找比某个文件新或旧的文件：如果希望查找更改时间比某个文件新但比另一个文件旧的所有文件，可以使用-newer选项。它的一般形式为：newest_file_name ! oldest_file_name其中，！是逻辑非符号。 查找更改时间比文件1log新但比文件3.log旧的文件（包含3.log） 9．使用type选项：在当前目录下查找所有的目录find . -type d -print 在当前目录下查找除目录以外的所有类型的文件find . ! -type d -print 在当前目录下查找所有的符号链接文件find . -type l -print 10．使用size选项：可以按照文件长度来查找文件，这里所指的文件长度既可以用块（block）来计量，也可以用字节来计量。以字节计量文件长度的表达形式为数字加c结尾；以块计量文件长度只用数字表示即可。在按照文件长度查找文件时，一般使用这种以字节表示的文件长度，在查看文件系统的大小，因为这时使用块来计量更容易转换。 在当前目录下查找文件长度大于1 M字节的文件find . -size +1000000c -print 在当前目录下查找文件长度恰好为100字节的文件:find . -size 100c -print 在当前目录下查找长度超过10块的文件（一块等于512字节）find . -size +10 -print 11．使用depth选项：在使用find命令时，可能希望先匹配所有的文件，再在子目录中查找。使用depth选项就可以使find命令这样做。这样做的一个原因就是，当在使用find命令向磁带上备份文件系统时，希望首先备份所有的文件，其次再备份子目录中的文件。下面例子可以看出输出是相反的。 12．使用mount选项：在当前的文件系统中查找文件（不进入其他文件系统），可以使用find命令的mount选项。 从当前目录开始查找位于本文件系统中文件名以XC结尾的文件find . -name “*.XC” -mount -print]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[python3迭代器与生成器]]></title>
      <url>%2F2017%2F03%2F30%2Fpython%E8%BF%AD%E4%BB%A3%E5%99%A8%E4%B8%8E%E7%94%9F%E6%88%90%E5%99%A8%2F</url>
      <content type="text"><![CDATA[迭代器迭代是Python是访问集合元素的一种方式。迭代器是一个可以记住遍历的位置的对象。迭代器对象从集合的第一个元素开始访问，直到所有的元素被访问完结束。迭代器只能往前不会后退。 创建迭代器迭代器有两个基本的方法：iter() 和 next()。字符串，列表或元组对象都可用于创建迭代器： list=[1,2,3,4] it=iter(list) print(next(it)) print(next(it)) 结果： 1 2 迭代器对象可以使用常规for语句进行遍历，或者next()函数： list=[1,2,3,4] it = iter(list) # 创建迭代器对象 for x in it: print (x, end=&quot; &quot;) 或者 import sys # 引入 sys 模块 list=[1,2,3,4] it = iter(list) # 创建迭代器对象 while True: try: print (next(it)) except StopIteration: sys.exit() 生成器受到内存限制，列表容量有限，创建一个包含100万个元素的列表，不仅占用很大的存储空间，如果仅仅需要访问前面几个元素，那后面绝大多数元素占用的空间都白白浪费如果列表元素可以按照某种算法推算出来，那我们是否可以在循环的过程中不断推算出后续的元素呢？这样就不必创建完整的list，从而节省大量的空间。在Python中，这种一边循环一边计算的机制，称为生成器：generator。 创建生成器 列表生成式的[]改成() &gt;&gt;&gt; g = (x * x for x in range(10)) &gt;&gt;&gt; g &lt;generator object &lt;genexpr&gt; at 0x01E5DA20&gt; &gt;&gt;&gt; 可通过next()打印出生成器的每个元素。generator保存的是算法，每次调用next(g)，就计算出g的下一个元素的值，直到计算到最后一个元素，没有更多的元素时，抛出StopIteration的错误。 更好的方法是采用for循环： g = (x * x for x in range(10)) for n in g: print(n) 如果一个函数定义中包含yield关键字，那么这个函数就不再是一个普通函数，而是一个generator。 generator和函数的执行流程不一样。函数是顺序执行，遇到return语句或者最后一行函数语句就返回。而变成generator的函数，在每次调用next()的时候执行，遇到yield语句返回，再次执行时从上次返回的yield语句处继续执行。 定义一个generator，依次返回数字1，3，5： def odd(): print(&apos;step 1&apos;) yield 1 print(&apos;step 2&apos;) yield(3) print(&apos;step 3&apos;) yield(5) 调用该generator时，首先要生成一个generator对象，然后用next()函数不断获得下一个返回值： &gt;&gt;&gt; o = odd() &gt;&gt;&gt; next(o) step 1 1 &gt;&gt;&gt; next(o) step 2 3 &gt;&gt;&gt; next(o) step 3 5 &gt;&gt;&gt; next(o) Traceback (most recent call last): File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt; StopIteration odd不是普通函数，而是generator，在执行过程中，遇到yield就中断，下次又继续执行。执行3次yield后，已经没有yield可以执行了，所以，第4次调用next(o)就报错。 实例使用 yield 实现斐波那契数列： import sys def fibonacci(n): # 生成器函数 - 斐波那契 a, b, counter = 0, 1, 0 while True: if (counter &gt; n): return yield a a, b = b, a + b counter += 1 f = fibonacci(10) # f 是一个迭代器，由生成器返回生成 while True: try: print (next(f), end=&quot; &quot;) except StopIteration: sys.exit()]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[python3网络爬虫实例]]></title>
      <url>%2F2017%2F03%2F30%2Fpython%E7%BD%91%E7%BB%9C%E7%88%AC%E8%99%AB%E7%BB%83%E4%B9%A0%2F</url>
      <content type="text"><![CDATA[简单抓取指定页面 &quot;&quot;&quot; __title__ =first scrapy __author__= chamo &quot;&quot;&quot; &quot;&quot;&quot; 导入相应库 &quot;&quot;&quot; import urllib.request import urllib.error &quot;&quot;&quot; function:抓取指定页面 para1:抓取页面的URL para2:重试下载的次数2 return:解码后的页面html &quot;&quot;&quot; def Scrapy(url,num_retries=2): print(&quot;Downloading :&quot;,url) try: #构建Request请求 req = urllib.request.Request(url) #服务器响应 response=urllib.request.urlopen(url) #读取抓取网页 html=response.read() #解码为utf-8格式 html=html.decode(&quot;utf-8&quot;) except urllib.error.URLError as e: print(&quot;Download error:&quot;,e.reason) html=None if num_retries&gt;0: #500到600之间的错误码一般为服务器问题， 尝试下载 if hasattr (e,&apos;code&apos;) and 500&lt;=e.code&lt;600: return Scrapy(url,num_retries-1) return html if __name__==&quot;__main__&quot;: url = &apos;http://www.csdn.net/&apos; html=Scrapy(url) print(html) 设置随机user_agent&quot;&quot;&quot; __title__ =first scrapy __author__= chamo &quot;&quot;&quot; &quot;&quot;&quot; 导入相应库 &quot;&quot;&quot; import urllib.request import urllib.error import random &quot;&quot;&quot; function:抓取指定页面 para1:抓取页面的URL para2:user_agent para3:重试下载的次数2 return:解码后的页面html &quot;&quot;&quot; def Scrapy(url,user_agent,num_retries=2): print(&quot;Downloading :&quot;,url) try: #构建Request请求 req = urllib.request.Request(url) #随机user_agent req.add_header(&apos;User-Agent&apos;, random.choice(user_agent)) #服务器响应 response=urllib.request.urlopen(url) #读取抓取网页 html=response.read() #解码为utf-8格式 html=html.decode(&quot;utf-8&quot;) except urllib.error.URLError as e: print(&quot;Download error:&quot;,e.reason) html=None if num_retries&gt;0: #500到600之间的错误码一般为服务器问题， 尝试下载 if hasattr (e,&apos;code&apos;) and 500&lt;=e.code&lt;600: return Scrapy(url,num_retries-1) return html if __name__==&quot;__main__&quot;: url = &apos;http://www.csdn.net/&apos; user_agent = [ \ &quot;Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/537.1 (KHTML, like Gecko) Chrome/22.0.1207.1 Safari/537.1&quot;, \ &quot;Mozilla/5.0 (X11; CrOS i686 2268.111.0) AppleWebKit/536.11 (KHTML, like Gecko) Chrome/20.0.1132.57 Safari/536.11&quot;, \ &quot;Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/536.6 (KHTML, like Gecko) Chrome/20.0.1092.0 Safari/536.6&quot;, \ &quot;Mozilla/5.0 (Windows NT 6.2) AppleWebKit/536.6 (KHTML, like Gecko) Chrome/20.0.1090.0 Safari/536.6&quot;, \ &quot;Mozilla/5.0 (Windows NT 6.2; WOW64) AppleWebKit/537.1 (KHTML, like Gecko) Chrome/19.77.34.5 Safari/537.1&quot;, \ &quot;Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/536.5 (KHTML, like Gecko) Chrome/19.0.1084.9 Safari/536.5&quot;, \ &quot;Mozilla/5.0 (Windows NT 6.0) AppleWebKit/536.5 (KHTML, like Gecko) Chrome/19.0.1084.36 Safari/536.5&quot;, \ &quot;Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/536.3 (KHTML, like Gecko) Chrome/19.0.1063.0 Safari/536.3&quot;, \ &quot;Mozilla/5.0 (Windows NT 5.1) AppleWebKit/536.3 (KHTML, like Gecko) Chrome/19.0.1063.0 Safari/536.3&quot;, \ &quot;Mozilla/5.0 (Macintosh; Intel Mac OS X 10_8_0) AppleWebKit/536.3 (KHTML, like Gecko) Chrome/19.0.1063.0 Safari/536.3&quot;, \ &quot;Mozilla/5.0 (Windows NT 6.2) AppleWebKit/536.3 (KHTML, like Gecko) Chrome/19.0.1062.0 Safari/536.3&quot;, \ &quot;Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/536.3 (KHTML, like Gecko) Chrome/19.0.1062.0 Safari/536.3&quot;, \ &quot;Mozilla/5.0 (Windows NT 6.2) AppleWebKit/536.3 (KHTML, like Gecko) Chrome/19.0.1061.1 Safari/536.3&quot;, \ &quot;Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/536.3 (KHTML, like Gecko) Chrome/19.0.1061.1 Safari/536.3&quot;, \ &quot;Mozilla/5.0 (Windows NT 6.1) AppleWebKit/536.3 (KHTML, like Gecko) Chrome/19.0.1061.1 Safari/536.3&quot;, \ &quot;Mozilla/5.0 (Windows NT 6.2) AppleWebKit/536.3 (KHTML, like Gecko) Chrome/19.0.1061.0 Safari/536.3&quot;, \ &quot;Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/535.24 (KHTML, like Gecko) Chrome/19.0.1055.1 Safari/535.24&quot;, \ &quot;Mozilla/5.0 (Windows NT 6.2; WOW64) AppleWebKit/535.24 (KHTML, like Gecko) Chrome/19.0.1055.1 Safari/535.24&quot; ] html=Scrapy(url,user_agent) print(html) 抓取代理IPimport urllib.request from bs4 import BeautifulSoup import re import time import random # ------------------公用方法----------------------- class CommanCalss: def __init__(self): self.header={&apos;User-Agent&apos;:&apos;Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/50.0.2661.94 Safari/537.36&apos;} self.testurl=&quot;www.baidu.com&quot; def getresponse(self,url): req = urllib.request.Request(url, headers=self.header) resp = urllib.request.urlopen(req, timeout=5) content = resp.read() return content def _is_alive(self,proxy): try: resp=0 for i in range(3): proxy_support = urllib.request.ProxyHandler({&quot;http&quot;: proxy}) opener = urllib.request.build_opener(proxy_support) urllib.request.install_opener(opener) req = urllib.request.Request(self.url, headers=self.header) # 访问 resp = urllib.request.urlopen(req, timeout=5) if resp == 200: return True except: return False # -----------------------代理池--------------------- class ProxyPool: def __init__(self,proxy_finder): self.pool=[] self.proxy_finder=proxy_finder self.cominstan=CommanCalss() def get_proxies(self): self.pool=self.proxy_finder.find() for p in self.pool: if self.cominstan._is_alive(p): continue else: self.pool.remove(p) def get_one_proxy(self): return random.choice(self.pool) def writeToTxt(self,file_path): try: fp = open(file_path, &quot;w+&quot;) for item in self.pool: fp.write(str(item) + &quot;\n&quot;) fp.close() except IOError: print(&quot;fail to open file&quot;) #--------------------获取代理方法---------- #定义一个基类 class IProxyFinder: def __init__(self): self.pool = [] def find(self): return #西祠代理爬取 class XiciProxyFinder(IProxyFinder): def __init__(self, url): super(XiciProxyFinder,self).__init__() self.url=url self.cominstan = CommanCalss() def find(self): for i in range(1, 10): content = self.cominstan.getresponse(self.url + str(i)) soup = BeautifulSoup(content,&apos;lxml&apos;) ips = soup.findAll(&apos;tr&apos;) for x in range(2, len(ips)): ip = ips[x] tds = ip.findAll(&quot;td&quot;) if tds == []: continue ip_temp = tds[1].contents[0] + &quot;:&quot; + tds[2].contents[0] self.pool.append(ip_temp) time.sleep(1) return self.pool #-------------------------------------------------------测试---------------------------------------------------- if __name__ == &apos;__main__&apos;: finder = XiciProxyFinder(&quot;http://www.xicidaili.com/wn/&quot;) ppool_instance = ProxyPool(finder) ppool_instance.get_proxies() ppool_instance.writeToTxt(&quot;proxy.txt&quot;) #!/usr/bin/python # -*- coding: UTF-8 -*- #print(&quot;Hello, World!&quot;); #python动态抓取代理IP：代理获取的相关代码，目前抓取了快代理、代理66、有代理、西刺代理、guobanjia这个五个网站的免费代理 #author:zjcjava@163.com 2016-11-02 import urllib.parse import urllib.request import time from lxml import etree #可写函数说明 def printinfo( name, age ): &quot;打印任何传入的字符串&quot; print (&quot;Name: &quot;, name); print (&quot;Age &quot;, age); return; #调用printinfo函数 printinfo( age=50, name=&quot;miki&quot; ); global url_path url_path = [3] def get_url(url): #国内高匿代理的链接 url_path [0] = url url_list = [] if &quot;xici&quot; in url: for i in range(1,1000): url_new = url + str(i) url_list.append(url_new) if &quot;66&quot; in url: for i in range(1,2): url_new = url + str(i)+&quot;.html&quot; url_list.append(url_new) print(url_new) return url_list def get_content(url): # 获取网页内容 user_agent = &apos;Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/49.0.2623.22 Safari/537.36 SE 2.X MetaSr 1.0&apos; headers = {&apos;User-Agent&apos;: user_agent} req = urllib.request.Request(url=url, headers=headers) res = urllib.request.urlopen(req) content = res.read() return content #.decode(&apos;utf-8&apos;) def get_info(content,url): # 提取网页信息 / ip 端口 print(&quot;111111111111111111&quot;); print(&quot;sss:&quot;+url) if &quot;xici&quot; in url: datas_ip = etree.HTML(content).xpath(&apos;//table[contains(@id,&quot;ip_list&quot;)]/tr/td[2]/text()&apos;) datas_port = etree.HTML(content).xpath(&apos;//table[contains(@id,&quot;ip_list&quot;)]/tr/td[3]/text()&apos;) if &quot;66&quot; in url: print(66); datas_ip = etree.HTML(content).xpath(&apos;//div[contains(@id,&quot;main&quot;)]/div/div[1]/table/tr[position()&gt;1]/td[1]/text()&apos;) datas_port = etree.HTML(content).xpath(&apos;//div[contains(@id,&quot;main&quot;)]/div/div[1]/table/tr[position()&gt;1]/td[2]/text()&apos;) #print(&apos;%s : %s&apos;%(datas_ip,datas_port)) with open(&quot;temp.txt&quot;, &quot;w&quot;) as fd: for i in range(0,len(datas_ip)): out = u&quot;&quot; out += u&quot;&quot; + datas_ip[i] out += u&quot;:&quot; + datas_port[i] fd.write(out + u&quot;\n&quot;) # 所有ip和端口号写入data文件 def verif_ip(ip,port): # 验证ip有效性 user_agent =&apos;Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/49.0.2623.22 Safari/537.36 SE 2.X MetaSr 1.0&apos; headers = {&apos;User-Agent&apos;:user_agent} proxy = {&apos;http&apos;:&apos;http://%s:%s&apos;%(ip,port)} print(proxy) proxy_handler = urllib.request.ProxyHandler(proxy) opener = urllib.request.build_opener(proxy_handler) urllib.request.install_opener(opener) test_url = &quot;https://www.baidu.com/&quot; req = urllib.request.Request(url=test_url,headers=headers) time.sleep(6) try: res = urllib.request.urlopen(req) time.sleep(3) content = res.read() if content: print(&apos;that is ok&apos;) with open(&quot;data.txt&quot;, &quot;a&quot;) as fd: # 有效ip保存到data2文件夹 fd.write(ip + u&quot;:&quot; + port) #fd.write(&quot;\n&quot;) else: print(&apos;its not ok&apos;) except urllib.request.URLError as e: print(e.reason) # url_list =get_url(url=&quot;http://www.xicidaili.com/nn/&quot;); # for i in url_list: # print(i) #url = &apos;http://www.xicidaili.com/nn/&apos; if __name__ == &quot;__main__&quot;: url = &apos;http://www.66ip.cn/&apos; url_list = get_url(url) for i in url_list: print(i) content = get_content(i) time.sleep(3) get_info(content,url); file = open(&quot;temp.txt&quot;) while 1: lines = file.readlines(100000) if not lines: break for data in lines: print(data.split(u&quot;:&quot;)[0]) #out=data.split(u&quot;:&quot;); #print(&apos;%s : %s&apos;%(data.split(u&quot;:&quot;)[0],data.split(u&quot;:&quot;)[0])) verif_ip(data.split(u&quot;:&quot;)[0],data.split(u&quot;:&quot;)[1]) #encoding=utf8 import urllib2 from bs4 import BeautifulSoup import urllib import socket User_Agent = &apos;Mozilla/5.0 (Windows NT 6.3; WOW64; rv:43.0) Gecko/20100101 Firefox/43.0&apos; header = {} header[&apos;User-Agent&apos;] = User_Agent &apos;&apos;&apos; 获取所有代理IP地址 &apos;&apos;&apos; def getProxyIp(): proxy = [] for i in range(1,2): try: url = &apos;http://www.xicidaili.com/nn/&apos;+str(i) req = urllib2.Request(url,headers=header) res = urllib2.urlopen(req).read() soup = BeautifulSoup(res) ips = soup.findAll(&apos;tr&apos;) for x in range(1,len(ips)): ip = ips[x] tds = ip.findAll(&quot;td&quot;) ip_temp = tds[1].contents[0]+&quot;\t&quot;+tds[2].contents[0] proxy.append(ip_temp) except: continue return proxy &apos;&apos;&apos; 验证获得的代理IP地址是否可用 &apos;&apos;&apos; def validateIp(proxy): url = &quot;http://ip.chinaz.com/getip.aspx&quot; f = open(&quot;E:\ip.txt&quot;,&quot;w&quot;) socket.setdefaulttimeout(3) for i in range(0,len(proxy)): try: ip = proxy[i].strip().split(&quot;\t&quot;) proxy_host = &quot;http://&quot;+ip[0]+&quot;:&quot;+ip[1] proxy_temp = {&quot;http&quot;:proxy_host} res = urllib.urlopen(url,proxies=proxy_temp).read() f.write(proxy[i]+&apos;\n&apos;) print proxy[i] except Exception,e: continue f.close() if __name__ == &apos;__main__&apos;: proxy = getProxyIp() validateIp(proxy) 爬去指定页面图片import urllib.request import re import os import urllib #根据给定的网址来获取网页详细信息，得到的html就是网页的源代码 def getHtml(url): page = urllib.request.urlopen(url) html = page.read() return html.decode(&apos;UTF-8&apos;) def getImg(html): reg = r&apos;src=&quot;(.+?\.jpg)&quot; pic_ext&apos; imgre = re.compile(reg) imglist = imgre.findall(html)#表示在整个网页中过滤出所有图片的地址，放在imglist中 x = 0 path = &apos;D:\\test&apos; # 将图片保存到D:\\test文件夹中，如果没有test文件夹则创建 if not os.path.isdir(path): os.makedirs(path) paths = path+&apos;\\&apos; #保存在test路径下 for imgurl in imglist: urllib.request.urlretrieve(imgurl,&apos;{}{}.jpg&apos;.format(paths,x)) #打开imglist中保存的图片网址，并下载图片保存在本地，format格式化字符串 x = x + 1 return imglist html = getHtml(&quot;http://tieba.baidu.com/p/2460150866&quot;)#获取该网址网页详细信息，得到的html就是网页的源代码 print (getImg(html)) #从网页源代码中分析并下载保存图片]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[python简介及安装]]></title>
      <url>%2F2017%2F03%2F30%2Fpython%E7%AE%80%E4%BB%8B%E5%8F%8A%E5%AE%89%E8%A3%85%2F</url>
      <content type="text"><![CDATA[python简介Python是著名的“龟叔”Guido van Rossum在1989年圣诞节期间，为了打发无聊的圣诞节而编写的一个编程语言。Python为我们提供了非常完善的基础代码库，覆盖了网络、文件、GUI、数据库、文本等大量内容，被形象地称作“内置电池（batteries included）”。除了内置的库外，Python还有大量的第三方库供你直接使用。 龟叔给Python的定位是“优雅”、“明确”、“简单”，Python的哲学就是简单优雅，尽量写容易看明白的代码，尽量写少的代码。Python适合开发网络应用，包括网站、后台服务等等。其次是许多日常需要的小工具，包括系统管理员需要的脚本任务等等；另外就是把其他语言开发的程序再包装起来，方便使用。 任何编程语言都有缺点，Python也不例外。第一个缺点就是运行速度慢，和C程序相比非常慢，因为Python是解释型语言，你的代码在执行时会一行一行地翻译成CPU能理解的机器码，这个翻译过程非常耗时，所以很慢。而C程序是运行前直接编译成CPU能执行的机器码，所以非常快。 但是大量的应用程序不需要这么快的运行速度，用户根本感觉不出来。第二个缺点就是代码不能加密。如果要发布你的Python程序，实际上就是发布源代码，这一点跟C语言不同，C语言不用发布源代码，只需要把编译后的机器码（也就是你在Windows上常见的xxx.exe文件）发布出去。要从机器码反推出C代码是不可能的，所以，凡是编译型的语言，都没有这个问题，而解释型的语言，则必须把源码发布出去。 python安装Ubuntu12.04STEP1ubuntu12.04，系统默认已经安装了python2.7。可以在终端输入python，运行如下结果。 STEP2/usr/bin下面，只有一个python2.7是真正的python，另外两个只是软链接。增加软链接的目的是：不管用户输入的是python或者python2，都能够正确的链到python2.7。 STEP3安装Python3.5.2 在python下载找到linux适用的source release版本 tar xzvf Python-3.5.2.tgz cd Pyton-3.5.2 sudo mkdir /usr/local/python3 sudo chmod 777 /usr/local/python3/ ./configure –prefix=/usr/local/python3#配置python3.5安装路径 sudo make#编译 sudo make install#安装 其中，编译结束时如果提示缺少zlib和_ssl，这会对后面安装pip3和setuptools有影响。所以，需要把他们都安装上。安装zlib： sudo apt-get install –reinstall zlibc zlib1g zlib1g-dev 安装_ssl： sudo apt-get install libssl-dev 然后重新make, make install. STEP4给python3.5 和它对应的pip版本做一个软链接了，和python2.7版本区分。 cd /usr/bin sudo ln -s /usr/local/python3/bin/python /usr/bin/python3 # sudo ln -s /usr/local/python3/bin/pip /usr/bin/pip3 python3 –version #查看版本 pip3 –version #看到输出路径来自python3.5 若软连接已存在，删除一个软连接 windowsSTEP 1下载python,一路安装即可，记录下此时安装位置D:\python3.6 STEP 2下载pip,下载完成之后，解压到一个文件夹，用CMD控制台进入解压目录，输入： python setup.py install 安装完后会显示一个Scripts的安装路径：D:\python3.6\Scripts STEP 3添加系统环境变量path,分别加入： D:\python3.6;D:\python3.6\Scripts STEP 4测试安装成功与否,cmd下输入： python pip list]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[linux终端设备-终端属性termios]]></title>
      <url>%2F2017%2F03%2F30%2Flinux%E7%BB%88%E7%AB%AF%E8%AE%BE%E5%A4%87%E5%AD%A6%E4%B9%A0%E2%80%94%E7%BB%88%E7%AB%AF%E5%B1%9E%E6%80%A7termios%E7%BB%93%E6%9E%84%E4%BD%93%2F</url>
      <content type="text"><![CDATA[termios结构体简介 为便于用户层统一管理终端属性，linux使用termios结构体来统一管理struct termios{ unsigned short c_iflag; / 输入模式标志/ unsigned short c_oflag; / 输出模式标志/ unsigned short c_cflag; / 控制模式标志/ unsigned short c_lflag; /区域模式标志或本地模式标志或局部模式/ unsigned char c_line; /行控制line discipline / unsigned char c_cc[NCC]; / 控制字符特性/};可以调用函数tcgetattr来初始化一个终端对应的termios结构，该函数的原型如下： #include&lt;termios.h&gt; int tcgetattr(int fd, struct termios *termios_p); 这个函数调用获取fd所指向的当前终端对象fd的相关属性，并写入termios_p参数指向的结构。 通过调用函数tcsetattr来重新配置某个终端的属性，函数原型如下： #include&lt;termios.h&gt; int tcsetattr(int fd , int actions , const struct termios *termios_h); 函数根据actions所指示的行为来设置与fp所指向的终端设备的属性参数actions控制修改方式，共有三种修改方式，如下所示。1.TCSANOW：立刻对值进行修改2.TCSADRAIN：等当前的输出完成后再对值进行修改。3.TCSAFLUSH：等当前的输出完成之后，再对值进行修改，但丢弃还未从read调用返回的当前的可用的任何输入。 五种模式标志 输入模式标志c_iflag输入模式控制输入数据在传递给程序之前的处理方式。通过设置termios结构中的c_iflag成员的标志对它们进行控制。所有的标志都被定义为宏,并可通过按位或的方式结合起来。可用于c_iflag成员的宏如下所示：BRKINT：当在输入行中检测到一个终止状态时，产生一个中断。TGNBRK：忽略输入行中的终止状态。TCRNL：将接受到的回车符转换为新行符。TGNCR：忽略接受到的新行符。INLCR：将接受到的新行符转换为回车符。IGNPAR：忽略奇偶校检错误的字符。INPCK：对接收到的字符执行奇偶校检。PARMRK：对奇偶校检错误作出标记。ISTRIP：将所有接收的字符裁减为7比特。IXOFF：对输入启用软件流控。IXON：对输出启用软件流控。 注意：如果BRKINT和TGNBRK标志都未被设置，则输入行中的终止状态就被读取为NULL（0X00）字符。对于PARKMRK如果没有设置IGNPAR,在有奇偶校验错误的字符前插入\337\0如果没有设置IGNPAR也没有设置PARMRK，将有奇偶校验错误或帧错误的字符视为/0对于BRKINT,如果设置了IGNBRK,将忽略BREAK,如果没有设置，但是设置了BRKINT,那么BREAK将使得输入和输出队列被刷新。如果终端是一个前台进程组的控制终端，这个进程组所有进程将收到SIGINT信号。如果既未设置IGNBRK也为设置BRKINT,BRKINT将视为与NUL字符同意。除非设置了PARMRK，这种情况下被视为序列/337/0/0 输出模式标志c_oflag输出模式控制输出字符的处理方式,即由程序发出的字符在传递到串行口或屏幕之前如何处理.通过设置c_oflag成员的标识对输出模式进行控制.可用于c_iflag成员的宏如下所示（部分）：OPSOT:打开输出处理功能OLCUC:将输出的小写字母映射为大写字母ONLCR:将输出中的换行符转换为回车符OCRNL:将回车符转换为换行符ONOCR:第０行不输出回车符ONLRET:不输出回车符NLDLY:换行符延时选择CRDLY:回车符延时TABDLY:制表符延时 控制模式标志c_cflag控制模式控制终端的硬件特性,通过c_cflag成员标识配置. 包括：波特率，数据位长度，停止位长度，奇偶校验位等CBAUD ：(不属于 POSIX) 波特率掩码 (4+1 位)。CSIZE：字符长度掩码（传送或接收字元时用的位数）。 取值为CS5（传送或接收字元时用5bits）, CS6, CS7, 或 CS8。CSTOPB ：设置两个停止位，而不是一个。CREAD ：打开接受者。PARENB ：允许输出产生奇偶信息以及输入的奇偶校验（启用同位产生与侦测）。PARODD ：输入和输出是奇校验（使用奇同位而非偶同位）。HUPCL ：在最后一个进程关闭设备后，降低 modem 控制线 (挂断)。CLOCAL ：忽略 modem 控制线。LOBLK :(不属于 POSIX) 从非当前 shell 层阻塞输出。CIBAUD :(不属于 POSIX) 输入速度的掩码。CIBAUD 各位的值与CBAUD 各位相同，左移了 IBSHIFT 位。CRTSCTS :(不属于 POSIX) 启用 RTS/CTS (硬件) 流控制 设置波特率波特率即调制速率，指信号被调制以后在单位时间内的变化。即单位时间内载波参数变化的次数。为了减少用户编程负担，函数cfgetospeed()将获取存储于struct stermios结构中的输出波特率属性函数cfgetispeed()将获取存储于struct stermios结构中的输入波特率属性，不需要自己进行位操作。函数cfsetospeed()和cfsetispeed分别设置存储于termios结构的输出和输入波特率。cfsetspeed()可以同时设置termios结构的输入和输出波特率。例子：struct termios options;tcgetattr(fd,&amp;options);cfsetispeed(&amp;options,B19200); //输入波特率19200cfsetospeed(&amp;options,B19200); //输出波特率19200options.c_cflag | =(CLOCAL | CREAD ); //允许接收，本地模式tcsetattr(fd,TCSANOW,&amp;options); //生效时间立即生效 设置帧数据位宽度终端可以设置为每帧数据位为5，6，7,8bit。修改数据位宽度如下：options.c_cflag &amp;=~CSIZE; //清除现在数据位宽度options.c_cflag ｜＝CS8; //设置为每帧8bit 设置奇偶校验奇偶校验是串行通信所采用的简单的差错检测方式。例子：设置为8N1，即每帧数据位8bit，无奇偶校验，一位停止位options.c_cflag &amp; =~PARENG;options.c_cflag &amp; =~CSTOPB;options.c_cflag &amp; =~CSIZE;options.c_cflag &amp; =~CS8； 本地模式标志c_lflag本地模式标志用来管理用何种方式输入字符，一般设置为标准模式或者原始模式。标准模式：回显由客户端完成，用户输入的字符先缓存到一个缓存区，直到用户输入回车或者换行才发送到服务端原始模式：又称为字符模式，回显由服务端完成。用户输入的一个字符立即发送到服务端，服务端然后将该字符回显到客户端。ISIG ： 当输入INTR、QUIT、SUSP或DSUSP时，产生相应的信号ICANON ： 使用标准输入模式XCASE ： 在ICANON和XCASE同时设置的情况下，终端只使用大写。如果只设置了XCASE，则输入字符将被转换为小写字符，除非字符使用了转义字符（非POSIX，且Linux不支持该参数）ECHO ： 显示输入字符ECHOE ： 如果ICANON同时设置，ERASE将删除输入的字符，WERASE将删除输入的单词ECHOK ： 如果ICANON同时设置，KILL将删除当前行ECHONL ： 如果ICANON同时设置，即使ECHO没有设置依然显示换行符ECHOPRT： 如果ECHO和ICANON同时设置，将删除打印出的字符（非POSIX）TOSTOP ： 向后台输出发送SIGTTOU信号 控制字符标志c_cc[NCCS]标准模式和非标准模式下,c_cc数组的下标有不同的值:标准模式:VEOF:ＥＯＦ字符VEOL:ＥＯＬ字符VERASE:ERASE字符VINTR:INTR字符VKILL:KILL字符VQUIT:QUIT字符VSTART:START字符VSTOP:STOP字符非标准模式:VINTR:INTR字符VMIN:MIN值VQUIT:QUIT字符VSUSP:SUSP字符VTIME:TIME值VSTART:START字符VSTOP:STOP字符 字符INTR:该字符使终端驱动程序向与终端相连的进程以送SIGINT信号QUIT:该字符使终端驱动程序向与终端相连的进程发送SIGQUIT信号EOF;该字符使终端驱动程序将输入行中的全部字符传递给正在读取输入的应用程序.如果输入行为空,read调用将返回０,就好像在文件尾调用read一样 TIME和MIN值 这两个值只用于非标准模式,两者结合共同控制对输入的读取方式,还能控制在一个程序试图与一个终端关联的文件描述符时将发生的情况MIN = 0, TIME = 0时:read立即返回,如果有待处理的字符,它们就会被返回,如果没有,read调用返回0,且不读取任何字符MIN = 0, TIME &gt; 0时:有字符处理或经过TIME个0.1秒后返回MIN &gt; 0, TIME = 0时:read一直等待,直到有ＭＩＮ个字符可以读取,返回值是字符的数量.到达文件尾时返回0MIN &gt; 0, TIME &gt; 0时:read调用时,它会等待接收一个字符.在接收到第一个字符及其后续的每个字符后,启用一个字符间隔定时器.当有ＭＩＮ个字符可读或两字符间的时间间隔超进TIME个0.1秒时,read返回通过设置ＭＩＮ和ＴＩＭＥ值,我们可以逐个字符地对输入进行处理 其他函数这些函数直接作用于文件描述符,不需要读写termios结构:#include int tcdrain(int fd);让调用程序一直等待,直到所有排队的输出都发送完毕int tcflow(int, int flowtype);暂停或重新开始输出int tcflush(int fd, int in_out_selector);清空输入,输出或两者都清空]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[linux下SSH服务]]></title>
      <url>%2F2017%2F03%2F30%2Flinux%E4%B8%8BSSH%E6%9C%8D%E5%8A%A1%E8%BF%9C%E7%A8%8B%E7%99%BB%E5%85%A5%2F</url>
      <content type="text"><![CDATA[SSH原理SSH 是目前较可靠，专为远程登录会话和其他网络服务提供安全性的协议。利用SSH 协议可以有效防止远程管理过程中的信息泄露问题。SSH最初是UNIX系统上的一个程序，后来又迅速扩展到其他操作平台。SSH在正确使用时可弥补网络中的漏洞。SSH客户端适用于多种平台。从客户端来看，SSH提供两种级别的安全验证：第一种级别是基于口令的安全验证只要你知道自己帐号和口令，就可以登录到远程主机。所有传输的数据都会被加密， 但是不能保证你正在连接的服务器就是你想连接的服务器。这个过程如下：1）远程主机收到用户的登录请求，把自己的公钥发给用户。2）用户使用这个公钥，将登录密码加密后，发送回来。3）远程主机用自己的私钥，解密登录密码，如果密码正确，就同意用户登录。这种方式可能会有别的服务器在冒充真正的服务器，将公钥发送给客户端，客户端就会将密码加密后发送给冒充的服务器，冒充的服务器就可以拿自己的私钥获取到密码，也就是受到“中间人”这种方式的攻击。当第一次链接远程主机时，会提示您当前主机的“公钥指纹”，询问您是否继续，如果选择继续后就可以输入密码进行登录了，当远程的主机接受以后，该台服务器的公钥就会保存到~/.ssh/known_hosts文件中。第二种级别是基于密匙的安全验证需要依靠密匙，也就是必须为自己创建一对密匙，并把公用密匙放在需要访问的服务器上。如果你要连接到SSH服务器上，客户端软件就会向服务器发出请求，请求用你的密匙进行安全验证。服务器收到请求之后，先在该服务器上你的主目录下寻找你的公用密匙，然后把它和你发送过来的公用密匙进行比较。如果两个密匙一致，服务器就用公用密匙加密“质询”并把它发送给客户端软件。客户端软件收到“质询”之后就可以用你的私人密匙解密再把它发送给服务器。用这种方式，你必须知道自己密匙的口令。 但是，与第一种级别相比，第二种级别不需要在网络上传送口令。第二种级别不仅加密所有传送的数据，而且“中间人”这种攻击方式也是不可能的（因为他没有你的私人密匙）。但是整个登录的过程可能需要10秒，但是相比输入密码的方式来说10秒也不长。 安装SSHsudo apt-get updatesudo apt-get openssh-server openssh-client 配置SSHsudo gedit /etc/ssh/sshd_config”该文件下是SSH的相关配置，包括端口22。如下，允许root用户登入 启动SSHsudo ps -e |grep ssh”–&gt;回车–&gt;有sshd,说明ssh服务已经启动如果没有启动，”sudo service ssh start”–&gt;回车–&gt;ssh服务就会启动 查看SSH状态 SSH远程登入使用putty进行ssh远程登入，默认端口22第一次登录的时候，OpenSSH将会提示用户它不知道这台登录的主机，只要键入“yes”，就会把这台登录主机的“识别标记”加到“~/.ssh/know_hosts”文件中。第二次访问这台主机的时候就不会再显示这条提示信息了。然后，SSH提示用户输入远程主机上用户账号的口令。这样，就建立了SSH连接，这之后就可以象使用telnet那样方便地使用SSH了。 秘钥登入秘钥登入不要每次登入输入密码， 使用通信短语即可。使用的是secureCRT1，快速链接-公钥-属性设置-创建身份文件 2，按照生成向导一步步完成这里选择OpneSSH格式通行短语类似于密码作用，在登入时会用到，如下： 3，完成后，将公钥传入要登入的服务器（linux）,可以采用虚拟机的文件共享方式。本地公钥在公钥文件名下可看到 4，在服务器段，建立要登入用户的.SSH文件mkdir -p ~/.ssh &amp;&amp; chmod -R 700 ~/.sshchmod -R 600 ~/.ssh/ authorized_keys 5，将公钥文件的内容复制到authorized_keys中去（可直接粘贴复制） 6，在secrueCRT下，将公钥放在最前面，输入主机名，用户名接下来会提示输入通信短语，输入确定即可]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[python3网络爬虫入门]]></title>
      <url>%2F2017%2F03%2F30%2Fpython%E7%BD%91%E7%BB%9C%E7%88%AC%E8%99%AB%2F</url>
      <content type="text"><![CDATA[前言网络爬虫(Web Spider)从网站某一个页面（通常是首页）开始，读取网页的内容，找到在网页中的其它链接地址，然后通过这些链接地址寻找下一个网页，一直循环下去，直到把这个网站所有的网页都抓取完为止。 网络爬虫就是一个抓取网页的程序,基本操作就是抓取网页。 浏览网页在浏览器的地址栏中输入网页地址，打开网页的过程就是浏览器作为一个浏览的“客户端”，向服务器端发送了一次请求，把服务器端的文件“抓”到本地，再进行解释、展现。 HTML是一种标记语言，用标签标记内容并加以解析和区分。浏览器的功能是将获取到的HTML代码进行解析，然后将原始的代码转变成直接看到的网站页面。 URI和URLWeb上每种可用的资源，如 HTML文档、图像、视频片段、程序等都由一个通用资源标志符(Universal Resource Identifier， URI)进行定位。 URI通常由三部分组成： 访问资源的命名机制； 存放资源的主机名； 资源自身 的名称，由路径表示。 URL(Uniform Resource Locator)是URI的一个子集，译为“统一资源定位符”.通俗地说，URL是Internet上描述信息资源的字符串，主要用在各种WWW客户程序和服务器程序上。采用URL可以用一种统一的格式来描述各种信息资源，包括文件、服务器的地址和目录等。URL就是在浏览器端输入的http://www.baidu.com字符串。 URL的一般格式为(带方括号[]的为可选项)： protocol :// hostname[:port] / path / [;parameters][?query]#fragment URL的格式由三部分组成： 第一部分是协议(或称为服务方式)。第一部分和第二部分用“://”符号隔开 第二部分是存有该资源的主机IP地址(也包括端口号),第二部分和第三部分用“/”符号隔开。 第三部分是主机资源的具体地址，如目录和文件名等。第三部分有时可以省略。 二者的区别在于，URI表示请求服务器的路径，定义这么一个资源。而URL同时说明要如何访问这个资源（http://）。 例：http://www.peopledaily.com.cn/channel/welcome.htm其计算机域名为www.peopledaily.com.cn。文本文件(文件类型为.html)是在目录 /channel下的welcome.htm。 用URL表示文件时，服务器方式用file表示，后面要有主机IP地址、文件的存取路 径(即目录)和文件名等信息。有时可以省略目录和文件名，但“/”符号不能省略。例：file://ftp.yoyodyne.com/pub/files/foobar.txtURL代表存放在主机ftp.yoyodyne.com上的pub/files/目录下的一个文件，文件名是foobar.txt。例：file://ftp.yoyodyne.com/pub代表主机ftp.yoyodyne.com上的目录/pub。 爬虫入门from urllib import request if __name__ == &quot;__main__&quot;: req=request.Request(&quot;http://fanyi.baidu.com&quot;) response=request.urlopen(req) html=response.read() ##urlencode()将通俗的字符串转化为url格式。 html=html.decode(&quot;utf-8&quot;) print(html) urllib官方文档显示urlib是一个包，包含request,error,parse,robotparser等模块。 urllib.request模块是用来打开和读取URLs的； urllib.error模块包含一些有urllib.request产生的错误，可以使用try进行捕捉处理； urllib.parse模块包含了一些解析URLs的方法； urllib.robotparser模块用来解析robots.txt文本文件.它提供了一个单独的RobotFileParser类，通过该类提供的can_fetch()方法测试爬虫是否可以下载一个页面。 urlopen() 函数返回一个 http.client.HTTPResponse 对象,该对象包含各种方法在相应文档。url表示需要打开的网址，data表示Post提交的数据，timeout表示设置网站的访问超时时间 urllib.request.urlopen(url, data=None, [timeout, ]*, cafile=None, capath=None, cadefault=False) urlopen（）获取页面page的数据格式为bytes类型，需要decode（）解码，转换成str类型。 网页编码方式常见编码方式： ASCII编码：用来表示英文，它使用1个字节表示，其中第一位规定为0，其他7位存储数据，一共可以表示128个字符。 拓展ASCII编码：用于表示更多的欧洲文字，用8个位存储数据，一共可以表示256个字符 GBK/GB2312/GB18030：表示汉字。GBK/GB2312表示简体中文，GB18030表示繁体中文。 Unicode编码：包含世界上所有的字符，是一个字符集。 UTF-8：是Unicode字符的实现方式之一，它使用1-4个字符表示一个符号，根据不同的符号而变化字节长度。 安装第三方库chardet，它是用来判断编码的模块. pip install chardet 使用chardet.detect()方法，判断网页的编码方式: from urllib import request import chardet if __name__ == &quot;__main__&quot;: response = request.urlopen(&quot;http://fanyi.baidu.com/&quot;) html = response.read() charset = chardet.detect(html) print(charset) 输出结果： {&apos;encoding&apos;: &apos;utf-8&apos;, &apos;confidence&apos;: 0.99, &apos;language&apos;: &apos;&apos;} urlopen发送数据urlopen()使用data参数向服务器发送数据。根据HTTP规范，GET用于信息获取，POST是向服务器提交数据的一种请求，再换句话说：从客户端向服务器提交数据使用POST；从服务器获得数据到客户端使用GET。 如果没有设置urlopen()函数的data参数，HTTP请求采用GET方式，也就是我们从服务器获取信息，如果设置data参数，HTTP请求采用POST方式，也就是向服务器传递数据。 data参数有自己的格式，它是一个基于application/x-www.form-urlencoded的格式，可以使用urllib.parse.urlencode()函数将字符串自动转换成上面所说的格式。 URL获取：打开有道-右键检查-选择右侧的network-输入单词自动翻译-选择右侧栏的headers获取页面中URL与最下面的Form Data from urllib import request from urllib import parse import json if __name__ == &quot;__main__&quot;: #对应上图的Request URL Request_URL = &apos;http://fanyi.youdao.com/translate?smartresult=dict&amp;smartresult=rule&amp;smartresult=ugc&amp;sessionFrom=https://www.baidu.com/link&apos; #创建Form_Data字典，存储上图的Form Data Form_Data = {} Form_Data[&apos;type&apos;] = &apos;AUTO&apos; Form_Data[&apos;i&apos;] = &apos;Jack&apos; Form_Data[&apos;doctype&apos;] = &apos;json&apos; Form_Data[&apos;xmlVersion&apos;] = &apos;1.8&apos; Form_Data[&apos;keyfrom&apos;] = &apos;fanyi.web&apos; Form_Data[&apos;ue&apos;] = &apos;ue:UTF-8&apos; Form_Data[&apos;action&apos;] = &apos;FY_BY_CLICKBUTTON&apos; #使用urlencode方法转换标准格式 data = parse.urlencode(Form_Data).encode(&apos;utf-8&apos;) #传递Request对象和转换完格式的数据 response = request.urlopen(Request_URL,data) #读取信息并解码 html = response.read().decode(&apos;utf-8&apos;) #使用JSON translate_results = json.loads(html) #找到翻译结果 translate_results = translate_results[&apos;translateResult&apos;][0][0][&apos;tgt&apos;] #打印翻译信息 print(&quot;翻译的结果是：%s&quot; % translate_results) 结果： 翻译的结果是：玫瑰 urllib.error异常 urllib.error可以接收有urllib.request产生的异常。urllib.error有两个方法，URLError和HTTPError。 URLErrorfrom urllib import request from urllib import error if __name__ == &quot;__main__&quot;: #一个不存在的连接 url = &quot;http://www.iloveyou.com/&quot; req = request.Request(url) try: response = request.urlopen(req) html = response.read().decode(&apos;utf-8&apos;) print(html) except error.URLError as e: print(e.reason) 结果： [Errno 11004] getaddrinfo failed HTTPErrorfrom urllib import request from urllib import error if __name__ == &quot;__main__&quot;: #一个不存在的连接 url = &quot;http://www.douyu.com/Jack_Cui.html&quot; req = request.Request(url) try: responese = request.urlopen(req) # html = responese.read() except error.HTTPError as e: print(e.code) 结果： 404 说明请求的资源没有在服务器上找到，www.douyu.com这个服务器是存在的，但是我们要查找的Jack_Cui.html资源是没有的，所以抛出404异常。 URLError和HTTPError混合如果想用HTTPError和URLError一起捕获异常，那么需要将HTTPError放在URLError的前面，因为HTTPError是URLError的一个子类。如果URLError放在前面，出现HTTP异常会先响应URLError，这样HTTPError就捕获不到错误信息了。 也可以使用hasattr函数判断URLError含有的属性，如果含有reason属性表明是URLError，如果含有code属性表明是HTTPError from urllib import request from urllib import error if __name__ == &quot;__main__&quot;: #一个不存在的连接 url = &quot;http://www.douyu.com/Jack_Cui.html&quot; req = request.Request(url) try: responese = request.urlopen(req) except error.URLError as e: if hasattr(e,&apos;code&apos;): print(&quot;HTTPError&quot;) print(e.code) elif hasattr(e, &apos;reason&apos;): print(&quot;URLError&quot;) print(e.reason) 结果： HTTPError 404 User Agent和代理IP隐藏身份有一些网站不喜欢被爬虫程序访问，所以会检测连接对象，如果是爬虫程序，也就是非人点击访问，它就会不让你继续访问，所以为了要让程序可以正常运行，需要隐藏自己的爬虫程序的身份。此时可以通过设置User Agent的来达到隐藏身份的目的，User Agent的中文名为用户代理，简称UA。 User Agent存放于Headers中，服务器就是通过查看Headers中的User Agent来判断是谁在访问。在python中，如果不设置User Agent，程序将使用默认的参数，那么这个User Agent就会有Python的字样，如果服务器检查User Agent，那么没有设置User Agent的Python程序将无法正常访问网站。Python允许修改这个User Agent来模拟浏览器访问。 常见的User Agent Android Mozilla/5.0 (Linux; Android 4.1.1; Nexus 7 Build/JRO03D) AppleWebKit/535.19 (KHTML, like Gecko) Chrome/18.0.1025.166 Safari/535.19 Mozilla/5.0 (Linux; U; Android 4.0.4; en-gb; GT-I9300 Build/IMM76D) AppleWebKit/534.30 (KHTML, like Gecko) Version/4.0 Mobile Safari/534.30 Mozilla/5.0 (Linux; U; Android 2.2; en-gb; GT-P1000 Build/FROYO) AppleWebKit/533.1 (KHTML, like Gecko) Version/4.0 Mobile Safari/533.1 Firefox Mozilla/5.0 (Windows NT 6.2; WOW64; rv:21.0) Gecko/20100101 Firefox/21.0 Mozilla/5.0 (Android; Mobile; rv:14.0) Gecko/14.0 Firefox/14.0 Google Chrome Mozilla/5.0 (Windows NT 6.2; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/27.0.1453.94 Safari/537.36 Mozilla/5.0 (Linux; Android 4.0.4; Galaxy Nexus Build/IMM76B) AppleWebKit/535.19 (KHTML, like Gecko) Chrome/18.0.1025.133 Mobile Safari/535.19 iOS Mozilla/5.0 (iPad; CPU OS 5_0 like Mac OS X) AppleWebKit/534.46 (KHTML, like Gecko) Version/5.1 Mobile/9A334 Safari/7534.48.3 Mozilla/5.0 (iPod; U; CPU like Mac OS X; en) AppleWebKit/420.1 (KHTML, like Gecko) Version/3.0 Mobile/3A101a Safari/419.3 设置User Agent class urllib.request.Request(url, data=None, headers={}, origin_req_host=None, unverifiable=False, method=None)urllib.request.Request()在创建Request对象的时候，可以传入headers参数，想要设置User Agent，有两种方法： 在创建Request对象的时候，填入headers参数(包含User Agent信息)，这个Headers参数要求为字典； 在创建Request对象的时候不添加headers参数，在创建完成之后，使用add_header()的方法，添加headers。 方式1：使用上面提到的android的第一个User Agent，在创建Request对象的时候传入headers参数 # -*- coding: UTF-8 -*- from urllib import request if __name__ == &quot;__main__&quot;: #以CSDN为例，CSDN不更改User Agent是无法访问的 url = &apos;http://www.csdn.net/&apos; head = {} #写入User Agent信息 head[&apos;User-Agent&apos;] = &apos;Mozilla/5.0 (Linux; Android 4.1.1; Nexus 7 Build/JRO03D) AppleWebKit/535.19 (KHTML, like Gecko) Chrome/18.0.1025.166 Safari/535.19&apos; #创建Request对象 req = request.Request(url, headers=head) #传入创建好的Request对象 response = request.urlopen(req) #读取响应信息并解码 html = response.read().decode(&apos;utf-8&apos;) #打印信息 print(html) 方法二：使用上面提到的Android的第一个User Agent，在创建Request对象时不传入headers参数，创建之后使用add_header()方法，添加headers # -*- coding: UTF-8 -*- from urllib import request if __name__ == &quot;__main__&quot;: #以CSDN为例，CSDN不更改User Agent是无法访问的 url = &apos;http://www.csdn.net/&apos; #创建Request对象 req = request.Request(url) #传入headers req.add_header(&apos;User-Agent&apos;, &apos;Mozilla/5.0 (Linux; Android 4.1.1; Nexus 7 Build/JRO03D) AppleWebKit/535.19 (KHTML, like Gecko) Chrome/18.0.1025.166 Safari/535.19&apos;) #传入创建好的Request对象 response = request.urlopen(req) #读取响应信息并解码 html = response.read().decode(&apos;utf-8&apos;) #打印信息 print(html) IP代理的使用如果我们利用一个爬虫程序在网站爬取东西，一个固定IP的访问频率就会很高，这不符合人为操作的标准，因为人操作不可能在几ms内，进行如此频繁的访问。所以一些网站会设置一个IP访问频率的阈值，如果一个IP访问频率超过这个阈值，说明这个不是人在访问，而是一个爬虫程序。 一个简单的解决办法就是设置延时，但是这显然不符合爬虫快速爬取信息的目的，所以另一种更好的方法就是使用IP代理。使用代理的步骤： 调用urlib.request.ProxyHandler()，proxies参数为一个字典。 class urllib.request.ProxyHandler(proxies=None) 创建Opener(类似于urlopen，这个代开方式是我们自己定制的) urllib.request.build_opener([handler, ...]) 安装Opener urllib.request.install_opener(opener) 使用install_opener方法之后，会将程序默认的urlopen方法替换掉。也就是说，如果使用install_opener之后，在该文件中，再次调用urlopen会使用自己创建好的opener。如果不想替换掉，只是想临时使用一下，可以使用opener.open(url)，这样就不会对程序默认的urlopen有影响。 先在代理IP网站选好一个IP地址，推荐西刺代理IP从西刺网站选出信号好的IP，访问http://www.whatismyip.com.tw/，该网站是测试自己IP为多少的网址，服务器会返回访问者的IP # -*- coding: UTF-8 -*- from urllib import request if __name__ == &quot;__main__&quot;: #访问网址 url = &apos;http://www.whatismyip.com.tw/&apos; #这是代理IP proxy = {&apos;http&apos;:&apos;111.73.83.113&apos;} #创建ProxyHandler proxy_support = request.ProxyHandler(proxy) #创建Opener opener = request.build_opener(proxy_support) #添加User Angent opener.addheaders = [(&apos;User-Agent&apos;,&apos;Mozilla/5.0 (Windows NT 6.1; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/56.0.2924.87 Safari/537.36&apos;)] #安装OPener request.install_opener(opener) #使用自己安装好的Opener response = request.urlopen(url) #读取相应信息并解码 html = response.read().decode(&quot;utf-8&quot;) #打印信息 print(html) 直接访问会报如下错误： urllib.error.URLError: &lt;urlopen error [WinError 10060] 由于连接方在一段时间后没有正确答复或连接的主机没有反应，连接尝试失败。&gt; 若将request.install_opener(opener)注释便不会保错，该函数是使代理ip生效，说明该代理IP不成功。换了大量IP最后proxy = {‘http’:’119.36.92.41’}成功运行。，访问的IP已经伪装成了106.46.136.112。 IP位址&lt;/h1&gt; &lt;span data-ip=&apos;121.12.105.83&apos;&gt; Cookie模拟登入cookie指某些网站为了辨别用户身份、进行session跟踪而储存在用户本地终端上的数据（通常经过加密)。 比如说有些网站需要登录后才能访问某个页面，在登录之前，你想抓取某个页面内容，登陆前与登陆后是不同的，或者不允许的。使用Cookie和使用代理IP一样，也需要创建一个自己的opener。在HTTP包中，提供了cookiejar模块，用于提供对Cookie的支持。 http.cookiejar功能强大，可以利用本模块的CookieJar类的对象来捕获cookie并在后续连接请求时重新发送，比如可以实现模拟登录功能。该模块主要的对象有CookieJar、FileCookieJar、MozillaCookieJar、LWPCookieJar。它们的关系： CookieJar–派生–&gt;FileCookieJar–派生–&gt;MozillaCookieJar和LWPCookieJar 工作原理：创建一个带有cookie的opener，在访问登录的URL时，将登录后的cookie保存下来，然后利用这个cookie来访问其他网址 获取Cookie利用CookieJar对象实现获取cookie的功能，存储到变量中 from urllib import request from http import cookiejar if __name__ == &apos;__main__&apos;: #声明一个CookieJar对象实例来保存cookie cookie = cookiejar.CookieJar() #利用urllib.request库的HTTPCookieProcessor对象来创建cookie处理器,也就CookieHandler handler=request.HTTPCookieProcessor(cookie) #通过CookieHandler创建opener opener = request.build_opener(handler) #此处的open方法打开网页 response = opener.open(&apos;http://www.baidu.com&apos;) #打印cookie信息 for item in cookie: print(&apos;Name = %s&apos; % item.name) print(&apos;Value = %s&apos; % item.value) 结果： Name = BAIDUID Value = B7369EF14E25D8738EB85FBE2D84785E:FG=1 Name = BIDUPSID Value = B7369EF14E25D8738EB85FBE2D84785E Name = H_PS_PSSID Value = 1428_21116_18559_17001_22159 Name = PSTM Value = 1499327930 Name = BDSVRTM Value = 0 Name = BD_HOME Value = 0 保存Cookie到文件如果想将cookie保存到文件中方便以后直接读取文件使用，就要用到FileCookieJar这个对象，在这里使用它的子类MozillaCookieJar来实现Cookie的保存， from urllib import request from http import cookiejar if __name__ == &apos;__main__&apos;: #设置保存cookie的文件，同级目录下的cookie.txt filename = &apos;cookie.txt&apos; #声明一个MozillaCookieJar对象实例来保存cookie，之后写入文件 cookie = cookiejar.MozillaCookieJar(filename) #利用urllib.request库的HTTPCookieProcessor对象来创建cookie处理器,也就CookieHandler handler=request.HTTPCookieProcessor(cookie) #通过CookieHandler创建opener opener = request.build_opener(handler) #此处的open方法打开网页 response = opener.open(&apos;http://www.baidu.com&apos;) #保存cookie到文件 cookie.save(ignore_discard=True, ignore_expires=True) cookie.save的参数说明： ignore_discard的意思是即使cookies将被丢弃也将它保存下来； ignore_expires的意思是如果在该文件中cookies已经存在，则覆盖原文件写入。 从文件中获取Cookie并访问from urllib import request from http import cookiejar if __name__ == &apos;__main__&apos;: #设置保存cookie的文件的文件名,相对路径,也就是同级目录下 filename = &apos;cookie.txt&apos; #创建MozillaCookieJar实例对象 cookie = cookiejar.MozillaCookieJar() #从文件中读取cookie内容到变量 cookie.load(filename, ignore_discard=True, ignore_expires=True) #利用urllib.request库的HTTPCookieProcessor对象来创建cookie处理器,也就CookieHandler handler=request.HTTPCookieProcessor(cookie) #通过CookieHandler创建opener opener = request.build_opener(handler) #此用opener的open方法打开网页 response = opener.open(&apos;http://www.baidu.com&apos;) #打印信息 print(response.read().decode(&apos;utf-8&apos;)) 实例# -*- coding: UTF-8 -*- from urllib import request from urllib import error from urllib import parse from http import cookiejar if __name__ == &apos;__main__&apos;: #登陆地址 login_url = &apos;http://www.jobbole.com/wp-admin/admin-ajax.php&apos; #User-Agent信息 user_agent = r&apos;Mozilla/5.0 (Windows NT 6.2; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/27.0.1453.94 Safari/537.36&apos; #Headers信息 head = {&apos;User-Agnet&apos;: user_agent, &apos;Connection&apos;: &apos;keep-alive&apos;} #登陆Form_Data信息 Login_Data = {} Login_Data[&apos;action&apos;] = &apos;user_login&apos; Login_Data[&apos;redirect_url&apos;] = &apos;http://www.jobbole.com/&apos; Login_Data[&apos;remember_me&apos;] = &apos;0&apos; #是否一个月内自动登陆 Login_Data[&apos;user_login&apos;] = &apos;********&apos; #改成你自己的用户名 Login_Data[&apos;user_pass&apos;] = &apos;********&apos; #改成你自己的密码 #使用urlencode方法转换标准格式 logingpostdata = parse.urlencode(Login_Data).encode(&apos;utf-8&apos;) #声明一个CookieJar对象实例来保存cookie cookie = cookiejar.CookieJar() #利用urllib.request库的HTTPCookieProcessor对象来创建cookie处理器,也就CookieHandler cookie_support = request.HTTPCookieProcessor(cookie) #通过CookieHandler创建opener opener = request.build_opener(cookie_support) #创建Request对象 req1 = request.Request(url=login_url, data=logingpostdata, headers=head) #面向对象地址 date_url = &apos;http://date.jobbole.com/wp-admin/admin-ajax.php&apos; #面向对象 Date_Data = {} Date_Data[&apos;action&apos;] = &apos;get_date_contact&apos; Date_Data[&apos;postId&apos;] = &apos;4128&apos; #使用urlencode方法转换标准格式 datepostdata = parse.urlencode(Date_Data).encode(&apos;utf-8&apos;) req2 = request.Request(url=date_url, data=datepostdata, headers=head) try: #使用自己创建的opener的open方法 response1 = opener.open(req1) response2 = opener.open(req2) html = response2.read().decode(&apos;utf-8&apos;) index = html.find(&apos;jb_contact_email&apos;) #打印查询结果 print(&apos;联系邮箱:%s&apos; % html[index+19:-2]) except error.URLError as e: if hasattr(e, &apos;code&apos;): print(&quot;HTTPError:%d&quot; % e.code) elif hasattr(e, &apos;reason&apos;): print(&quot;URLError:%s&quot; % e.reason) Beautiful SoupBeautiful Soup是python的一个库，最主要的功能是从网页抓取数据。Beautiful Soup自动将输入文档转换为Unicode编码，输出文档转换为utf-8编码。Beautiful Soup已成为和lxml、html6lib一样出色的python解释器，为用户灵活地提供不同的解析策略或强劲的速度。 安装Beautiful Soup pip3 install beautifulsoup4 创建Beautiful Soup对象from bs4 import BeautifulSoup html = &quot;&quot;&quot; &lt;html&gt; &lt;head&gt; &lt;title&gt;Jack_Cui&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;p class=&quot;title&quot; name=&quot;blog&quot;&gt;&lt;b&gt;My Blog&lt;/b&gt;&lt;/p&gt; &lt;li&gt;&lt;!--注释--&gt;&lt;/li&gt; &lt;a href=&quot;http://blog.csdn.net/c406495762/article/details/58716886&quot; class=&quot;sister&quot; id=&quot;link1&quot;&gt;Python3网络爬虫(一)：利用urllib进行简单的网页抓取&lt;/a&gt;&lt;br/&gt; &lt;a href=&quot;http://blog.csdn.net/c406495762/article/details/59095864&quot; class=&quot;sister&quot; id=&quot;link2&quot;&gt;Python3网络爬虫(二)：利用urllib.urlopen发送数据&lt;/a&gt;&lt;br/&gt; &lt;a href=&quot;http://blog.csdn.net/c406495762/article/details/59488464&quot; class=&quot;sister&quot; id=&quot;link3&quot;&gt;Python3网络爬虫(三)：urllib.error异常&lt;/a&gt;&lt;br/&gt; &lt;/body&gt; &lt;/html&gt; &quot;&quot;&quot; soup = BeautifulSoup(html,&apos;lxml&apos;) #html的信息写入一个html文件也是一样的 #soup = BeautifulSoup(open(test.html),&apos;lxml&apos;) #格式化输出 print(soup.prettify()) Beautiful Soup四大对象Beautiful Soup将复杂HTML文档转换成一个复杂的树形结构,每个节点都是Python对象,所有对象可以归纳为4种: Tag NavigableString BeautifulSoup Comment TagTag就是HTML中的一个个标签，例如title就是HTML标签，标签加里面的内容就是Tag Jack_Cui利用Beautiful Soup 可以方便地获取 Tags： from bs4 import BeautifulSoup html = “”” Jack_Cui My Blog Python3网络爬虫(一)：利用urllib进行简单的网页抓取 Python3网络爬虫(二)：利用urllib.urlopen发送数据 Python3网络爬虫(三)：urllib.error异常 “”” soup = BeautifulSoup(html,’lxml’) print(soup.title) print(soup.head) print(soup.a) print(soup.p)输出结果： Jack_Cui Jack_Cui Python3网络爬虫(一)：利用urllib进行简单的网页抓取 My Blog 对于Tag，有两个重要的属性：name和attrs name：soup 对象本身比较特殊，它的 name 即为 [document]，对于其他内部标签，输出的值便为标签本身的名称。 print(soup.name) print(soup.title.name) 结果： [document] title attrs：把 a 标签的所有属性打印输出，得到的类型是一个字典 print(soup.a.attrs) 想要单独获取某个属性，例如我们获取a标签的class叫什么，两个等价的方法如下： print(soup.a[&apos;class&apos;]) print(soup.a.get(&apos;class&apos;)) 结果： [&apos;sister&apos;] [&apos;sister&apos;] 要想获取标签内部的文字用 .string 即可： print(soup.title.string) 结果： Jack_Cui BeautifulSoup 对象表示的是一个文档的全部内容.可以把它当作 Tag 对象，是一个特殊的 Tag，我们可以分别获取它的类型，名称，以及属性： print(type(soup.name)) print(soup.name) print(soup.attrs) 结果： &lt;class &apos;str&apos;&gt; [document] {} Comment对象是一个特殊类型的NavigableString对象，其实输出的内容仍然不包括注释符号，但是如果不好好处理它，可能会对文本处理造成意想不到的麻烦。使用前最好做一下判断，是否为 Comment 类型，然后再进行其他操作 if type(soup.li.string) == element.Comment: print(soup.li.string) 遍历文档直接子节点(不包含孙节点)tag的content属性可以将tag的子节点以列表的方式输出： print(soup.body.contents) 结果： [&apos;\n&apos;, &lt;p class=&quot;title&quot; name=&quot;blog&quot;&gt;&lt;b&gt;My Blog&lt;/b&gt;&lt;/p&gt;, &apos;\n&apos;, &lt;li&gt;&lt;!--注释--&gt;&lt;/li&gt;, &apos;\n&apos;, &lt;a class=&quot;sister&quot; href=&quot;http://blog.csdn.net/c406495762/article/details/58716886&quot; id=&quot;link1&quot;&gt;Python3网络爬虫(一)：利用urllib进行简单的网页抓取&lt;/a&gt;, &lt;br/&gt;, &apos;\n&apos;, &lt;a class=&quot;sister&quot; href=&quot;http://blog.csdn.net/c406495762/article/details/59095864&quot; id=&quot;link2&quot;&gt;Python3网络爬虫(二)：利用urllib.urlopen发送数据&lt;/a&gt;, &lt;br/&gt;, &apos;\n&apos;, &lt;a class=&quot;sister&quot; href=&quot;http://blog.csdn.net/c406495762/article/details/59488464&quot; id=&quot;link3&quot;&gt;Python3网络爬虫(三)：urllib.error异常&lt;/a&gt;, &lt;br/&gt;, &apos;\n&apos;] 输出方式为列表，可以用列表索引来获取它的某一个元素 print(soup.body.contents[1]) 结果： &lt;p class=&quot;title&quot; name=&quot;blog&quot;&gt;&lt;b&gt;My Blog&lt;/b&gt;&lt;/p&gt; children返回的不是一个 list，不过可以通过遍历获取所有子节点，它是一个 list 生成器对象 for child in soup.body.children: print(child) 结果： &lt;p class=&quot;title&quot; name=&quot;blog&quot;&gt;&lt;b&gt;My Blog&lt;/b&gt;&lt;/p&gt; &lt;li&gt;&lt;!--注释--&gt;&lt;/li&gt; &lt;a class=&quot;sister&quot; href=&quot;http://blog.csdn.net/c406495762/article/details/58716886&quot; id=&quot;link1&quot;&gt;Python3网络爬虫(一)：利用urllib进行简单的网页抓取&lt;/a&gt; &lt;br/&gt; &lt;a class=&quot;sister&quot; href=&quot;http://blog.csdn.net/c406495762/article/details/59095864&quot; id=&quot;link2&quot;&gt;Python3网络爬虫(二)：利用urllib.urlopen发送数据&lt;/a&gt; &lt;br/&gt; &lt;a class=&quot;sister&quot; href=&quot;http://blog.csdn.net/c406495762/article/details/59488464&quot; id=&quot;link3&quot;&gt;Python3网络爬虫(三)：urllib.error异常&lt;/a&gt; &lt;br/&gt; 搜索文档树find_all() 方法搜索当前tag的所有tag子节点,并判断是否符合过滤器的条件 find_all(name, attrs, recursive, text, limit, **kwargs)： 1) name参数：name 参数可以查找所有名字为 name 的tag,字符串对象会被自动忽略掉。传递字符： print(soup.find_all(&apos;a&apos;)) 传递正则表达式： 如果传入正则表达式作为参数,Beautiful Soup会通过正则表达式的 match() 来匹配内容.下面例子中找出所有以b开头的标签,这表示&lt;body&gt;和&lt;b&gt;标签都应该被找到 import re for tag in soup.find_all(re.compile(&quot;^b&quot;)): print(tag.name) 传递列表： 如果传入列表参数，Beautiful Soup会将与列表中任一元素匹配的内容返回，下面代码找到文档中所有&lt;title&gt;标签和&lt;b&gt;标签 print(soup.find_all([&apos;title&apos;,&apos;b&apos;])) 传递True： True 可以匹配任何值,下面代码查找到所有的tag,但是不会返回字符串节点： for tag in soup.find_all(True): print(tag.name) 结果： html head title body p b li a br a br a br 2)attrs参数 可以通过 find_all() 方法的 attrs 参数定义一个字典参数来搜索包含特殊属性的tag。 print(soup.find_all(attrs={&quot;class&quot;:&quot;title&quot;})) 结果: [&lt;p class=&quot;title&quot; name=&quot;blog&quot;&gt;&lt;b&gt;My Blog&lt;/b&gt;&lt;/p&gt;] 3)recursive参数 调用tag的 find_all() 方法时,Beautiful Soup会检索当前tag的所有子孙节点,如果只想搜索tag的直接子节点,可以使用参数 recursive=False 4)text参数 通过 text 参数可以搜搜文档中的字符串内容，与 name 参数的可选值一样, text 参数接受字符串 , 正则表达式 , 列表, True。 5)limit参数 find_all() 方法返回全部的搜索结构,如果文档树很大那么搜索会很慢.如果我们不需要全部结果,可以使用 limit 参数限制返回结果的数量.当搜索到的结果数量达到 limit 的限制时,就停止搜索返回结果。 print(soup.find_all(&quot;a&quot;, limit=2)) 6)kwargs参数 如果传入 class 参数,Beautiful Soup 会搜索每个 class 属性为 title 的 tag 。kwargs 接收字符串，正则表达式 print(soup.find_all(class_=&quot;title&quot;)) 结果： [&lt;p class=&quot;title&quot; name=&quot;blog&quot;&gt;&lt;b&gt;My Blog&lt;/b&gt;&lt;/p&gt;] 单章小说内容爬取# -*- coding:UTF-8 -*- from urllib import request from bs4 import BeautifulSoup if __name__ == &quot;__main__&quot;: download_url = &apos;http://www.biqukan.com/1_1094/5403177.html&apos; head = {} head[&apos;User-Agent&apos;] = &apos;Mozilla/5.0 (Linux; Android 4.1.1; Nexus 7 Build/JRO03D) AppleWebKit/535.19 (KHTML, like Gecko) Chrome/18.0.1025.166 Safari/535.19&apos; download_req = request.Request(url = download_url, headers = head) download_response = request.urlopen(download_req) download_html = download_response.read().decode(&apos;gbk&apos;,&apos;ignore&apos;) soup_texts = BeautifulSoup(download_html, &apos;lxml&apos;) texts = soup_texts.find_all(id = &apos;content&apos;, class_ = &apos;showtxt&apos;) soup_text = BeautifulSoup(str(texts), &apos;lxml&apos;) #将\xa0无法解码的字符删除 print(soup_text.div.text.replace(&apos;\xa0&apos;,&apos;&apos;)) 各章小说链接爬取# -*- coding:UTF-8 -*- from urllib import request from bs4 import BeautifulSoup if __name__ == &quot;__main__&quot;: target_url = &apos;http://www.biqukan.com/1_1094/&apos; head = {} head[&apos;User-Agent&apos;] = &apos;Mozilla/5.0 (Linux; Android 4.1.1; Nexus 7 Build/JRO03D) AppleWebKit/535.19 (KHTML, like Gecko) Chrome/18.0.1025.166 Safari/535.19&apos; target_req = request.Request(url = target_url, headers = head) target_response = request.urlopen(target_req) target_html = target_response.read().decode(&apos;gbk&apos;,&apos;ignore&apos;) #创建BeautifulSoup对象 listmain_soup = BeautifulSoup(target_html,&apos;lxml&apos;) #搜索文档树,找出div标签中class为listmain的所有子标签 chapters = listmain_soup.find_all(&apos;div&apos;,class_ = &apos;listmain&apos;) #使用查询结果再创建一个BeautifulSoup对象,对其继续进行解析 download_soup = BeautifulSoup(str(chapters), &apos;lxml&apos;) #开始记录内容标志位,只要正文卷下面的链接,最新章节列表链接剔除 begin_flag = False #遍历dl标签下所有子节点 for child in download_soup.dl.children: #滤除回车 if child != &apos;\n&apos;: #找到《一念永恒》正文卷,使能标志位 if child.string == u&quot;《一念永恒》正文卷&quot;: begin_flag = True #爬取链接 if begin_flag == True and child.a != None: download_url = &quot;http://www.biqukan.com&quot; + child.a.get(&apos;href&apos;) download_name = child.string print(download_name + &quot; : &quot; + download_url) 爬取所有章节内容，并保存到文件中-- coding:UTF-8 --from urllib import requestfrom bs4 import BeautifulSoupimport collectionsimport reimport osimport timeimport sysimport types “””类说明:下载《笔趣看》网小说: url:http://www.biqukan.com/Parameters: target - 《笔趣看》网指定的小说目录地址(string)Returns: 无Modify: 2017-05-06“””class download(object): def init(self, target): self.target_url = target self.head = {‘User-Agent’:’Mozilla/5.0 (Linux; Android 4.1.1; Nexus 7 Build/JRO03D) AppleWebKit/535.19 (KHTML, like Gecko) Chrome/18.0.1025.166 Safari/535.19’,} &quot;&quot;&quot; 函数说明:获取下载链接 Parameters: 无 Returns: novel_name + &apos;.txt&apos; - 保存的小说名(string) numbers - 章节数(int) download_dict - 保存章节名称和下载链接的字典(dict) Modify: 2017-05-06 &quot;&quot;&quot; def get_download_url(self): charter = re.compile(u&apos;[第弟](.+)章&apos;, re.IGNORECASE) target_req = request.Request(url = self.__target_url, headers = self.__head) target_response = request.urlopen(target_req) target_html = target_response.read().decode(&apos;gbk&apos;,&apos;ignore&apos;) listmain_soup = BeautifulSoup(target_html,&apos;lxml&apos;) chapters = listmain_soup.find_all(&apos;div&apos;,class_ = &apos;listmain&apos;) download_soup = BeautifulSoup(str(chapters), &apos;lxml&apos;) novel_name = str(download_soup.dl.dt).split(&quot;》&quot;)[0][5:] flag_name = &quot;《&quot; + novel_name + &quot;》&quot; + &quot;正文卷&quot; numbers = (len(download_soup.dl.contents) - 1) / 2 - 8 download_dict = collections.OrderedDict() begin_flag = False numbers = 1 for child in download_soup.dl.children: if child != &apos;\n&apos;: if child.string == u&quot;%s&quot; % flag_name: begin_flag = True if begin_flag == True and child.a != None: download_url = &quot;http://www.biqukan.com&quot; + child.a.get(&apos;href&apos;) download_name = child.string names = str(download_name).split(&apos;章&apos;) name = charter.findall(names[0] + &apos;章&apos;) if name: download_dict[&apos;第&apos; + str(numbers) + &apos;章 &apos; + names[1]] = download_url numbers += 1 return novel_name + &apos;.txt&apos;, numbers, download_dict &quot;&quot;&quot; 函数说明:爬取文章内容 Parameters: url - 下载连接(string) Returns: soup_text - 章节内容(string) Modify: 2017-05-06 &quot;&quot;&quot; def Downloader(self, url): download_req = request.Request(url = url, headers = self.__head) download_response = request.urlopen(download_req) download_html = download_response.read().decode(&apos;gbk&apos;,&apos;ignore&apos;) soup_texts = BeautifulSoup(download_html, &apos;lxml&apos;) texts = soup_texts.find_all(id = &apos;content&apos;, class_ = &apos;showtxt&apos;) soup_text = BeautifulSoup(str(texts), &apos;lxml&apos;).div.text.replace(&apos;\xa0&apos;,&apos;&apos;) return soup_text &quot;&quot;&quot; 函数说明:将爬取的文章内容写入文件 Parameters: name - 章节名称(string) path - 当前路径下,小说保存名称(string) text - 章节内容(string) Returns: 无 Modify: 2017-05-06 &quot;&quot;&quot; def Writer(self, name, path, text): write_flag = True with open(path, &apos;a&apos;, encoding=&apos;utf-8&apos;) as f: f.write(name + &apos;\n\n&apos;) for each in text: if each == &apos;h&apos;: write_flag = False if write_flag == True and each != &apos; &apos;: f.write(each) if write_flag == True and each == &apos;\r&apos;: f.write(&apos;\n&apos;) f.write(&apos;\n\n&apos;) if name == “main“: print(“\n\t\t欢迎使用《笔趣看》小说下载小工具\n\n\t\t作者:Jack-Cui\t时间:2017-05-06\n”) print(“*“) #小说地址 target_url = str(input(&quot;请输入小说目录下载地址:\n&quot;)) #实例化下载类 d = download(target = target_url) name, numbers, url_dict = d.get_download_url() if name in os.listdir(): os.remove(name) index = 1 #下载中 print(&quot;《%s》下载中:&quot; % name[:-4]) for key, value in url_dict.items(): d.Writer(key, name, d.Downloader(value)) sys.stdout.write(&quot;已下载:%.3f%%&quot; % float(index/numbers) + &apos;\r&apos;) sys.stdout.flush() index += 1 print(&quot;《%s》下载完成！&quot; % name[:-4])]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[python3爬取微信朋友圈信息]]></title>
      <url>%2F2017%2F03%2F30%2Fpython%E6%B5%8F%E8%A7%88%E5%BE%AE%E4%BF%A1%E6%9C%8B%E5%8F%8B%E5%9C%88%2F</url>
      <content type="text"><![CDATA[itchatitchat是一个开源的微信个人号接口，使用不到三十行的代码，就可以完成一个能够处理所有信息的微信机器人。可以通过本命令安装itchat： pip install itchat 微信好友男女比例import itchat from echarts import Echart, Legend, Pie,Bar # 先登录 itchat.login() # 获取好友列表 friends = itchat.get_friends(update=True)[0:] # 初始化计数器，有男有女，当然，有些人是不填的 male = female = other = 0 # 遍历这个列表，列表里第一位是自己，所以从&quot;自己&quot;之后开始计算 # 1表示男性，2女性 for i in friends[1:]: sex = i[&quot;Sex&quot;] if sex == 1: male += 1 elif sex == 2: female += 1 else: other += 1 # 总数算上，好计算比例啊～ total = len(friends[1:]) # 好了，打印结果 print (&quot;男性好友：%.2f%%&quot; % (float(male) / total * 100)) print (&quot;女性好友：%.2f%%&quot; % (float(female) / total * 100)) print (&quot;其他：%.2f%%&quot; % (float(other) / total * 100)) 微信好友男女比例图形化展示安装Echarts库： pip install echarts-python 源码： import itchat from echarts import Echart, Legend, Pie,Bar # 先登录 itchat.login() # 获取好友列表 friends = itchat.get_friends(update=True)[0:] # 初始化计数器，有男有女，当然，有些人是不填的 male = female = other = 0 # 遍历这个列表，列表里第一位是自己，所以从&quot;自己&quot;之后开始计算 # 1表示男性，2女性 for i in friends[1:]: sex = i[&quot;Sex&quot;] if sex == 1: male += 1 elif sex == 2: female += 1 else: other += 1 # 总数算上，好计算比例啊～ total = len(friends[1:]) # 好了，打印结果 print (&quot;男性好友：%.2f%%&quot; % (float(male) / total * 100)) print (&quot;女性好友：%.2f%%&quot; % (float(female) / total * 100)) print (&quot;其他：%.2f%%&quot; % (float(other) / total * 100)) chart = Echart(&apos;%s的微信好友性别比例&apos; % (friends[0][&apos;NickName&apos;]), &apos;from WeChat&apos;) chart.use(Pie(&apos;WeChat&apos;, [{&apos;value&apos;: male, &apos;name&apos;: &apos;男性 %.2f%%&apos; % (float(male) / total * 100)}, {&apos;value&apos;: female, &apos;name&apos;: &apos;女性 %.2f%%&apos; % (float(female) / total * 100)}, {&apos;value&apos;: other, &apos;name&apos;: &apos;其他 %.2f%%&apos; % (float(other) / total * 100)}], radius=[&quot;50%&quot;, &quot;70%&quot;])) chart.use(Legend([&quot;male&quot;, &quot;female&quot;, &quot;other&quot;])) chart.plot() 由于echarts库适用于python2.7,故直接运行会报错，在init.py中的95与105行出修改如下： with open(os.path.join(os.path.dirname(__file__), &apos;plot.j2&apos;),&apos;r&apos;,encoding=&apos;utf-8&apos;) as f: template = f.read() fobj.write(self._html().encode(&apos;utf-8&apos;))]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[python3时间模块datetime]]></title>
      <url>%2F2017%2F03%2F30%2Fpython%E6%97%B6%E9%97%B4%E6%A8%A1%E5%9D%97datetime%2F</url>
      <content type="text"><![CDATA[#datetime#相比于time模块，datetime模块的接口更直观、更容易调用。 datetime模块下的常量： datetime.MINYEAR和datetime.MAXYEAR，分别表示datetime所能表示的最 小、最大年份。其中，MINYEAR = 1，MAXYEAR = 9999。 datetime模块下的类（不可变（immutable）的）： datetime.date：表示日期的类。常用的属性有year, month, day； datetime.time：表示时间的类。常用的属性有hour, minute, second, microsecond； datetime.datetime：表示日期时间。 datetime.timedelta：表示时间间隔，即两个时间点之间的长度。 datetime.tzinfo：与时区有关的相关信息。 date类date类表示一个日期。日期由年、月、日组成。构造函数如下： class datetime.date(year, month, day)： year的范围是[MINYEAR, MAXYEAR]，即[1, 9999]；month的范围是[1, 12]。（月份是从1开始的，不是从0开始的~_~）；day的最大值根据给定的year, month参数来决定。例如闰年2月份有29天； date类定义的类方法与类属性：date.max、date.min：date对象所能表示的最大、最小日期；date.resolution：date对象表示日期的最小单位。这里是天。date.today()：返回一个表示当前本地日期的date对象；date.fromtimestamp(timestamp)：根据给定的时间戮，返回一个date对象；datetime.fromordinal(ordinal)：将Gregorian日历时间转换为date对象； from datetime import * import time print (&apos;date.max:&apos; , date.max) print (&apos;date.min:&apos; , date.min) print (&apos;date.today():&apos; , date.today()) print (&apos;date.fromtimestamp():&apos; , date.fromtimestamp(time.time())) 结果： date.max: 9999-12-31 date.min: 0001-01-01 date.today(): 2017-07-04 date.fromtimestamp(): 2017-07-04 date提供的实例方法和属性：date.year、date.month、date.day：年、月、日；date.replace(year, month, day)：生成一个新的日期对象，用参数指定的年，月，日代替原有对象中的属性。（原有对象仍保持不变）date.timetuple()：返回日期对应的time.struct_time对象；date.toordinal()：返回日期对应的Gregorian Calendar日期；date.weekday()：返回weekday，如果是星期一，返回0；如果是星期2，返回1，以此类推；data.isoweekday()：返回weekday，如果是星期一，返回1；如果是星期2，返回2，以此类推；date.isocalendar()：返回格式如(year，month，day)的元组；date.isoformat()：返回格式如’YYYY-MM-DD’的字符串；date.strftime(fmt)：自定义格式化字符串。 from datetime import * now = date(2017,7,4) tomorrow = now.replace(day=5) print (&apos;now:&apos; , now, &apos;, tomorrow:&apos; , tomorrow ) print (&apos;timetuple():&apos; , now.timetuple()) print (&apos;weekday():&apos; , now.weekday()) print (&apos;isoweekday():&apos; , now.isoweekday()) print (&apos;isocalendar():&apos; , now.isocalendar()) print (&apos;isoformat():&apos; , now.isoformat()) 结果： now: 2017-07-04 , tomorrow: 2017-07-05 timetuple(): time.struct_time(tm_year=2017, tm_mon=7, tm_mday=4, tm_hour=0, tm_min=0, tm_sec=0, tm_wday=1, tm_yday=185, tm_isdst=-1) weekday(): 1 isoweekday(): 2 isocalendar(): (2017, 27, 2) isoformat(): 2017-07-04 date类重载：date2 = date1 + timedelta # 日期加上一个间隔，返回一个新的日期对象date2 = date1 - timedelta # 日期隔去间隔，返回一个新的日期对象timedelta = date1 - date2 # 两个日期相减，返回一个时间间隔对象date1 &lt; date2 # 两个日期进行比较 from datetime import * now = date.today() tomorrow = now.replace(day = 7 ) delta = tomorrow - now print (&apos;now:&apos; , now, &apos; tomorrow:&apos; , tomorrow) print (&apos;timedelta:&apos; , delta ) print (now + delta) print (tomorrow &gt; now) 结果： now: 2017-07-04 tomorrow: 2017-07-07 timedelta: 3 days, 0:00:00 2017-07-07 True Time类 time类表示时间，由时、分、秒以及微秒组成。构造函数如下： class datetime.time(hour[ , minute[ , second[ , microsecond[ , tzinfo] ] ] ] ) 参数tzinfo，表示时区信息。hour的范围为[0, 24)，minute的范围为[0, 60)，second的范围为[0, 60)，microsecond的范围为[0, 1000000)。 time类定义的类属性：time.min、time.max：time类所能表示的最小、最大时间。其中，time.min = time(0, 0, 0, 0)， time.max = time(23, 59, 59, 999999)；time.resolution：时间的最小单位，这里是1微秒； time类提供的实例方法和属性：time.hour、time.minute、time.second、time.microsecond：时、分、秒、微秒；time.tzinfo：时区信息；time.replace([ hour[ , minute[ , second[ , microsecond[ , tzinfo] ] ] ] ] )：创建一个新的时间对象，用参数指定的时、分、秒、微秒代替原有对象中的属性（原有对象仍保持不变）；time.isoformat()：返回型如”HH:MM:SS”格式的字符串表示；time.strftime(fmt)：返回自定义格式化字符串。 from datetime import * tm = time(23 , 46 , 10 ) print (&apos;tm:&apos; , tm ) print (&apos;hour: %d, minute: %d, second: %d, microsecond: %d&apos; % (tm.hour, tm.minute, tm.second, tm.microsecond) ) tm1 = tm.replace(hour = 20 ) print (&apos;tm1:&apos; , tm1 ) print (&apos;isoformat():&apos; , tm.isoformat() ) 结果： tm: 23:46:10 hour: 23, minute: 46, second: 10, microsecond: 0 tm1: 20:46:10 isoformat(): 23:46:10 datetime类datetime是date与time的结合体，包括date与time的所有信息。构造函数如下： datetime.datetime (year, month, day[ , hour[ , minute[ , second[ , microsecond[ , tzinfo] ] ] ] ] )， datetime类定义的类属性与方法：datetime.min、datetime.max：datetime所能表示的最小值与最大值；datetime.resolution：datetime最小单位；datetime.today()：返回一个表示当前本地时间的datetime对象；datetime.now([tz])：返回一个表示当前本地时间的datetime对象，如果提供了参数tz，则获取tz参数所指时区的本地时间；datetime.utcnow()：返回一个当前utc时间的datetime对象；datetime.fromtimestamp(timestamp[, tz])：根据时间戮创建一个datetime对象，参数tz指定时区信息；datetime.utcfromtimestamp(timestamp)：根据时间戮创建一个datetime对象；datetime.combine(date, time)：根据date和time，创建一个datetime对象；datetime.strptime(date_string, format)：将格式字符串转换为datetime对象； from datetime import * import time print (&apos;datetime.max:&apos; , datetime.max) print (&apos;datetime.min:&apos; , datetime.min) print (&apos;datetime.resolution:&apos; , datetime.resolution ) print (&apos;today():&apos; , datetime.today() ) print (&apos;now():&apos; , datetime.now() ) print (&apos;utcnow():&apos; , datetime.utcnow() ) print (&apos;fromtimestamp(tmstmp):&apos; , datetime.fromtimestamp(time.time()) ) print (&apos;utcfromtimestamp(tmstmp):&apos; , datetime.utcfromtimestamp(time.tim()) ) 结果: atetime.max: 9999-12-31 23:59:59.999999 datetime.min: 0001-01-01 00:00:00 datetime.resolution: 0:00:00.000001 today(): 2017-07-04 13:59:23.976966 now(): 2017-07-04 13:59:23.976965 utcnow(): 2017-07-04 05:59:23.976965 fromtimestamp(tmstmp): 2017-07-04 13:59:23.976966 utcfromtimestamp(tmstmp): 2017-07-04 05:59:23.976966 datetime类提供的实例方法与属性:datetime.year、month、day、hour、minute、second、microsecond、tzinfo datetime.date()：获取date对象； datetime.time()：获取time对象； datetime. replace ([ year[ , month[ , day[ , hour[ , minute[ , second[ , microsecond[ , tzinfo] ] ] ] ] ] ] ]) datetime. timetuple () datetime. utctimetuple () datetime. toordinal () datetime. weekday () datetime. isocalendar () datetime. isoformat ([ sep] ) datetime. ctime ()：返回一个日期时间的C格式字符串，等效于time.ctime(time.mktime(dt.timetuple()))； datetime. strftime (format) 字符串转换datetime、date、time都提供了strftime()方法，该方法接收一个格式字符串，输出日期时间的字符串表示%a 星期的简写。如 星期三为Web%A 星期的全写。如 星期三为Wednesday%b 月份的简写。如4月份为Apr%B月份的全写。如4月份为April%c: 日期时间的字符串表示。（如： 04/07/10 10:43:39）%d: 日在这个月中的天数（是这个月的第几天）%f: 微秒（范围[0,999999]）%H: 小时（24小时制，[0, 23]）%I: 小时（12小时制，[0, 11]）%j: 日在年中的天数 [001,366]（是当年的第几天）%m: 月份（[01,12]）%M: 分钟（[00,59]）%p: AM或者PM%S: 秒（范围为[00,61]，为什么不是[00, 59]，参考python手册~_~）%U: 周在当年的周数当年的第几周），星期天作为周的第一天%w: 今天在这周的天数，范围为[0, 6]，6表示星期天%W: 周在当年的周数（是当年的第几周），星期一作为周的第一天%x: 日期字符串（如：04/07/10）%X: 时间字符串（如：10:43:39）%y: 2个数字表示的年份%Y: 4个数字表示的年份%z: 与utc时间的间隔 （如果是本地时间，返回空字符串）%Z: 时区名称（如果是本地时间，返回空字符串）%%: %% =&gt; % from datetime import * import time dt = datetime.now() print (&apos;(%Y-%m-%d %H:%M:%S %f): &apos;, dt.strftime(&apos;%Y-%m-%d %H:%M:%S %f&apos;) ) print (&apos;(%Y-%m-%d %H:%M:%S %p): &apos;, dt.strftime(&apos;%y-%m-%d %I:%M:%S %p&apos;) ) print (&apos;%%a: %s &apos; % dt.strftime(&apos;%a&apos;) ) print (&apos;%%A: %s &apos; % dt.strftime(&apos;%A&apos;) ) print (&apos;%%b: %s &apos; % dt.strftime(&apos;%b&apos;) ) print (&apos;%%B: %s &apos; % dt.strftime(&apos;%B&apos;) ) print (&apos;日期时间%%c: %s &apos; % dt.strftime(&apos;%c&apos;) ) print (&apos;日期%%x：%s &apos; % dt.strftime(&apos;%x&apos;) ) print (&apos;时间%%X：%s &apos; % dt.strftime(&apos;%X&apos;) ) print (&apos;今天是这周的第%s天 &apos; % dt.strftime(&apos;%w&apos;) ) print (&apos;今天是今年的第%s天 &apos; % dt.strftime(&apos;%j&apos;) ) print (&apos;今周是今年的第%s周 &apos; % dt.strftime(&apos;%U&apos;) ) 结果： (%Y-%m-%d %H:%M:%S %f): 2017-07-04 14:04:12 784484 (%Y-%m-%d %H:%M:%S %p): 17-07-04 02:04:12 PM %a: Tue %A: Tuesday %b: Jul %B: July 日期时间%c: Tue Jul 4 14:04:12 2017 日期%x：07/04/17 时间%X：14:04:12 今天是这周的第2天 今天是今年的第185天 今周是今年的第27周 #把datetime转成字符串 def datetime_toString(dt): return dt.strftime(&quot;%Y-%m-%d-%H&quot;) #把字符串转成datetime def string_toDatetime(string): return datetime.strptime(string, &quot;%Y-%m-%d-%H&quot;) #把字符串转成时间戳形式 def string_toTimestamp(strTime): return time.mktime(string_toDatetime(strTime).timetuple()) #把时间戳转成字符串形式 def timestamp_toString(stamp): return time.strftime(&quot;%Y-%m-%d-%H&quot;, tiem.localtime(stamp)) #把datetime类型转外时间戳形式 def datetime_toTimestamp(dateTim): return time.mktime(dateTim.timetuple())]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[python3正则表达式]]></title>
      <url>%2F2017%2F03%2F30%2Fpython%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%2F</url>
      <content type="text"><![CDATA[前言学习python3时常遇到正则表达式，参考博文进行学习 正则表达式正则表达式是字符串处理的常用工具，通常被用来检索、替换那些符合某个模式的文本 ##用途 ## 测试字符串内的模式（数据验证）—— 例如，可以测试输入字符串，以查看字符串内是否出现电话号码模式或信用卡号码模式。 替换文本—— 可以使用正则表达式来识别文档中的特定文本，完全删除该文本或者用其他文本替换它。 基于模式匹配从字符串中提取子字符串—— 可以查找文档内或输入域内特定的文本。 语法贪婪模式”尝试匹配尽可能多的字符；“非贪婪模式”则相反，总是匹配尽可能少的字符。 re模块Python通过re模块提供对正则表达式的支持。使用re的一般步骤是先将正则表达式的字符串形式编译为Pattern实例，然后使用Pattern实例处理文本并获得匹配结果 compile()re.compile() 函数将一个字符串编译成 pattern object，用于匹配或搜索： re.compile(strPattern[, flag]): 第二个参数flag是匹配模式，取值可以使用按位或运算符’|’表示同时生效，比如re.I | re.M。 可选值有：re.I(re.IGNORECASE): 忽略大小写（括号内是完整写法）M(MULTILINE): 多行模式，改变’^’和’$’的行为S(DOTALL): 点任意匹配模式，改变’.’的行为L(LOCALE): 使预定字符类 \w \W \b \B \s \S 取决于当前区域设定U(UNICODE): 使预定字符类 \w \W \b \B \s \S \d \D 取决于unicode定义的字符属性X(VERBOSE): 详细模式。这个模式下正则表达式可以是多行，忽略空白字符，并可以加入注释。 如果在pattern生成时已经指明了flags，那么在下面的方法中就不需要传入这个参数。 match()Match对象是一次匹配的结果，包含了很多关于此次匹配的信息，可以使用Match提供的可读属性或方法来获取这些信息,比如，起始位置、匹配到的子串 re.match(pattern, string[, flags]) 属性： string: 匹配时使用的文本。re: 匹配时使用的Pattern对象。pos: 文本中正则表达式开始搜索的索引。值与Pattern.match()和Pattern.seach()方法的同名参数相同。endpos: 文本中正则表达式结束搜索的索引。值与Pattern.match()和Pattern.seach()方法的同名参数相同。lastindex: 最后一个被捕获的分组在文本中的索引。如果没有被捕获的分组，将为None。lastgroup: 最后一个被捕获的分组的别名。如果这个分组没有别名或者没有被捕获的分组，将为None。 方法： group([group1, …]):获得一个或多个分组截获的字符串；指定多个参数时将以元组形式返回。group1可以使用编号也可以使用别名；编号0代表整个匹配的子串；不填写参数时，返回group(0)；没有截获字符串的组返回None；截获了多次的组返回最后一次截获的子串。 groups([default]):以元组形式返回全部分组截获的字符串。相当于调用group(1,2,…last)。default表示没有截获字符串的组以这个值替代，默认为None。 groupdict([default]): 返回以有别名的组的别名为键、以该组截获的子串为值的字典，没有别名的组不包含在内。default含义同上。 start([group]): 返回指定的组截获的子串在string中的起始索引（子串第一个字符的索引）。group默认值为0。 end([group]): 返回指定的组截获的子串在string中的结束索引（子串最后一个字符的索引+1）。group默认值为0。 span([group]): 返回(start(group), end(group))。 expand(template): 将匹配到的分组代入template中然后返回。template中可以使用\id或\g、\g引用分组，但不能使用编号0。\id与\g是等价的；但\10将被认为是第10个分组，如果你想表达\1之后是字符’0’，只能使用\g0。 PatternPattern对象是一个编译好的正则表达式，通过Pattern提供的一系列方法可以对文本进行匹配查找。 Pattern不能直接实例化，必须使用re.compile()进行构造。 Pattern提供了几个可读属性用于获取表达式的相关信息：pattern: 编译时用的表达式字符串。flags: 编译时用的匹配模式。数字形式。groups: 表达式中分组的数量。groupindex: 以表达式中有别名的组的别名为键、以该组对应的编号为值的字典，没有别名的组不包含在内。 re模块方法re.match(pattern, string[, flags]):从string的pos下标处起尝试匹配pattern；如果pattern结束时仍可匹配，则返回一个Match对象；如果匹配过程中pattern无法匹配，或者匹配未结束就已到达endpos，则返回None。 pos和endpos的默认值分别为0和len(string)；re.match()无法指定这两个参数，参数flags用于编译pattern时指定匹配模式。 注意：这个方法并不是完全匹配。当pattern结束时若string还有剩余字符，仍然视为成功。想要完全匹配，可以在表达式末尾加上边界匹配符’$’。 import re # 将正则表达式编译成Pattern对象，注意hello前面的r的意思是“原生字符串” pattern = re.compile(r&apos;hello&apos;) # 使用re.match匹配文本，获得匹配结果，无法匹配时将返回None result1 = re.match(pattern,&apos;hello&apos;) result2 = re.match(pattern,&apos;helloo python!&apos;) result3 = re.match(pattern,&apos;helo python!&apos;) result4 = re.match(pattern,&apos;hello python!&apos;) #如果1匹配成功 if result1: # 使用Match获得分组信息 print (result1.group()) else: print (&apos;1匹配失败！&apos;) #如果2匹配成功 if result2: # 使用Match获得分组信息 print (result2.group()) else: print (&apos;2匹配失败！&apos;) #如果3匹配成功 if result3: # 使用Match获得分组信息 print (result3.group()) else: print (&apos;3匹配失败！&apos;) #如果4匹配成功 if result4: # 使用Match获得分组信息 print (result4.group()) else: print (&apos;4匹配失败！&apos;) 结果： hello hello 3匹配失败！ hello 1.第一个匹配，pattern正则表达式为’hello’，我们匹配的目标字符串string也为hello，从头至尾完全匹配，匹配成功。 2.第二个匹配，string为helloo CQC，从string头开始匹配pattern完全可以匹配，pattern匹配结束，同时匹配终止，后面的o CQC不再匹配，返回匹配成功的信息。 3.第三个匹配，string为helo CQC，从string头开始匹配pattern，发现到 ‘o’ 时无法完成匹配，匹配终止，返回None 4.第四个匹配，同第二个匹配原理，即使遇到了空格符也不会受影响。 re.search(pattern, string[, flags])用于查找字符串中可以匹配成功的子串。从string的pos下标处起尝试匹配pattern，如果pattern结束时仍可匹配，则返回一个Match对象；若无法匹配，则将pos加1后重新尝试匹配；直到pos=endpos时仍无法匹配则返回None。 pos和endpos的默认值分别为0和len(string))；re.search()无法指定这两个参数，参数flags用于编译pattern时指定匹配模式 import re # 将正则表达式编译成Pattern对象 pattern = re.compile(r&apos;world&apos;) # 使用search()查找匹配的子串，不存在能匹配的子串时将返回None # 这个例子中使用match()无法成功匹配 match = re.search(pattern,&apos;hello world!&apos;) if match: # 使用Match获得分组信息 print (match.group()) 结果： world re.split(pattern, string[, maxsplit])按照能够匹配的子串将string分割后返回列表。maxsplit用于指定最大分割次数，不指定将全部分割。 import re pattern = re.compile(r&apos;\d+&apos;) print （re.split(pattern,&apos;one1two2three3four4&apos;)） 结果： [&apos;one&apos;, &apos;two&apos;, &apos;three&apos;, &apos;four&apos;, &apos;&apos;] import re pattern = re.compile(r&apos;\d&apos;) print (re.split(pattern,&apos;one12Qtwo23Qthree33Qfour44Q&apos;)) 结果： [&apos;one&apos;, &apos;&apos;, &apos;Qtwo&apos;, &apos;&apos;, &apos;Qthree&apos;, &apos;&apos;, &apos;Qfour&apos;, &apos;&apos;, &apos;Q&apos;] 通过上述两个例子可以看出，split()根据匹配的字串为分界进行分割，去掉匹配的字串后返回列表这里’\d+’表示尽可能的匹配0-9数字，即以数字为分界线进行分割 re.findall(pattern, string[, flags])搜索string，以列表形式返回全部能匹配的子串。与split()函数功能相反 import re pattern = re.compile(r&apos;\d&apos;) print (pattern.findall(&apos;one1two2three3four4&apos;)) 结果： [&apos;1&apos;, &apos;2&apos;, &apos;3&apos;, &apos;4&apos;] import re pattern = re.compile(r&apos;\d+&apos;) print (re.findall(pattern,&apos;one12Qtwo23Qthree33Qfour44Q&apos;)) 结果： [&apos;12&apos;, &apos;23&apos;, &apos;33&apos;, &apos;44&apos;] re.finditer(pattern, string[, flags])搜索string，返回一个顺序访问每一个匹配结果（Match对象）的迭代器 import re p = re.compile(r&apos;\d+&apos;) for m in p.finditer(&apos;one12Qtwo23Qthree33Qfour45Q&apos;): print (m.group()) 结果： 12 23 33 45 ###re.sub(pattern, repl, string[, count])###使用repl替换string中每一个匹配的子串后返回替换后的字符串。当repl是一个字符串时，可以使用\id或\g、\g引用分组，但不能使用编号0。当repl是一个方法时，这个方法应当只接受一个参数（Match对象），并返回一个字符串用于替换（返回的字符串中不能再引用分组）。count用于指定最多替换次数，不指定时全部替换。 import re p = re.compile(r&apos;(\w+) (\w+)&apos;) s = &apos;i say, hello world!&apos; print (p.sub(r&apos;\2 \1&apos;, s)) def func(m): return m.group(1).title() + &apos; &apos; + m.group(2).title() print (p.sub(func, s)) 结果： say i, world hello! I Say, Hello World! re.subn(pattern, repl, string[, count])返回 替换次数 import re p = re.compile(r&apos;(\w+) (\w+)&apos;) s = &apos;i say, hello world!&apos; print (p.subn(r&apos;\2 \1&apos;, s)) def func(m): return m.group(1).title() + &apos; &apos; + m.group(2).title() print (p.subn(func, s)) 结果： (&apos;say i, world hello!&apos;, 2) (&apos;I Say, Hello World!&apos;, 2) 常用匹配匹配中文字符[\\u4e00-\\u9fa5] 匹配双字节字符(包括汉字在内)[^\x00-\xff] 匹配空白行的正则表达式\n\s*\r 匹配 HTML 标记的正则表达式&lt;(\S*?)[^&gt;]*&gt;.*?&lt;/\1&gt;\|&lt;.*? /&gt; 说明：仅能匹配一部分，对于复杂的嵌套标记无能为力 匹配首尾空白字符的正则表达式首 ^\s* 尾 \s*$ 匹配Email地址的正则表达式\w+([-+.]\w+)*@\w+([-.]\w+)*\.\w+([-.]\w+)* 或者 [\w-]\+(\.[\w-]\+)*@[\w-]\+(\.[\w-]\+)\+ 匹配网址URL的正则表达式\(\l\|\u\)\+://[^\s]* 或者 \(\l\|\u\)\+://(\w\+(-\w\+)*)(\.(\w\+(-\w\+)*))*(\?\S*)? 匹配帐号是否合法(字母开头，5-16字节，允许字母数字下划线) \(\l\|\u\)\w\{4,15} 匹配国内固定电话号码\d\{3,4}-\d\{7,8} 匹配腾讯QQ号[1-9]\d\{4,} 说明：腾讯 QQ 号从 10000 开始 匹配国内邮政编码[1-9]\d\{5}(?!\d) 匹配身份证号\d\{15}\|\d\{18}\|\d\{17}[xX] 匹配ip地址\d+\.\d+\.\d+\.\d+ 匹配特定数字这里全不允许 0 打头，如果允许的话，需要调整一下： 非负整数 [1-9]\d*\|0 正整数 [1-9]\d* 非正整数 -[1-9]\d*\|0 负整数 -[1-9]\d* 整数 -?[1-9]\d* 非负浮点数 \d\+(\.\d\+)? 或者 [1-9]\d*\.\d*\|0\.\d*[1-9]\d*\|0?\.0+\|0 正浮点数 ((\d\+\.\d*[1-9]\d*)\|(\d*[1-9]\d*\.\d\+)\|(\d*[1-9]\d*)) 或者 [1-9]\d*\.\d*\|0\.\d*[1-9]\d* 非正浮点数 ((-\d\+(\.\d\+)?)\|(0\+(\.0\+)?)) 或者 (-([1-9]\d*\.\d*\|0\.\d*[1-9]\d*))\|0?\.0+\|0 负浮点数 (-((\d\+\.\d*[1-9]\d*)\|(\d*[1-9]\d*\.\d\+)\|(\d*[1-9]\d*))) 或者 -([1-9]\d*\.\d*\|0\.\d*[1-9]\d*) 浮点数 (-?\d\+)(\.\d\+)? 或者 -?([1-9]\d*\.\d*\|0\.\d*[1-9]\d*\|0?\.0+\|0) 匹配特定字符串由英文字母组成的字符串 \a\+ 由大写英文字母组成的字符串 \u\+ 由小写英文字母组成的字符串 \l\+ 由数字和英文字母组成的字符串 \(\l\|\u\|\d\)\+ 由数字、英文字母和下划线组成的字符串 \w\+ 特殊匹配前跟某模式，后跟某模式，前不跟某模式，后不跟某模式后跟bar的foo foo\(bar\)\@= 后不跟bar的foo foo\(bar\)\@! 前跟bar的foo \(bar\)\@&lt;=foo 前不跟bar的foo \(bar\)\@&lt;!foo]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[python3模块]]></title>
      <url>%2F2017%2F03%2F30%2Fpython%E6%A8%A1%E5%9D%97%2F</url>
      <content type="text"><![CDATA[模块脚本上是用 python 解释器来编程，如果从 Python 解释器退出再进入，那么定义的所有的方法和变量就都消失。 Python 提供了一个办法，把这些定义存放在文件中，为一些脚本或者交互式的解释器实例使用，这个文件被称为模块。模块是一个包含所有定义的函数和变量的文件，其后缀名是.py。模块可以被别的程序引入，以使用该模块中的函数等功能。这也是使用 python 标准库的方法。 import 语句想使用 Python 源文件，只需在另一个源文件里执行 import 语句，语法如下。当解释器遇到 import 语句，如果模块在当前的搜索路径就会被导入。一个模块只会被导入一次，不管你执行了多少次import。这样可以防止导入模块被一遍又一遍地执行。 import module1[, module2[,... moduleN] 当使用import语句的时候，Python解释器是怎样找到对应的文件的呢？这就涉及到Python的搜索路径，搜索路径是由一系列目录名组成的，Python解释器就依次从这些目录中去寻找所引入的模块。看起来很像环境变量，事实上，也可以通过定义环境变量的方式来确定搜索路径。搜索路径是在Python编译或安装的时候确定的，安装新的库应该也会修改。搜索路径被存储在sys模块中的path变量。 &gt;&gt;&gt; import sys &gt;&gt;&gt; sys.path [&apos;&apos;, &apos;D:\\python3.6\\python36.zip&apos;, &apos;D:\\python3.6\\DLLs&apos;, &apos;D:\\python3.6\\lib&apos;, &apos;D:\\python3.6&apos;, &apos;D:\\python3.6\\lib\\site-packages&apos;, &apos;D:\\python3.6\\lib\\site-packages\\pip-9.0.1-py3.6.egg&apos;, &apos;D:\\python3.6\\lib\\site-packages\\pylint-1.7.2-py3.6.egg&apos;, &apos;D:\\python3.6\\lib\\site-packages\\colorama-0.3.9-py3.6.egg&apos;, &apos;D:\\python3.6\\lib\\site-packages\\mccabe-0.6.1-py3.6.egg&apos;] sys.path 输出是一个列表，其中第一项是空串’’，代表当前目录（若是从一个脚本中打印出来的话，可以更清楚地看出是哪个目录），亦即我们执行python解释器的目录（对于脚本的话就是运行的脚本所在的目录）。 在sys.path 中的一个目录里面来创建一个fibo.py的文件（D:\python3.6\Lib\user） # 斐波那契(fibonacci)数列模块 def fib(n): # 定义到 n 的斐波那契数列 a, b = 0, 1 while b &lt; n: print(b, end=&apos; &apos;) a, b = b, a+b print() def fib2(n): # 返回到 n 的斐波那契数列 result = [] a, b = 0, 1 while b &lt; n: result.append(b) a, b = b, a+b return result 使用： import fibo fibo.fib(1000) #设置别名 fib = fibo.fib fib(500) From…import* 语句把一个模块的所有内容全都导入到当前的命名空间也是可行的，只需使用如下声明： from modname import * 深入模块模块除了方法定义，还可以包括可执行的代码。这些代码一般用来初始化这个模块。这些代码只有在第一次被导入时才会被执行。 每个模块有各自独立的符号表，在模块内部为所有的函数当作全局符号表来使用。所以，模块的作者可以放心大胆的在模块内部使用这些全局变量，而不用担心把其他用户的全局变量搞花。 模块是可以导入其他模块的。在一个模块（或者脚本，或者其他地方）的最前面使用 import 来导入一个模块，当然这只是一个惯例，而不是强制的。被导入的模块的名称将被放入当前操作的模块的符号表中。 还有一种导入的方法，可以使用 import 直接把模块内（函数，变量的）名称导入到当前操作模块。比如: from fibo import fib, fib2 fib(500) name属性一个模块被另一个程序第一次引入时，其主程序将运行。如果我们想在模块被引入时，模块中的某一程序块不执行，我们可以用name属性来使该程序块仅在该模块自身运行时执行。每个模块都有一个__name__属性，当其值是&#39;__main__&#39;时，表明该模块自身在运行，否则是被引入。 #!/usr/bin/python3 # Filename: using_name.py if __name__ == &apos;__main__&apos;: print(&apos;程序自身在运行&apos;) else: print(&apos;我来自另一模块&apos;) $ python using_name.py 程序自身在运行 &gt;&gt;&gt; import using_name 我来自另一模块 dir() 函数内置的函数 dir() 可以找到模块内定义的所有名称。以一个字符串列表的形式返回: &gt;&gt;&gt; import fibo,sys &gt;&gt;&gt; dir(fibo) [&apos;__builtins__&apos;, &apos;__cached__&apos;, &apos;__doc__&apos;, &apos;__file__&apos;, &apos;__loader__&apos;, &apos;__name__&apos;, &apos;__package__&apos;, &apos;__spec__&apos;, &apos;fib&apos;, &apos;fib2&apos;] &gt;&gt;&gt; dir(sys) [&apos;__displayhook__&apos;, &apos;__doc__&apos;, &apos;__excepthook__&apos;, &apos;__interactivehook__&apos;, &apos;__loader__&apos;, &apos;__name__&apos;, &apos;__package__&apos;, &apos;__spec__&apos;, &apos;__stderr__&apos;, &apos;__stdin__&apos;, &apos;__stdout__&apos;, &apos;_clear_type_cache&apos;, &apos;_current_frames&apos;, &apos;_debugmallocstats&apos;, &apos;_enablelegacywindowsfsencoding&apos;, &apos;_getframe&apos;, &apos;_git&apos;, &apos;_home&apos;, &apos;_xoptions&apos;, &apos;api_version&apos;, &apos;argv&apos;, &apos;base_exec_prefix&apos;, &apos;base_prefix&apos;, &apos;builtin_module_names&apos;, &apos;byteorder&apos;, &apos;call_tracing&apos;, &apos;callstats&apos;, &apos;copyright&apos;, &apos;displayhook&apos;, &apos;dllhandle&apos;, &apos;dont_write_bytecode&apos;, &apos;exc_info&apos;, &apos;excepthook&apos;, &apos;exec_prefix&apos;, &apos;executable&apos;, &apos;exit&apos;, &apos;flags&apos;, &apos;float_info&apos;, &apos;float_repr_style&apos;, &apos;get_asyncgen_hooks&apos;, &apos;get_coroutine_wrapper&apos;, &apos;getallocatedblocks&apos;, &apos;getcheckinterval&apos;, &apos;getdefaultencoding&apos;, &apos;getfilesystemencodeerrors&apos;, &apos;getfilesystemencoding&apos;, &apos;getprofile&apos;, &apos;getrecursionlimit&apos;, &apos;getrefcount&apos;, &apos;getsizeof&apos;, &apos;getswitchinterval&apos;, &apos;gettrace&apos;, &apos;getwindowsversion&apos;, &apos;hash_info&apos;, &apos;hexversion&apos;, &apos;implementation&apos;, &apos;int_info&apos;, &apos;intern&apos;, &apos;is_finalizing&apos;, &apos;maxsize&apos;, &apos;maxunicode&apos;, &apos;meta_path&apos;, &apos;modules&apos;, &apos;path&apos;, &apos;path_hooks&apos;, &apos;path_importer_cache&apos;, &apos;platform&apos;, &apos;prefix&apos;, &apos;ps1&apos;, &apos;ps2&apos;, &apos;set_asyncgen_hooks&apos;, &apos;set_coroutine_wrapper&apos;, &apos;setcheckinterval&apos;, &apos;setprofile&apos;, &apos;setrecursionlimit&apos;, &apos;setswitchinterval&apos;, &apos;settrace&apos;, &apos;stderr&apos;, &apos;stdin&apos;, &apos;stdout&apos;, &apos;thread_info&apos;, &apos;version&apos;, &apos;version_info&apos;, &apos;warnoptions&apos;, &apos;winver&apos;] &gt;&gt;&gt; 标准模块Python 本身带着一些标准的模块库。有些模块直接被构建在解析器里，这些虽然不是一些语言内置的功能，但是他却能很高效的使用，甚至是系统级调用也没问题。这些组件会根据不同的操作系统进行不同形式的配置。 模块 sys 内置在每一个 Python 解析器中。变量 sys.ps1 和 sys.ps2 定义了主提示符和副提示符所对应的字符串 包包是一种管理 Python 模块命名空间的形式，采用”点模块名称”。 比如一个模块的名称是 A.B， 那么他表示一个包 A中的子模块 B 。就好像使用模块的时候，你不用担心不同模块之间的全局变量相互影响一样，采用点模块名称这种形式也不用担心不同库之间的模块重名的情况。 假设你想设计一套统一处理声音文件和数据的模块（或者称之为一个”包”）。现存很多种不同的音频文件格式（基本上都是通过后缀名区分的，例如： .wav，:file:.aiff，:file:.au，），所以你需要有一组不断增加的模块，用来在不同的格式之间转换。并且针对这些音频数据，还有很多不同的操作（比如混音，添加回声，增加均衡器功能，创建人造立体声效果），所你还需要一组怎么也写不完的模块来处理这些操作。 这里给出了一种可能的包结构（在分层的文件系统中）: sound/ 顶层包 __init__.py 初始化 sound 包 formats/ 文件格式转换子包 __init__.py wavread.py wavwrite.py aiffread.py aiffwrite.py auread.py auwrite.py ... effects/ 声音效果子包 __init__.py echo.py surround.py reverse.py ... filters/ filters 子包 __init__.py equalizer.py vocoder.py karaoke.py ... 在导入一个包的时候，Python 会根据 sys.path 中的目录来寻找这个包中包含的子目录。目录只有包含一个叫做 init.py 的文件才会被认作是一个包，主要是为了避免一些滥俗的名字（比如叫做 string）不小心的影响搜索路径中的有效模块。 最简单的情况，放一个空的 :file:init.py就可以了。当然这个文件中也可以包含一些初始化代码或者为 all变量赋值。 用户可以每次只导入一个包里面的特定模块，比如: import sound.effects.echo #必须使用全名去访问: sound.effects.echo.echofilter(input, output, delay=0.7, atten=4) 还有一种导入子模块的方法是: from sound.effects import echo #使用 echo.echofilter(input, output, delay=0.7, atten=4) 还有一种变化就是直接导入一个函数或者变量: from sound.effects.echo import echofilter #直接使用他的 echofilter() 函数: echofilter(input, output, delay=0.7, atten=4) 从一个包中导入*from sound.effects import * Python 会进入文件系统，找到这个包里面所有的子模块，一个一个的把它们都导入进来。但是很不幸，这个方法在 Windows平台上工作的就不是非常好，因为Windows是一个大小写不区分的系统。在这类平台上，没有人敢担保一个叫做 ECHO.py 的文件导入为模块 echo 还是 Echo 甚至 ECHO。为了解决这个问题，只能烦劳包作者提供一个精确的包的索引了。 导入语句遵循如下规则：如果包定义文件 init.py 存在一个叫做 all 的列表变量，那么在使用 from package import * 的时候就把这个列表中的所有名字作为包内容导入。作为包的作者，可别忘了在更新包之后保证 all 也更新了啊。 在file:sounds/effects/init.py中包含如下代码: __all__ = [&quot;echo&quot;, &quot;surround&quot;, &quot;reverse&quot;] 这表示当你使用from sound.effects import 这种用法时，你只会导入包里面这三个子模块。如果 all 真的没有定义，那么使用from sound.effects import 这种语法的时候，就不会导入包 sound.effects 里的任何子模块。他只是把包sound.effects和它里面定义的所有内容导入进来（可能运行init.py里定义的初始化代码）。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[python3数据结构]]></title>
      <url>%2F2017%2F03%2F30%2Fpython%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%2F</url>
      <content type="text"><![CDATA[数据结构列表当做堆栈堆栈作为特定的数据结构，最先进入的元素最后一个被释放（后进先出）。用 append() 方法可以把一个元素添加到堆栈顶。用不指定索引的 pop() 方法可以把一个元素从堆栈顶释放出来 stack=[3,4,5] stack.append(6) stack.append(7) print(stack) stack.pop() stack.pop() print(stack) 结果： [3, 4, 5, 6, 7] [3, 4, 5] 列表当作队列列表当做队列用，只是在队列里第一加入的元素，第一个取出来；但是拿列表用作这样的目的效率不高。在列表的最后添加或者弹出元素速度快，然而在列表里插入或者从头部弹出速度却不快（因为所有其他的元素都得一个一个地移动）。 from collections import deque queue=deque([&quot;eric&quot;,&quot;john&quot;,&quot;meichael&quot;]) queue.append(&quot;terry&quot;) queue.append(&quot;graham&quot;) queue.popleft() queue.popleft() print(queue) 结果： deque([&apos;meichael&apos;, &apos;terry&apos;, &apos;graham&apos;]) 列表推导式列表推导式提供了从序列创建列表的简单途径。通常应用程序将一些操作应用于某个序列的每个元素，用其获得的结果作为生成新列表的元素，或者根据确定的判定条件创建子序列。每个列表推导式都在 for 之后跟一个表达式，然后有零到多个 for 或 if 子句。返回结果是一个根据表达从其后的 for 和 if 上下文环境中生成出来的列表。如果希望表达式推导出一个元组，就必须使用括号。 将列表中每个数值乘三，获得一个新的列表： &gt;&gt;&gt; vec = [2, 4, 6] &gt;&gt;&gt; [3*x for x in vec] [6, 12, 18] 嵌套列表解析Python的列表还可以嵌套 &gt;&gt;&gt; matrix = [ [1, 2, 3, 4], [5, 6, 7, 8], [9, 10, 11, 12], ] #将3X4的矩阵列表转换为4X3列表： ... ... ... &gt;&gt;&gt; [[row[i] for row in matrix] for i in range(4)] [[1, 5, 9], [2, 6, 10], [3, 7, 11], [4, 8, 12]] 这个List Comprehension相当于一个嵌套循环，外层循环变量是i，内层循环变量是row。把列表的外层循环改为普通for循环的话，等价于： temp_list = [] for i in range(4): temp_list.append([row[i] for row in matrix]) 把列表的两层循环都改为普通for循环写法，大致相当于： temp_list = [] for i in range(4): temp_list.append([]) for row in matrix: temp_list[-1].append(row[i]) 或者 transposed = [] for i in range(4): # the following 3 lines implement the nested listcomp transposed_row = [] for row in matrix: transposed_row.append(row[i]) transposed.append(transposed_row) print(transposed)]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[python3循环结构]]></title>
      <url>%2F2017%2F03%2F30%2Fpython%E5%BE%AA%E7%8E%AF%E7%BB%93%E6%9E%84%2F</url>
      <content type="text"><![CDATA[if语句Python中if语句的一般形式如下所示，Python 中用 elif 代替了 else if，所以if语句的关键字为：if – elif – else。 if condition_1: statement_block_1 elif condition_2: statement_block_2 else: statement_block_3 每个条件后面要使用冒号（:），表示接下来是满足条件后要执行的语句块。 使用缩进来划分语句块，相同缩进数的语句在一起组成一个语句块。 在Python中没有switch – case语句。 操作运算符&lt; 小于 &lt;= 小于或等于 &gt; 大于 &gt;= 大于或等于 == 等于，比较对象是否相等 != 不等于 if 嵌套在嵌套 if 语句中，可以把 if…elif…else 结构放在另外一个 if…elif…else 结构中。 if 表达式1: 语句 if 表达式2: 语句 elif 表达式3: 语句 else: 语句 elif 表达式4: 语句 else: 语句 实例print(&quot;====欢迎进入狗狗年龄对比系统====&quot;) while True: try: age=int(input(&quot;请输入您家狗狗的年龄&quot;)) print(&quot;&quot;) age=float(age) if(age&lt;0): print(&quot;are you kidding me?&quot;) elif age ==1: print(&quot;相当于人类14岁&quot;) break elif age==2: print(&quot;相当于人类22岁&quot;) break else : human=22+(age-2)*5 print(&quot;相当于人类：&quot;,human) break except ValueError: print(&quot;输入不合法，请重新输入有效年龄&quot;) ##退出提示 input(&quot;click enter 退出&quot;) 输出结果： ====欢迎进入狗狗年龄对比系统==== 请输入您家狗狗的年龄2 相当于人类22岁 click enter 退出 while 循环Python中while语句的一般形式，需要注意冒号和缩进。在Python中没有do..while循环。 while 判断条件： 语句 如果while循环体中只有一条语句，可以将该语句与while写在同一行中： while 循环使用 else 语句while … else 在条件语句为 false 时执行 else 的语句块： count = 0 while count &lt; 5: print (count, &quot; 小于 5&quot;) count = count + 1 else: print (count, &quot; 大于或等于 5&quot;) for 语句for循环可以遍历任何序列的项目，如一个列表或者一个字符串。 for &lt;variable&gt; in &lt;sequence&gt;: &lt;statements&gt; else: &lt;statements&gt; range()函数如果需要遍历数字序列，可以使用内置range()函数。它会生成数列 for i in range(5): #从5开始至8 for i in range(5,9): #range以指定数字开始并指定不同的增量(步长): for i in range(0, 10, 3): 结合range()和len()函数以遍历一个序列的索引： a = [&apos;Google&apos;, &apos;Baidu&apos;, &apos;Runoob&apos;, &apos;Taobao&apos;, &apos;QQ&apos;] for i in range(len(a)): print(i, a[i]) 结果： 0 Google 1 Baidu 2 Runoob 3 Taobao break和continue语句及循环中的else子句break 语句跳出当前循环体 sites = [&quot;Baidu&quot;, &quot;Google&quot;,&quot;Runoob&quot;,&quot;Taobao&quot;] for site in sites: if site == &quot;Runoob&quot;: print(&quot;Runoob&quot;) break print(&quot;循环数据 &quot; + site) else: print(&quot;没有循环数据!&quot;) print(&quot;完成循环!&quot;) 结果: 循环数据 Baidu 循环数据 Google Runoob! 完成循环! 循环语句可以有 else 子句，它在穷尽列表(以for循环)或条件变为 false (以while循环)导致循环终止时被执行,但循环被break终止时不执行。查询质数的循环例子: for n in range(2, 10): for x in range(2, n): if n % x == 0: print(n, &apos;等于&apos;, x, &apos;*&apos;, n//x) break else: # 循环中没有找到元素 print(n, &apos; 是质数&apos;) 结果： 2 是质数 3 是质数 4 等于 2 * 2 5 是质数 6 等于 2 * 3 7 是质数 8 等于 2 * 4 9 等于 3 * 3 continue语句用来告诉Python跳过当前循环块中的剩余语句，继续进行下一轮循环 for letter in &apos;Runoob&apos;: # 第一个实例 if letter == &apos;o&apos;: # 字母为 o 时跳过输出 continue print (&apos;当前字母 :&apos;, letter) 结果： 当前字母 : R 当前字母 : u 当前字母 : n 当前字母 : b pass 语句Python pass是空语句，是为了保持程序结构的完整性。pass 不做任何事情，一般用做占位语句 实例enumerate 函数遍历:对于一个可迭代的（iterable）/可遍历的对象（如列表、字符串），enumerate将其组成一个索引序列，利用它可以同时获得索引和值 sequence = [12, 34, 34, 23, 45, 76, 89] for i, j in enumerate(sequence): print(i, j) 结果： 0 12 1 34 2 34 3 23 4 45 5 76 6 89 循环嵌套来实现99乘法法则while循环： i=1 while 1&lt;10: j=1 while j&lt;=i: mut=j*i print(&quot;%d*%d=%d&quot;%(j,i,mut), end=&quot;&quot;) j+=1 print() i+=1 for循环： for i in range(1,10): for j in range(1,i+1): mut=j*i print(&quot;%d*%d=%d&quot;%(j,i,mut), end=&quot; &quot;) print(&quot;&quot;)]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[python3搭建微信公众平台（1）]]></title>
      <url>%2F2017%2F03%2F30%2Fpython%E5%BC%80%E5%8F%91%E5%BE%AE%E4%BF%A1%E5%85%AC%E4%BC%97%E5%B9%B3%E5%8F%B0%2F</url>
      <content type="text"><![CDATA[环境配置新浪SAE环境配置新浪SAE搭建python应用,按要求填写二级域名即可。选择代码管理工具（我选的SVN）,创建版本后会显示出版本的链接：数字1代表默认版本1，chamo代表填写的web应用名 http://1.chamo.applinzi.com点击“编辑代码”,可以看到默认的代码文件index.wsgi和config.yaml。为了能够让微信后台验证我们的服务器地址，做出如下修改： config.yaml文件： name: chamo version: 1 libraries: - name: webpy version: &quot;0.36&quot; - name: lxml version: &quot;2.3.4&quot; index.wsgi文件： # coding: UTF-8 import os import sae import web from weixinInterface import WeixinInterface //服务器地址设在了http://1.xxxx.applinzi.com/weixin（也就是微信后台所需要提供的服务器地址） urls = ( &apos;/weixin&apos;,&apos;WeixinInterface&apos; ) app_root = os.path.dirname(__file__) templates_root = os.path.join(app_root, &apos;templates&apos;) render = web.template.render(templates_root) app = web.application(urls, globals()).wsgifunc() application = sae.create_wsgi_app(app) 创建weixinInterface.py文件: # -*- coding: utf-8 -*- import hashlib import web import lxml import time import os import urllib2,json from lxml import etree class WeixinInterface: def __init__(self): self.app_root = os.path.dirname(__file__) self.templates_root = os.path.join(self.app_root, &apos;templates&apos;) self.render = web.template.render(self.templates_root) def GET(self): #获取输入参数 data = web.input() signature=data.signature timestamp=data.timestamp nonce=data.nonce echostr=data.echostr #自己的token token=&quot;weixin&quot; #微信公众平台里输入的token #字典序排序 list=[token,timestamp,nonce] list.sort() sha1=hashlib.sha1() map(sha1.update,list) hashcode=sha1.hexdigest() #sha1加密算法 #如果是来自微信的请求，则回复echostr if hashcode == signature: return echostr 注意： 跟目录下创建空文件夹templates，之后文件夹中将会放上.xml文件方便调用不同的后台回复方式。 上述三个文件放在同一级目录下，即根目录下。 微信公众平台配置在基本配置-服务器配置中： URL：http://1.chamo.applinzi.com/weixin token:weixin EncodingAESKey:随机生成 如果一直显示Token验证失败，直接到应用网址http://1.xxxx.applinzi.com判断代码错误位置 简单回复微信消息机制中详细介绍了如何实现公众号的消息回复，消息交互类型分为文本、图片、语音、视频、小视频、地理位置、链接等。用户消息以 XML 形式传至搭建好的服务器中，我们需要解析 XML 信息，获取出需要的信息，进行处理后对用户回复结果。 文本格式： &lt;xml&gt; &lt;ToUserName&gt;&lt;![CDATA[toUser]]&gt;&lt;/ToUserName&gt; &lt;FromUserName&gt;&lt;![CDATA[fromUser]]&gt;&lt;/FromUserName&gt; &lt;CreateTime&gt;1348831860&lt;/CreateTime&gt; &lt;MsgType&gt;&lt;![CDATA[text]]&gt;&lt;/MsgType&gt; &lt;Content&gt;&lt;![CDATA[this is a test]]&gt;&lt;/Content&gt; &lt;MsgId&gt;1234567890123456&lt;/MsgId&gt; &lt;/xml&gt; 图片格式： &lt;xml&gt; &lt;ToUserName&gt;&lt;![CDATA[toUser]]&gt;&lt;/ToUserName&gt; &lt;FromUserName&gt;&lt;![CDATA[fromUser]]&gt;&lt;/FromUserName&gt; &lt;CreateTime&gt;1348831860&lt;/CreateTime&gt; &lt;MsgType&gt;&lt;![CDATA[image]]&gt;&lt;/MsgType&gt; &lt;PicUrl&gt;&lt;![CDATA[this is a url]]&gt;&lt;/PicUrl&gt; &lt;MediaId&gt;&lt;![CDATA[media_id]]&gt;&lt;/MediaId&gt; &lt;MsgId&gt;1234567890123456&lt;/MsgId&gt; &lt;/xml&gt; 两者共有的字段为ToUserName、FromUserName、CreateTime、MsgType和MsgId，对于文本消息，可以通过Content字段直接提取出消息文本内容，但是对于图片消息，我们需要通过PicUrl或MediaId获取图片信息后进行处理。 简单回复功能的实现：发送什么回复什么 在目录下新建 templates/reply_text.xml $def with (toUser,fromUser,createTime,content) &lt;xml&gt; &lt;ToUserName&gt;&lt;![CDATA[$toUser]]&gt;&lt;/ToUserName&gt; &lt;FromUserName&gt;&lt;![CDATA[$fromUser]]&gt;&lt;/FromUserName&gt; &lt;CreateTime&gt;$createTime&lt;/CreateTime&gt; &lt;MsgType&gt;&lt;![CDATA[text]]&gt;&lt;/MsgType&gt; &lt;Content&gt;&lt;![CDATA[$content]]&gt;&lt;/Content&gt; &lt;/xml&gt; 2.编辑weixinInterface.py，增加POST方法 def POST(self): str_xml = web.data() #获得post来的数据 xml = etree.fromstring(str_xml)#进行XML解析 msgType=xml.find(&quot;MsgType&quot;).text fromUser=xml.find(&quot;FromUserName&quot;).text toUser=xml.find(&quot;ToUserName&quot;).text if msgType == &apos;text&apos;: content=xml.find(&quot;Content&quot;).text return self.render.reply_text(fromUser,toUser,int(time.time()), content) else: return &quot;success&quot; 3.注意事项 reply_text.xml中的toUSer和fromUser与return self.render.reply_text(fromUser,toUser,int(time.time()), content)中刚好相反 微信开发入门指引中提到回复success问题，假如服务器无法保证在五秒内处理回复，则必须回复“success”或者“”（空串），否则微信后台会发起三次重试。发起重试是微信后台为了尽可以保证粉丝发送的内容开发者均可以收到。如果开发者不进行回复，微信后台没办法确认开发者已收到消息，只好重试。三次重试后，依旧没有及时回复任何内容，系统自动在粉丝会话界面出现错误提示“该公众号暂时无法提供服务，请稍后再试”。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[PyQt5入门学习]]></title>
      <url>%2F2017%2F03%2F30%2FPyQt5%E5%85%A5%E9%97%A8%E5%AD%A6%E4%B9%A0%2F</url>
      <content type="text"><![CDATA[PyQt5简介PyQt5以一套Python模块的形式来实现功能，是一个多平台的工具套件，可以运行在所有的主流操作系统中，包含了超过620个类，600个方法和函数。QtCore 模块包含了非GUI的功能设计。这个模块被用来实现时间，文件和目录，不同数据类型，流，URL，mime类型，线程和进程。PyQt5的类被划分在一下模块中： QtGui 模块包含的类用于窗口化的系统结构，事件处理，2D绘图，基本图形，字体和文本。 QtWidgets 模块包含的类提供了一套UI元素来创建经典桌面风格用户界面。 QtMultimedia 模块包含的类用于处理多媒体内容和链接摄像头和无线电功能的API。 QtBluetooth 模块包含的类用于扫描蓝牙设备，并且和他们建立连接互动。 QtNetwork 模块包含的类用于网络编程，使TCP/IP和UDP客户端/服务端编程更加容易和轻便。 QtPositioning 模块包含的类用于多种可获得资源的位置限定，包含卫星定位，Wi-Fi，或一个文本文件。Enginio 模块用于解决客户端访问Qt云服务托管。 QtWebSockets 模块包含的类用于解决WebSocket通信协议。 QtWebKit 包含的关于浏览器的类用于解决基于WebKit2的支持库。 QtWebKitWidgets 模块包含的关于WebKit1的类基本解决浏览器使用基于QtWidgets应用问题。 QtXml 模块包含的类用于解析XML文件，提供SAX和DOM API解决方法。 QtSvg 模块提供类用于显示SVG文件内容。Scalable Vector Graphics (SVG) 是一种语言，用XML来描述二维图形和图形应用程序。 QtSql模块提供类驱动数据库工作。 QtTest 模块包含了方法提供PyQt5应用的单元测试。 PyQt5安装windows安装python3.6和pip安装完成后，可在cmd下通过命令自动下载PyQt5,这样会自动匹配需要安装的pyqt5版本和slip。官网上有说名，安装pyqt5前要安装slip,(命令安装时会自动安装slip)否则会提示DLL:找不到模块。 pip3 install PyQt5 第一个程序import sys from PyQt5.QtWidgets import QApplication, QWidget if __name__ == &apos;__main__&apos;: #PyQt5应用必须创建一个应用（Application）对象。 #sys.argv参数是一个来自命令行的参数列表。 #Python脚本可以在shell中运行,控制应用启动 app = QApplication(sys.argv) #Qwidget组件是用户界面类的基础类。默认构造方法没有父类将被作为窗口使用。 w = QWidget() #resize()方法调整widget组件的大小,250px宽，150px高 w.resize(250, 150) #move()方法移动widget组件到一个位置，屏幕上x=300,y=300的坐标。 w.move(300, 300) #设置窗口的标题 w.setWindowTitle(&apos;Simple&apos;) #show()方法在屏幕上显示出widget。 w.show() #应用进入主循环。事件处理开始执行。主循环用于接收来自窗口触发的事件，并且转发他们到widget应用上处理。 #如果我们调用exit()方法或主widget组件被销毁，主循环将退出。 #sys.exit()方法确保一个不留垃圾的退出。 #exec_()方法有一个下划线。因为exec是Python保留关键字,用exec_()来代替。 sys.exit(app.exec_()) #GUI编程 # 标题栏应用图标import sys from PyQt5.QtWidgets import QApplication, QWidget from PyQt5.QtGui import QIcon class Example(QWidget): def __init__(self): #super()方法返回了Example类的父类对象并且调用了父类的构造方法 super().__init__() self.initUI() def initUI(self): #将窗口在屏幕上显示，并设置它的尺寸 #前两个参数定位窗口的x轴和y轴位置。第三个参数是定义窗口的宽度，第四个参数是定义窗口的高度 self.setGeometry(300, 300, 300, 220) self.setWindowTitle(&apos;Icon&apos;) #QIcon对象接收一个显示的图片路径作为参数。 self.setWindowIcon(QIcon(&apos;web.png&apos;)) self.show() if __name__ == &apos;__main__&apos;: app = QApplication(sys.argv) #exampel对象 ex=Example() sys.exit(app.exec_()) 显示提示文本import sys from PyQt5.QtWidgets import (QWidget, QToolTip, QPushButton, QApplication) from PyQt5.QtGui import QFont class Example(QWidget): def __init__(self): super().__init__() self.initUI() def initUI(self): #设置了用于提示框的字体,使用10px大小的SansSerif字体 QToolTip.setFont(QFont(&apos;SansSerif&apos;, 10)) #显示了提示框。 self.setToolTip(&apos;This is a &lt;b&gt;QWidget&lt;/b&gt; widget&apos;) #创建一个按钮组件 btn = QPushButton(&apos;Button&apos;, self) #调用了setTooltip(),在提示框中使用富文本格式 btn.setToolTip(&apos;This is a &lt;b&gt;QPushButton&lt;/b&gt; widget&apos;) #setHint()按钮一个推荐的大小。 btn.resize(btn.sizeHint()) btn.move(50, 50) self.setGeometry(300, 300, 300, 200) self.setWindowTitle(&apos;Tooltips&apos;) self.show() if __name__ == &apos;__main__&apos;: app = QApplication(sys.argv) ex = Example() sys.exit(app.exec_()) 关闭窗口import sys from PyQt5.QtWidgets import QWidget, QPushButton, QApplication from PyQt5.QtCore import QCoreApplication class Example(QWidget): def __init__(self): super().__init__() self.initUI() def initUI(self): #显示在button上的标签文本,第二个参数是父组件。父组件是Example组件，它继承了QWiget类 qbtn = QPushButton(&apos;Quit&apos;, self) #点击按钮，信号clicked被发送 #QCoreApplication类包含了主事件循环；instance()方法给我们返回一个实例化对象。注意QCoreAppli类由QApplication创建。点击信号连接到quit()方法，将结束应用处理和转发所有事件 #instance()方法给我们返回一个实例化对象。 #QCoreAppli类由QApplication创建。点击信号连接到quit()方法，将结束应用 #事件通信在两个对象之间进行：发送者和接受者。发送者是按钮，接受者是应用对象。 qbtn.clicked.connect(QCoreApplication.instance().quit) qbtn.resize(qbtn.sizeHint()) qbtn.move(50, 50) self.setGeometry(300, 300, 250, 150) self.setWindowTitle(&apos;Quit button&apos;) self.show() if __name__ == &apos;__main__&apos;: app = QApplication(sys.argv) ex = Example() sys.exit(app.exec_()) 弹出框import sys from PyQt5.QtWidgets import QWidget, QMessageBox, QApplication class Example(QWidget): def __init__(self): super().__init__() self.initUI() def initUI(self): self.setGeometry(300, 300, 250, 150) self.setWindowTitle(&apos;Message box&apos;) self.show() #如果关闭QWidget，QCloseEvent类事件将被生成。 def closeEvent(self, event): #返回值被储存在reply变量中。 reply = QMessageBox.question(self, &apos;Message&apos;, &quot;Are you sure to quit?&quot;, QMessageBox.Yes | QMessageBox.No, QMessageBox.No) if reply == QMessageBox.Yes: event.accept() else: event.ignore() if __name__ == &apos;__main__&apos;: app = QApplication(sys.argv) ex = Example() sys.exit(app.exec_()) 居中窗口import sys from PyQt5.QtWidgets import QWidget, QDesktopWidget, QApplication class Example(QWidget): def __init__(self): super().__init__() self.initUI() def initUI(self): self.resize(250, 150) #窗口居中 self.center() self.setWindowTitle(&apos;Center&apos;) self.show() def center(self): #获得主窗口的一个矩形特定几何图形。包含了窗口的框架。 qr = self.frameGeometry() #算出相对于显示器的绝对值。并且从这个绝对值中，获得了屏幕中心点。 cp = QDesktopWidget().availableGeometry().center() #把矩形的中心设置到屏幕的中间去 qr.moveCenter(cp) #移动应用窗口的左上方的点到qr矩形的左上方的点，因此居中显示在我们的屏幕上 self.move(qr.topLeft()) if __name__ == &apos;__main__&apos;: app = QApplication(sys.argv) ex = Example() sys.exit(app.exec_())]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[python3-IO编程]]></title>
      <url>%2F2017%2F03%2F30%2Fpython%20IO%E7%BC%96%E7%A8%8B%2F</url>
      <content type="text"><![CDATA[文件读写读写文件是最常见的IO操作。Python内置了读写文件的函数，用法和C是兼容的。 读写文件就是请求操作系统打开一个文件对象（文件描述符），通过操作系统提供的接口从这个文件对象中读取数据（读文件），或者把数据写入这个文件对象（写文件）。 读文件以读文件的模式打开一个文件对象，使用Python内置的open()函数，传入文件名和标示符： &gt;&gt;&gt; f = open(&apos;F:\python learning\wen.txt&apos;, &apos;r&apos;) 如果文件打开成功，接下来，调用read()方法可以一次读取文件的全部内容，Python把内容读到内存 &gt;&gt;&gt; f.read() &apos;111 &apos; 调用close()方法关闭文件。文件使用完毕后必须关闭，因为文件对象会占用操作系统的资源，并且操作系统同一时间能打开的文件数量也是有限的： &gt;&gt;&gt; f.close() 由于文件读写时都有可能产生IOError，一旦出错，后面的f.close()就不会调用。为了保证无论是否出错都能正确地关闭文件，可以使用try … finally来实现： try: f = open(&apos;/path/to/file&apos;, &apos;r&apos;) print(f.read()) finally: if f: f.close() Python引入了with语句来自动调用close()方法： with open(&apos;F:\python learning\wen.txt&apos;, &apos;r&apos;) as f: print(f.read()) 调用read(size)方法，每次最多读取size个字节的内容。调用readline()可以每次读取一行内容，调用readlines()一次读取所有内容并按行返回list 如果文件很小，read()一次性读取最方便；如果不能确定文件大小，反复调用read(size)比较保险；如果是配置文件，调用readlines()最方便 要读取二进制文件，比如图片、视频等等，用’rb’模式打开文件即可： f = open(&apos;F:\python learning\wen.jpg&apos;, &apos;r&apos;), &apos;rb&apos;) f.read() 读取非UTF-8编码的文本文件，需要给open()函数传入encoding参数，例如，读取GBK编码的文件： f = open(‘F:\python learning\gbk.txt’, ‘r’,encoding=’gbk’) f.read() ###read() readline()以及readlines()区别 ###创建python.txt文件，内容为： hello world python3 first python read() 每次读取整个文件，通常将读取到底文件内容放到一个字符串变量中，即read() 生成文件内容是一个字符串类型 f=open(&apos;F:\python learning\pytest.txt&apos;,&apos;r+&apos;) print(f.read()) 结果： hello world python3 first python readline()每只读取文件的一行，通常也是读取到的一行内容放到一个字符串变量中，返回str类型 f=open(&apos;F:\python learning\pytest.txt&apos;,&apos;r+&apos;) for i in f.readline(): print(i,end=&apos;&apos;) 结果： hello world readlines()每次按行读取整个文件内容，将读取到的内容放到一个列表中，返回list类型 f=open(&apos;F:\python learning\pytest.txt&apos;,&apos;r+&apos;) print(f.readlines()) 结果： [&apos;hello world\n&apos;, &apos;python3\n&apos;, &apos;first python&apos;] 写文件写文件和读文件是一样的，唯一区别是调用open()函数时，传入标识符’w’或者’wb’表示写文本文件或写二进制文件：可以反复调用write()来写入文件，但务必要调用f.close()来关闭文件。当写文件时，操作系统往往不会立刻把数据写入磁盘，而是放到内存缓存起来，空闲的时候慢慢写入。只有调用close()方法时，操作系统才保证把没有写入的数据全部写入磁盘。用with语句保险： with open(&apos;F:\python learning\wen.txt&apos;, &apos;r&apos;) as f: f.write(&apos;Hello, world!&apos;) ###write()与write()区别###write()需要传入一个字符串做为参数，输出后光标在行末不会换行，下次接着这行写 f=open(&apos;F:\python learning\pytest.txt&apos;,&apos;a+&apos;) f.write(&quot;second python&quot;) f=open(&apos;F:\python learning\pytest.txt&apos;,&apos;r+&apos;) print(f.readlines()) 结果： [&apos;hello world\n&apos;, &apos;python3\n&apos;, &apos;first pythonsecond python&apos;] writeline()需要传入一个字符串做为参数，换行需要手动添加换行符 ##读写模式##（1）r模式：该模式打开的文件必须存在，如果不存在，将会出错；并且，该模式打开的文件，只能读，不能向文件中写入。（只读）（2）r+模式：该模式打开的文件必须存在，如果不存在，将会出错；并且，该模式打开的文件，可以向文件中写入。（3）w模式：该模式打开的文件如果已经存在，则先清空，否则新建一个文件，然后只能写入数据，不能读取。（4）w+模式该模式打开的文件如果已经存在，则先清空，否则新建一个文件，然后可以写入数据，也可以读取。（5）a模式该模式打开的文件如果已经存在，不会清空，否则新建一个文件，写入的内容追加到文件尾；不能读取数据。（以追加的方式写入）（6）a+模式该模式打开的文件如果已经存在，不会清空，否则新建一个文件，写入的内容追加到文件尾；也可以读取数据。 （各模式中如果添加b，如‘rb’则可以读取二进制文件。） ##文件位置## tell 作用：获取当前文件读取指针的位置 file.tell()没有参数seek 作用：用于移动文件读写指针到指定的位置 语法格式：file.seek(offset, whence=0):–&gt; offset: 偏移量，需要向前或者是向后移动的字节数–&gt; whence: 可选值，默认为0, 可选值为1或者2，表示从何处开始计算偏移–&gt; 0表示从当前位置开始计算偏移–&gt; 1表示从文件头位置开始计算偏移–&gt; 2表示从文件尾开始计算偏移 f=open(&apos;F:\python learning\pytest.txt&apos;,&apos;r+&apos;) print(f.tell()) f.seek(3) print(f.tell()) 结果: 0 3 #使用想对位置来判断读写指针时需要将模式中加b,否则会报错 f=open(&apos;F:\python learning\pytest.txt&apos;,&apos;rb+&apos;) print(f.tell()) f.seek(5,1) print(f.tell()) 结果: 0 5 f=open(&apos;F:\python learning\pytest.txt&apos;,&apos;rb+&apos;) print(f.tell()) f.seek(0,2) print(f.tell()) f.seek(5,2) print(f.tell()) 结果： 0 24 29 常用方法file.close()：关闭文件。关闭后文件不能再进行读写操作。 file.flush()：刷新文件内部缓冲，直接把内部缓冲区的数据立刻写入文件, 而不是被动的等待输出缓冲区写入。 file.fileno()：返回一个整型的文件描述符(file descriptor FD 整型), 可以用在如os模块的read方法等一些底层操作上。 file.isatty()：如果文件连接到一个终端设备返回 True，否则返回 False。 file.next()：返回文件下一行。 file.read([size])：从文件读取指定的字节数，如果未给定或为负则读取所有。 file.readline([size])：读取整行，包括 “\n” 字符。 file.readlines([sizeint])：读取所有行并返回列表，若给定sizeint&gt;0，返回总和大约为sizeint字节的行, 实际读取值可能比 sizeint 较大, 因为需要填充缓冲区。 file.seek(offset[, whence])：设置文件当前位置 file.tell()：返回文件当前位置。 file.truncate([size])：从文件的首行首字符开始截断，截断文件为 size 个字符，无 size 表示从当前位置截断；截断之后 V 后面的所有字符被删除，其中 Widnows 系统下的换行代表2个字符大小。 file.write(str)：将字符串写入文件，没有返回值。 file.writelines(sequence)：向文件写入一个序列字符串列表，如果需要换行则要自己加入每行的换行符。 StringIO数据读写不一定是文件，也可以在内存中读写。StringIO顾名思义就是在内存中读写str。要把str写入StringIO，我们需要先创建一个StringIO，然后，像文件一样写入即可： &gt;&gt;&gt; from io import StringIO &gt;&gt;&gt; f=StringIO() &gt;&gt;&gt; f.write(&quot;hello&quot;) 5 &gt;&gt;&gt; f.write(&apos;&apos;) 0 &gt;&gt;&gt; f.write(&quot;world&quot;) 5 #getvalue()方法用于获得写入后的str。 &gt;&gt;&gt; print(f.getvalue()) helloworld &gt;&gt;&gt; 读取StringIO，可以用一个str初始化StringIO，然后，像读文件一样读取： &gt;&gt;&gt; from io import StringIO &gt;&gt;&gt; f = StringIO(&apos;Hello!\nHi!\nGoodbye!&apos;) &gt;&gt;&gt; while True: ... s = f.readline() ... if s == &apos;&apos;: ... break ... print(s.strip()) ... Hello! Hi! Goodbye! BytesIOStringIO操作的只能是str，如果要操作二进制数据，就需要使用BytesIO。BytesIO实现了在内存中读写bytes，创建一个BytesIO，然后写入一些bytes: &gt;&gt;&gt; from io import BytesIO &gt;&gt;&gt; f = BytesIO() &gt;&gt;&gt; f.write(&apos;中文&apos;.encode(&apos;utf-8&apos;)) 6 &gt;&gt;&gt; print(f.getvalue()) b&apos;\xe4\xb8\xad\xe6\x96\x87&apos; 和StringIO类似，可以用一个bytes初始化BytesIO，然后，像读文件一样读取： &gt;&gt;&gt; from io import BytesIO &gt;&gt;&gt; f = BytesIO(b&apos;\xe4\xb8\xad\xe6\x96\x87&apos;) &gt;&gt;&gt; f.read() b&apos;\xe4\xb8\xad\xe6\x96\x87&apos; 操作文件和目录Python内置的os模块调用操作系统提供的接口函数。 &gt;&gt;&gt; import os &gt;&gt;&gt; os.name &apos;nt&apos; 如果是posix，系统是Linux、Unix或Mac OS X，如果是nt，就是Windows系统。 在操作系统中定义的环境变量，全部保存在os.environ这个变量中.要获取某个环境变量的值，可以调用os.environ.get(‘key’) 操作文件和目录的函数一部分放在os模块中，一部分放在os.path模块中.把两个路径合成一个时，不要直接拼字符串，而要通过os.path.join()函数，这样可以正确处理不同操作系统的路径分隔符;拆分路径时，也不要直接去拆字符串，而要通过os.path.split()函数，这样可以把一个路径拆分为两部分，后一部分总是最后级别的目录或文件名： # 查看当前目录的绝对路径: &gt;&gt;&gt; os.path.abspath(&apos;.&apos;) &apos;/Users/michael&apos; # 在某个目录下创建一个新目录，首先把新目录的完整路径表示出来: &gt;&gt;&gt; os.path.join(&apos;/Users/michael&apos;, &apos;testdir&apos;) &apos;/Users/michael/testdir&apos; # 然后创建一个目录: &gt;&gt;&gt; os.mkdir(&apos;/Users/michael/testdir&apos;) # 删掉一个目录: &gt;&gt;&gt; os.rmdir(&apos;/Users/michael/testdir&apos;)]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[python3基础了解]]></title>
      <url>%2F2017%2F03%2F30%2FPython%E5%9F%BA%E7%A1%80%2F</url>
      <content type="text"><![CDATA[python基础语法编码默认情况下，Python 3 源码文件以 UTF-8 编码，所有字符串都是 unicode 字符串。 也可以为源码文件指定不同的编码： # -*- coding: cp-1252 -*- 标识符 第一个字符必须是字母表中字母或下划线’_’。 标识符的其他的部分有字母、数字和下划线组成。 标识符对大小写敏感。 关键字不能把它们用作任何标识符名称。Python 的标准库提供了一个 keyword 模块，可以输出当前版本的所有关键字： &gt;&gt;&gt; import keyword &gt;&gt;&gt; keyword.kwlist [&apos;False&apos;, &apos;None&apos;, &apos;True&apos;, &apos;and&apos;, &apos;as&apos;, &apos;assert&apos;, &apos;break&apos;, &apos;class&apos;, &apos;continue&apos;, &apos;def&apos;, &apos;del&apos;, &apos;elif&apos;, &apos;else&apos;, &apos;except&apos;, &apos;finally&apos;, &apos;for&apos;, &apos;from&apos;, &apos;global&apos;, &apos;if&apos;, &apos;import&apos;, &apos;in&apos;, &apos;is&apos;, &apos;lambda&apos;, &apos;nonlocal&apos;, &apos;not&apos;, &apos;or&apos;, &apos;pass&apos;, &apos;raise&apos;, &apos;return&apos;, &apos;try&apos;, &apos;while&apos;, &apos;with&apos;, &apos;yield&apos;] 注释 单行注释以 # 开头 多行注释用三引号’’’ ‘’’包含： &apos;&apos;&apos; first python &apos;&apos;&apos; python中文注释方法如果开头不声明保存编码的格式那么它会默认使用ASKII码保存文件，这时如果你的代码中有中文就会出错了，即使你的中文是包含在注释里面的 #coding=utf-8 或者 #coding=gbk 行与缩进python使用缩进来表示代码块，不需要使用大括号({})。缩进的空格数是可变的，但是同一个代码块的语句必须包含相同的缩进空格数。缩进不一致，执行后会出现类似以下错误： IndentationError: unindent does not match any outer indentation level 多行语句Python 通常是一行写完一条语句，但如果语句很长，可以使用反斜杠()来实现多行语句，在 [], {}, 或 () 中的多行语句，不需要使用反斜杠()： total = [&apos;item_one&apos;, &apos;item_two&apos;, &apos;item_three&apos;, &apos;item_four&apos;, &apos;item_five&apos;] 空行函数之间或类的方法之间用空行分隔，表示一段新的代码的开始。类和函数入口之间也用一行空行分隔，以突出函数入口的开始。 空行与代码缩进不同，空行并不是Python语法的一部分。书写时不插入空行，Python解释器运行也不会出错。但是空行的作用在于分隔两段不同功能或含义的代码，便于日后代码的维护或重构。记住：空行也是程序代码的一部分。 用户输入input(&quot;\n\n按下 enter 键后退出。&quot;) “\n\n”在结果输出前会输出两个新的空行 Print 输出print 默认输出是换行的，如果要实现不换行需要在变量末尾加上 end=””： x=&quot;1&quot; y=&quot;2&quot; # 换行输出 print( x ) print( y ) # 不换行输出 print( x, end=&quot; &quot; ) print( y, end=&quot; &quot; ) import 与 from…import在 python 用 import 或者 from…import 来导入相应的模块。 将整个模块(somemodule)导入，格式为： import somemodule从某个模块中导入某个函数,格式为： from somemodule import somefunction从某个模块中导入多个函数,格式为： from somemodule import firstfunc, secondfunc, thirdfunc将某个模块中的全部函数导入，格式为： from somemodule import * help() 函数调用 python 的 help() 函数可以打印输出一个函数的文档字符串： help(max) 按下 : q 两个按键即退出说明文档]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[python3与JSON]]></title>
      <url>%2F2017%2F03%2F30%2Fpython%E4%B8%8EJSON%2F</url>
      <content type="text"><![CDATA[JSONJSON (JavaScript Object Notation) 是一种轻量级的数据交换格式,Python3 中可以使用 json 模块来对 JSON 数据进行编解码，它包含了两个函数： json.dumps(): 对数据进行编码。 json.loads(): 对数据进行解码。 Python 编码为 JSON 类型转换对应表： dict -objectlist, tuple -arraystr -stringint, float, int- &amp; float-derived Enums -numberTrue -trueFalse -falseNone -null JSON 解码为 Python 类型转换对应表： object -dictarray -liststring -strnumber (int) -intnumber (real) -floattrue -Truefalse -Falsenull -None Python转换为JSONimport json # Python 字典类型转换为 JSON 对象 data = { &apos;no&apos; : 1, &apos;name&apos; : &apos;Runoob&apos;, &apos;url&apos; : &apos;http://www.runoob.com&apos; } json_str = json.dumps(data) print (&quot;Python 原始数据：&quot;, repr(data)) print (&quot;JSON 对象：&quot;, json_str) JSON换回Pythonimport json # Python 字典类型转换为 JSON 对象 data1 = { &apos;no&apos; : 1, &apos;name&apos; : &apos;Runoob&apos;, &apos;url&apos; : &apos;http://www.runoob.com&apos; } json_str = json.dumps(data1) print (&quot;Python 原始数据：&quot;, repr(data1)) print (&quot;JSON 对象：&quot;, json_str) # 将 JSON 对象转换为 Python 字典 data2 = json.loads(json_str) print (&quot;data2[&apos;name&apos;]: &quot;, data2[&apos;name&apos;]) print (&quot;data2[&apos;url&apos;]: &quot;, data2[&apos;url&apos;])]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[python3关键要素]]></title>
      <url>%2F2017%2F03%2F30%2Fpython%E5%85%B3%E9%94%AE%E8%A6%81%E7%B4%A0%2F</url>
      <content type="text"><![CDATA[要素1：数据类型python提供了几种内置的数据类型，使用int表示整数，使用str表示字符串（Unicode字符序列）。python所能表示的整数大小只受限于机器内存，而非固定的字节数，字符串可以用双引号或单引号封装，只要字符串头尾的符号对称。空字符串只使用引号。python使用方括号[]来存取字符串等序列中的某一项,索引位置从0开始。如：“hard times”[5]结果：‘t’在python中str类型与基本数据类型都是固定的，一旦设定就不能改变（虽然可以使用方括号取回字符串中国某给定索引位置的字符，但不能设置为新字符。字符就是长度为1的字符串）如果要将一个数据项转从某种数据类型转换为另一种类型，使用语法： datatype（item） 如：int(“45”) 或int(“ 45 ”) str(312)int()转换允许头尾处带空格，str()几乎可以应用于所有数据类型。 要素2：对象引用python没有定义某种数据类型的变量，而是使用“对象引用” x=”blue” python创建一个str对象，内容为blue,同时创建了一个名为x的对象引用，x引用的就是这个str对象 y=”green” 如上 z=x 创建了一个名为z的新对象引用，并将其设置为对象引用x所指向的相同对象（包含文本“blue”的str对象）。在python中，操作符‘=’作用是将对象引用与内存中的某对象进行绑定，如果对象引用已经存在，就简单的机械重绑定，以便引用“=”操作符右边的对象，如果对象没有存在，就有“=”操作符创建对象引用 对象引用的名称不能与python关键字相同，并且必须以字母或下划线引导，其后可以跟0个或多个非空格字符，下划线或数字，长度没有限制，区分大小写。python使用动态类型机制，任何时刻，只要需要，某个对象都可以重新引用一个不同的对象（可以是不同的数据类型） 要素3：组合数据类型python提供了几种组合数据类型，包括关联数组与集合等类型。例如元祖和列表。python元祖与列表可以用于存储任意数量，任意类型的数据项。元祖是固定的，创建之后不能改变。列表上可变的，需要时可以插入或移除数据。 要素4：逻辑操作符pytho提供了四组逻辑运算身份操作符：is(二元操作符)左端对象引用与右端对象引用指向同一个对象，返回true比较操作符：&lt; &lt;= == != &gt;= &gt;成员操作符：in对序列或集合这类数据类型，比如字符串，列表或元祖，可使用in来测试成员关系，not in测试非成员关系（in对列表或元祖大的组合类型比较慢，对字典会集合可以非常快）逻辑运算符：and， or与 not，and与or返回决定结果的操作数而不是布尔值（除非实际上就是布尔操作数） five=5 two=2 five and two———2 要素5:控制流语句.py文件中每条语句都是顺序执行的，从第一条语句开始，逐行执行。函数，方法调用或控制结构都可以使控制流转向，比如条件分支或循环语句。有意外产生时，控制流也会被转向。 要素6：算数操作符python提供了完整的算数运算符集，包括基本四则数学运算的操作符（+-、/）和一些增强的赋值操作符（+=,=）python的除法与一般语言不同，除法操作符会产生一个浮点值，而不是一个整数值。其他程序语言都是产生一个整数值，并剥离小数部分。如果需要整数结果可以用int()转换。 要素7：输入输出python提供了内置的input()函数用于接受用户输入，print（）用于输出 要素8：函数的创建和调用函数创建语法格式： def functionName(arguments): suite 其中，arguments是可选的，如果有多个参数，逗号分隔。每个python函数有一个返回值，默认为None。执行def时，会创建一个函数对象，同时创建一个带有指定名的 对象引用。由于函数也是对象，因此可以存储在组合数据类型中，并作为参数传递给其他函数。python有大量的内置函数，标准库的大量模块中包含更多函数。python模块实际就是包含python代码的.py文件，要使用某个模块内的函数功能，必须先导入该模块]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[python3变量与数据类型]]></title>
      <url>%2F2017%2F03%2F30%2Fpython%E5%8F%98%E9%87%8F%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%2F</url>
      <content type="text"><![CDATA[变量Python 中的变量不需要声明。每个变量在使用前都必须赋值，变量赋值以后该变量才会被创建。变量就是变量，它没有类型，所说的”类型”是变量所指的内存中对象的类型。变量在计算机内存中的表示也非常重要。当我们写： a = &apos;ABC&apos; b = a a = &apos;XYZ&apos; print(b) Python解释器： 执行a = ‘ABC’，解释器创建了字符串’ABC’和变量a，并把a指向’ABC’： 执行b = a，解释器创建了变量b，并把b指向a指向的字符串’ABC’： 执行a = ‘XYZ’，解释器创建了字符串’XYZ’，并把a的指向改为’XYZ’，但b并没有更改： 最后打印变量b的结果自然是’ABC’ Number（数字）Python 数字数据类型用于存储数值。数据类型是不允许改变的,如果改变数字数据类型的值，将重新分配内存空间。 Python 支持三种不同的数值类型： 整型(Int) - 通常被称为是整型或整数，是正或负整数，不带小数点。Python3 整型是没有限制大小的，可以当作 Long 类型使用，所以 Python3 没有 Python2 的 Long 类型 浮点型(float) - 浮点型由整数部分与小数部分组成，浮点型也可以使用科学计数法表示（2.5e2 = 2.5 x 102 = 250） 复数( (complex)) - 复数由实数部分和虚数部分构成，可以用a + bj,或者complex(a,b)表示， 复数的实部a和虚部b都是浮点型。 Python 数字类型转换 int(x) 将x转换为一个整数。 float(x) 将x转换到一个浮点数。 complex(x) 将x转换到一个复数，实数部分为 x，虚数部分为 0。 complex(x, y) 将 x 和 y 转换到一个复数，实数部分为 x，虚数部分为 y。x 和 y 是数字表达式。 数学函数abs(x):返回数字的绝对值，如abs(-10) 返回 10 ceil(x):返回数字的上入整数，如math.ceil(4.1) 返回 5 cmp(x, y):如果 x &lt; y 返回 -1, 如果 x == y 返回 0, 如果 x &gt; y 返回 1。 Python 3 已废弃 。使用 使用 (x&gt;y)-(x&lt;y) 替换。 exp(x):返回e的x次幂(ex),如math.exp(1) 返回2.718281828459045 fabs(x):返回数字的绝对值，如math.fabs(-10) 返回10.0 floor(x):返回数字的下舍整数，如math.floor(4.9)返回 4 log(x):如math.log(math.e)返回1.0,math.log(100,10)返回2.0 log10(x):返回以10为基数的x的对数，如math.log10(100)返回 2.0 max(x1, x2,…) :返回给定参数的最大值，参数可以为序列。 min(x1, x2,…):返回给定参数的最小值，参数可以为序列。 modf(x) :返回x的整数部分与小数部分，两部分的数值符号与x相同，整数部分以浮点型表示。 pow(x, y):x**y 运算后的值。 round(x [,n]):返回浮点数x的四舍五入值，如给出n值，则代表舍入到小数点后的位数。 sqrt(x):返回数字x的平方根，数字可以为负数，返回类型为实数，如math.sqrt(4)返回 2+0j 随机数函数choice(seq):从序列的元素中随机挑选一个元素，比如random.choice(range(10))，从0到9中随机挑选一个整数。 randrange ([start,] stop [,step]):从指定范围内，按指定基数递增的集合中获取一个随机数，基数缺省值为1 random():随机生成下一个实数，它在[0,1)范围内。 seed([x]):改变随机数生成器的种子seed。如果你不了解其原理，你不必特别去设定seed，Python会帮你选择seed。 shuffle(lst):将序列的所有元素随机排序 uniform(x, y):随机生成下一个实数，它在[x,y]范围内。 三角函数acos(x) :返回x的反余弦弧度值。 asin(x) :返回x的反正弦弧度值。 atan(x) :返回x的反正切弧度值。 atan2(y, x) :返回给定的 X 及 Y 坐标值的反正切值。 cos(x) :返回x的弧度的余弦值。 hypot(x, y) :返回欧几里德范数 sqrt(xx + yy)。 sin(x) :返回的x弧度的正弦值。 tan(x) :返回x弧度的正切值。 degrees(x) :将弧度转换为角度,如degrees(math.pi/2) ， 返回90.0 radians(x) :将角度转换为弧度 字符串字符串是 Python 中最常用的数据类型，可以使用引号(‘或”)来创建字符串。 访问字符串中的值Python 访问子字符串，可以使用方括号来截取字符串 var1 = &apos;Hello World!&apos; var2 = &quot;Runoob&quot; print (&quot;var1[0]: &quot;, var1[0]) print (&quot;var2[1:5]: &quot;, var2[1:5]) 字符串更新对已存在的字符串进行修改，并赋值给另一个变量： var1 = &apos;Hello World!&apos; print (&quot;已更新字符串 : &quot;, var1[:6] + &apos;Runoob!&apos;) 结果：已更新字符串 : Hello Runoob! 转义字符\(在行尾时) 续行符 \\ 反斜杠符号 \&apos; 单引号 \&quot; 双引号 \a 响铃 \b 退格(Backspace) \e 转义 \000 空 \n 换行 \v 纵向制表符 \t 横向制表符 \r 回车 \f 换页 \oyy 八进制数，yy代表的字符，例如：\o12代表换行 \xyy 十六进制数，yy代表的字符，例如：\x0a代表换行 \other 其它的字符以普通格式输出 字符串运算符+ 字符串连接 * 重复输出字符串 [] 通过索引获取字符串中字符 [ : ] 截取字符串中的一部分 in 成员运算符 - 如果字符串中包含给定的字符返回 True H in a 输出结果 1 not in 成员运算符 - 如果字符串中不包含给定的字符返回 True M not in a 输出结果 1 r/R 原始字符串 - 原始字符串：所有的字符串都是直接按照字面的意思来使用，没有转义特殊或不能打 印的字符。 原始字符串除在字符串的第一个引号前加上字母&quot;r&quot;（可以大小写）以外，与普通字符串有着几乎完全相同的语法。 % 格式字符串 字符串格式化%c 格式化字符及其ASCII码 %s 格式化字符串 %d 格式化整数 %u 格式化无符号整型 %o 格式化无符号八进制数 %x 格式化无符号十六进制数 %X 格式化无符号十六进制数（大写） %f 格式化浮点数字，可指定小数点后的精度 %e 用科学计数法格式化浮点数 %E 作用同%e，用科学计数法格式化浮点数 %g %f和%e的简写 %G %f 和 %E 的简写 %p 用十六进制数格式化变量的地址 字符串内建函数capitalize()：将字符串的第一个字符转换为大写 center(width, fillchar)：返回一个指定的宽度 width 居中的字符串，fillchar 为填充的字符，默认为空格。 count(str, beg= 0,end=len(string))：返回 str 在 string 里面出现的次数，如果 beg 或者 end 指定则返回指定范围内 str 出现的次数 bytes.decode(encoding=”utf-8”, errors=”strict”)：Python3 中没有 decode 方法，但我们可以使用 bytes 对象的 decode() 方法来解码给定的 bytes 对象，这个 bytes 对象可以由 str.encode() 来编码返回。 encode(encoding=’UTF-8’,errors=’strict’)：以 encoding 指定的编码格式编码字符串，如果出错默认报一个ValueError 的异常，除非 errors 指定的是’ignore’或者’replace’ endswith(suffix, beg=0, end=len(string))：检查字符串是否以 obj 结束，如果beg 或者 end 指定则检查指定的范围内是否以 obj 结束，如果是，返回 True,否则返回 False. expandtabs(tabsize=8)：把字符串 string 中的 tab 符号转为空格，tab 符号默认的空格数是 8 。 find(str, beg=0 end=len(string))：检测 str 是否包含在字符串中 中，如果 beg 和 end 指定范围，则检查是否包含在指定范围内，如果是返回开始的索引值，否则返回-1 index(str, beg=0, end=len(string))：跟find()方法一样，只不过如果str不在字符串中会报一个异常. isalnum()：如果字符串至少有一个字符并且所有字符都是字母或数字则返 回 True,否则返回 False isalpha()：如果字符串至少有一个字符并且所有字符都是字母则返回 True, 否则返回 False isdigit()：如果字符串只包含数字则返回 True 否则返回 False.. islower()：如果字符串中包含至少一个区分大小写的字符，并且所有这些(区分大小写的)字符都是小写，则返回 True，否则返回 False isnumeric()：如果字符串中只包含数字字符，则返回 True，否则返回 False isspace()：如果字符串中只包含空格，则返回 True，否则返回 False. istitle():如果字符串是标题化的(见 title())则返回 True，否则返回 False isupper():如果字符串中包含至少一个区分大小写的字符，并且所有这些(区分大小写的)字符都是大写，则返回 True，否则返回 False join(seq):以指定字符串作为分隔符，将 seq 中所有的元素(的字符串表示)合并为一个新的字符串 len(string):返回字符串长度 ljust(width[, fillchar]):返回一个原字符串左对齐,并使用 fillchar 填充至长度 width 的新字符串，fillchar 默认为空格。 lower():转换字符串中所有大写字符为小写. lstrip():截掉字符串左边的空格 maketrans():创建字符映射的转换表，对于接受两个参数的最简单的调用方式，第一个参数是字符串，表示需要转换的字符，第二个参数也是字符串表示转换的目标。 max(str):返回字符串 str 中最大的字母。 min(str):返回字符串 str 中最小的字母。 replace(old, new [, max]):把 将字符串中的 str1 替换成 str2,如果 max 指定，则替换不超过 max 次。 rfind(str, beg=0,end=len(string)):类似于 find()函数，不过是从右边开始查找. rindex( str, beg=0, end=len(string)):类似于 index()，不过是从右边开始. rjust(width,[, fillchar]):返回一个原字符串右对齐,并使用fillchar(默认空格）填充至长度 width 的新字符串 rstrip():删除字符串字符串末尾的空格. split(str=””, num=string.count(str)):num=string.count(str)) 以 str 为分隔符截取字符串，如果 num 有指定值，则仅截取 num 个子字符串 splitlines([keepends]):按照行(‘\r’, ‘\r\n’, \n’)分隔，返回一个包含各行作为元素的列表，如果参数 keepends 为 False，不包含换行符，如果为 True，则保留换行符。 startswith(str, beg=0,end=len(string)):检查字符串是否是以 obj 开头，是则返回 True，否则返回 False。如果beg 和 end 指定值，则在指定范围内检查。 strip([chars]):在字符串上执行 lstrip()和 rstrip() swapcase():将字符串中大写转换为小写，小写转换为大写 title():返回”标题化”的字符串,就是说所有单词都是以大写开始，其余字母均为小写(见 istitle()) translate(table, deletechars=””):根据 str 给出的表(包含 256 个字符)转换 string 的字符, 要过滤掉的字符放到 deletechars 参数中 upper()”转换字符串中的小写字母为大写 zfill (width):返回长度为 width 的字符串，原字符串右对齐，前面填充0 isdecimal():检查字符串是否只包含十进制字符，如果是返回 true，否则返回 false。 列表序列是Python中最基本的数据结构。序列中的每个元素都分配一个数字 - 它的位置，或索引，第一个索引是0序列都可以进行的操作包括索引，切片，加，乘，检查成员。它可以作为一个方括号内的逗号分隔值出现。列表的数据项不需要具有相同的类型 创建列表创建一个列表，只要把逗号分隔的不同的数据项使用方括号括起来即可： list1=[&apos;Google&apos;,&apos;Runnoob&apos;,1997,20001]; list2=[1,2,3,4,5,6,7]; list3=[&quot;a&quot;,&quot;b&quot;,&quot;c&quot;,&quot;d&quot;]; 访问列表中的值使用下标索引来访问列表中的值，也可以使用方括号的形式截取字符： print (&quot;list1[0]: &quot;, list1[0]) print (&quot;list2[1:5]: &quot;, list2[1:5]) 列表遍历l[start:end:span] 遍历 [start,end)，间隔为 span，当 span&gt;0 时顺序遍历, 当 span&lt;0 时，逆着遍历。start 不输入则默认为 0，end 不输入默认为长度。 &gt;&gt;&gt; l = [i for i in range(0,15)] &gt;&gt;&gt; print(l[::2]) [0, 2, 4, 6, 8, 10, 12, 14] 更新列表对列表的数据项进行修改或更新，也可以使用append()方法来添加列表项: list =[&apos;google&apos;,&apos;runnoob&apos;,1997,2001] print(&quot;第三个元素为:&quot;,list[2]) list[2]=2001 print(&quot;更新后的第三个元素：&quot;,list[2]) 结果： 第三个元素为: 1997 更新后的第三个元素： 2001 删除列表元素可以使用 del 语句来删除列表的的元素： del list[2] 列表脚本操作符列表对 + 和 的操作符与字符串相似。+ 号用于组合列表， 号用于重复列表。 #长度 len([1,2,3]) 3 #组合 [1,2,3]+[4,5,6] [1, 2, 3, 4, 5, 6] #重复 [&apos;Hi!&apos;] *4 [&apos;Hi!&apos;, &apos;Hi!&apos;, &apos;Hi!&apos;, &apos;Hi!&apos;] 列表截取&gt;&gt;&gt; L=[&apos;Google&apos;, &apos;Runoob&apos;, &apos;Taobao&apos;] #读取第三个元素 &gt;&gt;&gt; L[2] &apos;Taobao&apos; #从右侧开始读取倒数第二个元素 &gt;&gt;&gt; L[-2] &apos;Runoob&apos; #输出从第二个元素开始后的所有元素 &gt;&gt;&gt; L[1:] [&apos;Runoob&apos;, &apos;Taobao&apos;] 嵌套列表使用嵌套列表即在列表里创建其它列表，嵌套后可看做多维数组 &gt;&gt;&gt; a=[&apos;a&apos;,&apos;b&apos;,&apos;c&apos;] &gt;&gt;&gt; n=[1,2,3] &gt;&gt;&gt; x=[a,n] &gt;&gt;&gt; x [[&apos;a&apos;, &apos;b&apos;, &apos;c&apos;], [1, 2, 3]] &gt;&gt;&gt; x[0] [&apos;a&apos;, &apos;b&apos;, &apos;c&apos;] &gt;&gt;&gt; x[0][1] &apos;b&apos; &gt;&gt;&gt; 创建二维列表，将需要的参数写入 cols 和 rows 即可： list_2d = [[0 for col in range(cols)] for row in range(rows)] &gt;&gt;&gt; list_2d = [ [0 for i in range(5)] for i in range(5)] &gt;&gt;&gt; list_2d [[0, 0, 0, 0, 0], [0, 0, 0, 0, 0], [0, 0, 0, 0, 0], [0, 0, 0, 0, 0], [0, 0, 0, 0, 0]] &gt;&gt;&gt; 列表函数&amp;方法函数len(list)：列表元素个数 max(list)：返回列表元素最大值 min(list)：返回列表元素最小值 list(seq)：将元组转换为列表 方法list.append(obj)：在列表末尾添加新的对象 list.count(obj)：统计某个元素在列表中出现的次数 list.extend(seq)：在列表末尾一次性追加另一个序列中的多个值（用新列表扩展原来的列表） list.index(obj)：从列表中找出某个值第一个匹配项的索引位置 list.insert(index, obj)：将对象插入列表 list.pop(obj=list[-1])：移除列表中的一个元素（默认最后一个元素），并且返回该元素的值 list.remove(obj)：移除列表中某个值的第一个匹配项 list.reverse()：反向列表中元素 list.sort([func])：对原列表进行排序 list.clear()：清空列表 list.copy()：复制列表 元组Python 的元组与列表类似，不同之处在于元组的元素不能修改。元组使用小括号，列表使用方括号。 创建元祖元组创建只需要在括号()中添加元素，并使用逗号隔开即可。 &gt;&gt;&gt; tuple1=(&apos;google&apos;,&apos;runoob&apos;,1997,2000) &gt;&gt;&gt; tuple2=&quot;a&quot;,&quot;b&quot;,&quot;c&quot; #空元祖 &gt;&gt;&gt; tuple3=() #只包含一个元素时，需要在元素后面添加逗号 &gt;&gt;&gt; tuple4 = (50,) 访问元组元组可以使用下标索引来访问元组中的值，下标索引从0开始，与列表类似 print(&quot;tuple1[0]：&quot;,tuple1[0]) 修改元组元组中的元素值是不允许修改的，但可以对元组进行连接组合 &gt;&gt;&gt; tup1=(12,34) &gt;&gt;&gt; tup2=(&apos;abc&apos;,&apos;xyz&apos;) #修改元组元素操作是非法的 &gt;&gt;&gt; tup1[0]=100 Traceback (most recent call last): File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt; TypeError: &apos;tuple&apos; object does not support item assignment # 创建一个新的元组 &gt;&gt;&gt; tup3=tup1+tup2 &gt;&gt;&gt; print(tup3) (12, 34, &apos;abc&apos;, &apos;xyz&apos;) &gt;&gt;&gt; 删除元组元组中的元素值是不允许删除的，但可以使用del语句来删除整个元组。元组被删除后，输出变量会有异常信息 &gt;&gt;&gt; tup = (&apos;Google&apos;, &apos;Runoob&apos;, 1997, 2000) &gt;&gt;&gt; print (tup) (&apos;Google&apos;, &apos;Runoob&apos;, 1997, 2000) &gt;&gt;&gt; del tup; &gt;&gt;&gt; print (&quot;删除后的元组 tup : &quot;,tup) Traceback (most recent call last): File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt; NameError: name &apos;tup&apos; is not defined &gt;&gt;&gt; &gt;&gt;&gt; 元组运算符与字符串一样，元组之间可以使用 + 号和 * 号进行运算。运算后会生成一个新的元组。 #计算元素个数 &gt;&gt;&gt; len((1,2,3)) 3 #连接 &gt;&gt;&gt; (1,2,3)+(4,5,6) (1, 2, 3, 4, 5, 6) #复制 &gt;&gt;&gt; (&apos;Hi&apos;)*4 &apos;HiHiHiHi&apos; 元组截取元组也是一个序列，所以可以访问元组中的指定位置的元素，也可以截取索引中的一段元素 &gt;&gt;&gt; L=(&apos;Google&apos;, &apos;Taobao&apos;, &apos;Runoob&apos;) #读取第三个元素 &gt;&gt;&gt; L[2] &apos;Runoob&apos; #反向读取；读取倒数第二个元素 &gt;&gt;&gt; L[-2] &apos;Taobao&apos; #截取元素，从第二个开始后的所有元素。 &gt;&gt;&gt; L[1:] (&apos;Taobao&apos;, &apos;Runoob&apos;) &gt;&gt;&gt; 内置函数len(tuple)：计算元组元素个数。 max(tuple)：返回元组中元素最大值。 min(tuple)：返回元组中元素最小值。 tuple(seq)：将列表转换为元组。 字典字典是另一种可变容器模型，且可存储任意类型对象。在其他语言中也称为map，使用键-值（key-value）存储，具有极快的查找速度。。 创建字典字典的每个键值(key=&gt;value)对用冒号(:)分割，每个对之间用逗号(,)分割，整个字典包括在花括号({})中 键必须是唯一的，但值则不必。值可以取任何数据类型，但键必须是不可变的，如字符串，数字或元组。字典键的特性： 1）不允许同一个键出现两次。创建时如果同一个键被赋值两次，后一个值会被记住 2）键必须不可变，可以用数字，字符串或元组充当，而用列表就不行 d = {key1 : value1, key2 : value2 } 例如： dict1={&quot;abc:123,98.6:37&quot;} 访问字典把相应的键放入方括弧（如果用字典里没有的键访问数据，会输出错误） &gt;&gt;&gt; dict ={&apos;name&apos;:&apos;runnoob&apos;,&apos;age&apos;:7,&apos;class&apos;:&apos;first class&apos;} &gt;&gt;&gt; print(&quot;dict[name]:&quot;,dict[&apos;name&apos;]) dict[name]: runnoob &gt;&gt;&gt; 修改字典向字典添加新内容的方法是增加新的键/值对，修改或删除已有键/值对: &gt;&gt;&gt; dict[&apos;age&apos;]=&apos;8&apos; &gt;&gt;&gt; dict[&apos;school&apos;]=&apos;hub&apos; &gt;&gt;&gt; print(dict[&apos;age&apos;]) 8 &gt;&gt;&gt; print(dict[&apos;school&apos;]) hub &gt;&gt;&gt; 删除字典元素能删单一的元素也能清空字典，清空只需一项操作。显示删除一个字典用del命令， &gt;&gt;&gt; del dict[&apos;name&apos;] # 删除键 &apos;Name&apos; &gt;&gt;&gt; dict.clear() #删除字典 &gt;&gt;&gt; del dict #删除字典 内置函数&amp;方法函数len(dict)：计算字典元素个数，即键的总数。 str(dict)：输出字典，以可打印的字符串表示。 type(variable)：返回输入的变量类型，如果变量是字典就返回字典类型。 方法clear()：删除字典内所有元素 copy()：返回一个字典的浅复制 fromkeys()：创建一个新字典，以序列seq中元素做字典的键，val为字典所有键对应的初始值 get(key, default=None)：返回指定键的值，如果值不在字典中返回default值 items()：以列表返回可遍历的(键, 值) 元组数组 keys()：以列表返回一个字典所有的键 setdefault(key, default=None)：和get()类似, 但如果键不存在于字典中，将会添加键并将值设为default update(dict2)：把字典dict2的键/值对更新到dict里 values()：以列表返回字典中的所有值 pop(key[,default])：删除字典给定键 key 所对应的值，返回值为被删除的值。key值必须给出。 否则，返回default值。 popitem()：随机返回并删除字典中的一对键和值。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[python3函数]]></title>
      <url>%2F2017%2F03%2F30%2Fpython%E5%87%BD%E6%95%B0%2F</url>
      <content type="text"><![CDATA[函数函数是组织好的，可重复使用的，用来实现单一，或相关联功能的代码段。函数能提高应用的模块性，和代码的重复利用率。 定义函数自定义函数规则： def 函数名（参数列表）: 函数体 例如： def hello(): print(&quot;hello world&quot;) hello() 函数代码块以 def 关键词开头，后接函数标识符名称和圆括号 ()。 任何传入参数和自变量必须放在圆括号中间，圆括号之间可以用于定义参数。默认情况下，参数值和参数名称是按函数声明中定义的的顺序匹配起来的。 函数的第一行语句可以选择性地使用文档字符串—用于存放函数说明。 函数内容以冒号起始，并且缩进。 return [表达式] 结束函数，选择性地返回一个值给调用方。不带表达式的return相当于返回 None。 函数调用定义一个函数：给了函数一个名称，指定了函数里包含的参数，和代码块结构。可以通过另一个函数调用执行，也可以直接从 Python 命令提示符执行。 参数传递在 python 中，类型属于对象，变量是没有类型的，仅仅是一个对象的引用（一个指针） 可更改(mutable)与不可更改(immutable)对象在 python 中，strings, tuples, 和 numbers 是不可更改的对象，而 list,dict 等则是可以修改的对象。 不可变类型：变量赋值 a=5 后再赋值 a=10，这里实际是新生成一个 int 值对象 10，再让 a 指向它，而 5 被丢弃，不是改变a的值，相当于新生成了a。 可变类型：变量赋值 la=[1,2,3,4] 后再赋值 la[2]=5 则是将 list la 的第三个元素值更改，本身la没有动，只是其内部的一部分值被修改了。 python 函数的参数传递： 不可变类型：类似 c++ 的值传递，如 整数、字符串、元组。如fun（a），传递的只是a的值，没有影响a对象本身。比如在 fun（a）内部修改 a 的值，只是修改另一个复制的对象，不会影响 a 本身。 可变类型：类似 c++ 的引用传递，如 列表，字典。如 fun（la），则是将 la 真正的传过去，修改后fun外部的la也会受影响python 中一切都是对象，严格意义不能说值传递还是引用传递，应该说传不可变对象和传可变对象。 python 传不可变对象实例def ChangeInt( a ): a = 10 b = 2 ChangeInt(b) print( b ) # 结果是 2 实例中有 int 对象 2，指向它的变量是 b，在传递给 ChangeInt 函数时，按传值的方式复制了变量 b，a 和 b 都指向了同一个 Int 对象，在 a=10 时，则新生成一个 int 值对象 10，并让 a 指向它。 传可变对象实例可变对象在函数里修改了参数，那么在调用这个函数的函数里，原始的参数也被改变了 def changeme( mylist ): &quot;修改传入的列表&quot; mylist.append([1,2,3,4]); print (&quot;函数内取值: &quot;, mylist) return # 调用changeme函数 mylist = [10,20,30]; changeme( mylist ); print (&quot;函数外取值: &quot;, mylist) 传入函数的和在末尾添加新内容的对象用的是同一个引用。故输出结果如下： 函数内取值: [10, 20, 30, [1, 2, 3, 4]] 函数外取值: [10, 20, 30, [1, 2, 3, 4]] 参数必需参数必需参数须以正确的顺序传入函数。调用时的数量必须和声明时的一样。 关键字参数关键字参数和函数调用关系紧密，函数调用使用关键字参数来确定传入的参数值。使用关键字参数允许函数调用时参数的顺序与声明时不一致，因为 Python 解释器能够用参数名匹配参数值。 def printinfo( name, age ): &quot;打印任何传入的字符串&quot; print (&quot;名字: &quot;, name); print (&quot;年龄: &quot;, age); return; #调用printinfo函数 printinfo( age=50, name=&quot;runoob&quot; ); 默认参数调用函数时，如果没有传递参数，则会使用默认参数。 def printinfo( name, age = 35 ): &quot;打印任何传入的字符串&quot; print (&quot;名字: &quot;, name); print (&quot;年龄: &quot;, age); return; #调用printinfo函数 printinfo( age=50, name=&quot;runoob&quot; ); #age默认参数 printinfo( name=&quot;runoob&quot; ); 不定长参数需要一个函数能处理比当初声明时更多的参数。这些参数叫做不定长参数，和上述2种参数不同，声明时不会命名。 def functionname([formal_args,] *var_args_tuple ): &quot;函数_文档字符串&quot; function_suite return [expression] 加了星号（*）的变量名会存放所有未命名的变量参数。如果在函数调用时没有指定参数，它就是一个空元组，也可以不向函数传递未命名的变量。 匿名函数python 使用 lambda 来创建匿名函数。所谓匿名，即不再使用 def 语句这样标准的形式定义一个函数。 lambda [arg1 [,arg2,.....argn]]:expression lambda 只是一个表达式，函数体比 def 简单很多。 lambda的主体是一个表达式，而不是一个代码块。仅仅能在lambda表达式中封装有限的逻辑进去。 lambda 函数拥有自己的命名空间，且不能访问自有参数列表之外或全局命名空间里的参数。 虽然lambda函数看起来只能写一行，却不等同于C或C++的内联函数，后者的目的是调用小函数时不占用栈内存从而增加运行效率。 sum = lambda arg1, arg2: arg1 + arg2; # 调用sum函数 print (&quot;相加后的值为 : &quot;, sum( 10, 20 ))#结果为30 return语句return [表达式] 语句用于退出函数，选择性地向调用方返回一个表达式。不带参数值的return语句返回None 变量作用域Python的作用域一共有4中，分别是：L （Local） 局部作用域E （Enclosing） 闭包函数外的函数中G （Global） 全局作用域B （Built-in） 内建作用域以 L –&gt; E –&gt; G –&gt;B 的规则查找，即：在局部找不到，便会去局部外的局部找（例如闭包），再找不到就会去全局找，再者去内建中找。 x = int(2.9) # 内建作用域 g_count = 0 # 全局作用域 def outer(): o_count = 1 # 闭包函数外的函数中 def inner(): i_count = 2 # 局部作用域 Python 中只有模块（module），类（class）以及函数（def、lambda）才会引入新的作用域，其它的代码块（如 if/elif/else/、try/except、for/while等）是不会引入新的作用域的，也就是说这这些语句内定义的变量，外部也可以访问 全局变量和局部变量定义在函数内部的变量拥有一个局部作用域，定义在函数外的拥有全局作用域。局部变量只能在其被声明的函数内部访问，而全局变量可以在整个程序范围内访问。调用函数时，所有在函数内声明的变量名称都将被加入到作用域中。 total = 0; # 这是一个全局变量 # 可写函数说明 def sum( arg1, arg2 ): #返回2个参数的和.&quot; total = arg1 + arg2; # total在这里是局部变量. print (&quot;函数内是局部变量 : &quot;, total) return total; #调用sum函数 sum( 10, 20 ); print (&quot;函数外是全局变量 : &quot;, total) 结果： 函数内是局部变量 : 30 函数外是全局变量 : 0 global 和 nonlocal关键字当内部作用域想修改外部作用域的变量时，就要用到global和nonlocal关键字。修改全局变量 num： num = 1 def fun1(): global num # 需要使用 global 关键字声明 print(num) num = 123 print(num) fun1() 结果： 1 123 修改嵌套作用域（enclosing 作用域，外层非全局作用域）中的变量则需要 nonlocal 关键字 def outer(): num = 10 def inner(): nonlocal num # nonlocal关键字声明 num = 100 print(num) inner() print(num) outer() 结果： 100 100]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[python3应用-自动签到]]></title>
      <url>%2F2017%2F03%2F30%2Fpython%E5%BA%94%E7%94%A8-%E8%87%AA%E5%8A%A8%E7%AD%BE%E5%88%B0%2F</url>
      <content type="text"><![CDATA[前言初学python3想做一些简单实例，参考博文进行了简单修改，实现了windows下自动签到功能 源码实现 系统环境：windows-64 python：python3.6 #author:chamo import codecs import datetime import re #读取记录 def readRecord(path): with open(path,&apos;a+&apos;) as f: data=f.readline() # 读取文件第一行，并判断第一行是否有隐藏的BOM_UTF8 if data[:3]==codecs.BOM_UTF8: data=data[3:] print (data) for data in f: print (data) #计算工作日期，和周几 def workDate(*time): if time: #datetime模块还包含一个datetime类，通过from datetime import datetime导入的才是datetime这个类 #如果仅导入import datetime，则必须引用全名datetime.datetime now=datetime.datetime.strptime(time[0],&apos;%Y-%m-%d&apos;) else: now=datetime.datetime.now() week=now.weekday() weeks=(&quot;Monday&quot;,&quot;Tuesday&quot;,&quot;Wednesday&quot;,&quot;Thursday&quot;,&quot;Friday&quot;,&quot;Saturday&quot;,&quot;Sunday&quot;) #格式化时间 now=str(now.strftime(&apos;%Y-%m-%d&apos;)) return (now,weeks[week]) #计算当前工作天数（id） def workCount(file): count = 0 #enumerate会将数组或列表组成一个索引序列 for count, line in enumerate(file): pass count += 1 return str(count) #读取文件最后一行列表的时间项 def lastLine(file): #readlines() 自动将文件内容分析成一个行的列表，该列表可以由 Python 的 for ... in ... 结构进行处理 lines=file.readlines() #-1是因为光标读到文件内容后一位 if lines: data=lines[len(lines)-1] #字符串按空格分割成一个单词列表。 ary=re.split(&apos;\s+&apos;,data) return ary[1] # 写入文本文件 # time格式为: 2017-7-01 # time接收可变参数 def writeRecord(path,*time): with open(path,&apos;a+&apos;) as f: count=workCount(f) if time: (mydate,week)=workDate(time[0]) else: (mydate,week)=workDate() #重新定位在文件的第0位及开始位置 f.seek(0) if lastLine(f)!=mydate: #ljust()方法返回长度为width的左对齐的字符串 f.write(count.ljust(12)+(mydate).ljust(16)+week.ljust(16)+&apos;True&apos;+&apos;\n&apos;) print (&quot;签到完成&quot;) else: print (&quot;请不要重复签到！&quot;) writeRecord(&apos;F:\python learning\sign.txt&apos;) readRecord(&apos;F:\python learning\sign.txt&apos;) 自动签到功能创建auto.bat文件： f: cd F:\python learning start python main.py exit 将该文件复制到启动项文件夹 C:\Users\Administrator\AppData\Roaming\Microsoft\Windows\Start Menu\Programs\Startup]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[python3异常处理]]></title>
      <url>%2F2017%2F03%2F30%2Fpython%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86%2F</url>
      <content type="text"><![CDATA[异常处理当认为某些代码可能会出错时，就可以用try来运行这段代码，如果执行出错，则后续代码不会继续执行，而是直接跳转至错误处理代码，即except语句块，执行完except后，如果有finally语句块，则执行finally语句块，至此，执行完毕。一个 try 语句可能包含多个except子句，分别来处理不同的特定的异常。最多只有一个分支会被执行。处理程序将只针对对应的try子句中的异常进行处理，而不是其他的 try 的处理程序中的异常。一个except子句可以同时处理多个异常，这些异常将被放在一个括号里成为一个元组 except (RuntimeError, TypeError, NameError): pass try except 语句还有一个可选的else子句，如果使用这个子句，那么必须放在所有的except子句之后。这个子句将在try子句没有发生任何异常的时候执行 抛出异常Python 使用 raise 语句抛出一个指定的异常。如果只想知道是否抛出了一个异常，并不想去处理它，简单的 raise 语句就可以再次把它抛出。 except NameError: print(&apos;An exception flew by!&apos;) raise 用户自定义异常通过创建一个新的exception类来拥有自己的异常。异常应该继承自 Exception 类，或者直接继承，或者间接继承 class MyError(Exception): def __init__(self, value): self.value = value def __str__(self): return repr(self.value) 定义清理行为如果一个异常在 try 子句里（或者在 except 和 else 子句里）被抛出，而又没有任何的 except 把它截住，那么这个异常会在 finally 子句执行后再次被抛出。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[单片机寄存器总结]]></title>
      <url>%2F2017%2F03%2F29%2F%E5%8D%95%E7%89%87%E6%9C%BA%E5%AF%84%E5%AD%98%E5%99%A8%E6%80%BB%E7%BB%93%2F</url>
      <content type="text"><![CDATA[#前言#51单片机内部有一个CPU用来运算、控制，四个并行I/O口，分别是P0、P1、P2、P3，ROM存放程序，RAM存放中间结果，此外包括定时/计数器，串行I/O口，中断系统，以及一个内部的时钟电路。在单片机中有一些独立的存储单元是用来控制这些器件的，被称之为特殊功能寄存器（SFR）。这样的特殊功能寄存器在51单片机中共有21个并且都是可位寻址的。 #单片机寄存器#21个特殊功能寄存器（52系列是26个）不连续地分布在128个字节的SFR存储空间中，地址空间为80H-FFH，在这片SFR空间中，包含有128个位地址空间，地址也是80H-FFH，但只有83个有效位地址，可对11个特殊功能寄存器的某些位作位寻址操作（其地址能被8整除的都可以位寻址）。列表如下(其中带*号的为52系列所增加的特殊功能寄存器）： ##B寄存器##在做乘、除法时放乘数或除数，不做乘除法时，可以随便使用。 ##ACC累加器##自身带有全零标志Z，若A＝0则Z＝1；若A≠0则z＝0。该标志常用作程序分枝转移的判断条件。 ##PSW程序状态字##里面放了CPU工作时的很多状态，可以了解CPU的当前状态，并作出相应的处理CY进位标志：8051中的运算器是一种8位的运算器，8位运算器只能表示到0-255，如果做加法的话，两数相加可能会超过255，这样最高位就会丢失，造成运算的错误。最高位就进到CY中来。有进、借位，CY＝1；无进、借位，CY＝0 AC辅助进、借位(高半字节与低半字节间的进、借位)： 例：57H+3AH（01010111+00111010） F0用户标志位：由用户（编程人员）决定什么时候用，什么时候不用。 RS1、RS0工作寄存器组选择位：通过修改PSW中的RS1、RS0两位的状态，就能任选一个工作寄存器区。这个特点提高了MCS-51现场保护和现场恢复的速度。对于提高CPU的工作效率和响应中断的速度是很有利的。若在一个实际的应用系统中，不需要四组工作寄存器，那么这个区域中多余单元可以作为一般的数据缓冲器使用。 0V溢出标志位： 运算结果按补码运算理解。有溢出，OV=1；无溢出，OV＝0。 P奇偶校验位：它用来表示运算结果中二进制数位“1”的个数的奇偶性。若为奇数，则P=1，否则为0。运算结果有奇数个1，P＝1；运算结果有偶数个1，P＝0。 例：某运算结果是78H（01111000），显然1的个数为偶数，所以P=0。 ##IP中断优先级控制寄存器##可按位寻址，地址位B8H （IP.7）：保留 （IP.6）：保留PT2（IP.5）：定时2中断优先（8052用）PS （IP.4）：串行口中断优先PT1（IP.3）：定时1中断优先PX1（IP.2）：外中断INT1中断优先PT0（IP.1）：定时器0中断优先PX0（IP.0）：外部中断INT0的中断优先##P0,P1,P2,P3寄存器##四个并行输入/输出口（I/O）的寄存器，对应着管脚的输出。##IE中断充许寄存器##可按位寻址，地址：A8HEA （IE.7）：EA=0时，所有中断禁止（即不产生中断）；EA=1时，各中断的产生由个别的允许位决定 （IE.6）：保留ET2（IE.5）：定时2溢出中断充许（8052用）ES （IE.4）：串行口中断充许（ES=1充许，ES=0禁止）ET1（IE.3）：定时1中断充许EX1（IE.2）：外中断INT1中断充许ET0（IE.1）：定时器0中断充许EX0（IE.0）：外部中断INT0的中断允许 ##TMOD定时器方式控制寄存器##不按位寻址，地址89HGATE ：定时操作开关控制位，当GATE=1时，INT0或INT1引脚为高电平，同时TCON中的TR0或TR1控制位为1时，计时/计数器0或1才开始工作。若GATE=0，则只要将TR0或TR1控制位设为1，计时/计数器0或1就开始工作。C/T ：定时器或计数器功能的选择位。C/T=1为计数器，通过外部引脚T0或T1输入计数脉冲。C/T=0时为定时器，由内部系统时钟提供计时工作脉冲。M1 、M0：T0、T1工作模式选择位 ##TCON定时器控制寄存器##可按位寻址，地址位88HTF1：定时器T1溢出标志，可由程序查询和清零，TF1也是中断请求源，当CPU响应T1中断时由硬件清零。TF0：定时器T0溢出标志，可由程序查询和清零，TF0也是中断请求源，当CPU响应T0中断时由硬件清零。TR1：T1充许计数控制位，为1时充许T1计数。TR0：T0充许计数控制位，为1时充许T0计数。IE1：外部中断1请示源（INT1，P3.3）标志。IE1＝1，外部中断1正在向CPU请求中断，当CPU响应该中断时由硬件清“0”IE1（边沿触发方式）。IT1：外部中断源1触发方式控制位。IT1＝0，外部中断1程控为电平触发方式，当INT1（P3.3）输入低电平时，置位IE1。IE0：外部中断0请示源（INT0，P3.2）标志。IE0＝1，外部中断1正在向CPU请求中断，当CPU响应该中断时由硬件清“0”IE0（边沿触发方式）。IT0：外部中断源0触发方式控制位。IT0＝0，外部中断1程控为电平触发方式，当INT0（P3.2）输入低电平时，置位IE0。 ##SCON—-串行通信控制寄存器##可寻址的专用寄存器，用于串行数据的通信控制，单元地址是98H(1)SM0、SM1：串行口工作方式控制位。 SM0，SM1 工作方式 00 方式0－波特率由振荡器频率所定：振荡器频率/12 01 方式1－波特率由定时器T1或T2的溢出率和SMOD所定：2SMOD ×(T1溢出率)/32 10 方式2－波特率由振荡器频率和SMOD所定：2SMOD ×振荡器频率/64 11 方式3－波特率由定时器T1或T2的溢出率和SMOD所定：2SMOD ×(T1溢出率)/32 (2)SM2：多机通信控制位。&lt; br&gt; 多机通信是工作于方式2和方式3，SM2位主要用于方式2和方式3。接收状态，当串行口工作于方式2或3，以及SM2=1时，只有当接收到第9位数据（RB8）为1时，才把接收到的前8位数据送入SBUF，且置位RI发出中断申请，否则会将接受到的数据放弃。当SM2=0时，就不管第位数据是0还是1，都难得数据送入SBUF，并发出中断申请。工作于方式0时，SM2必须为0。 (3)REN：允许接收位。&lt; br&gt; REN用于控制数据接收的允许和禁止，REN=1时，允许接收，REN=0时，禁止接收。 (4)TB8：发送接收数据位8。&lt; br&gt; 在方式2和方式3中，TB8是要发送的——即第9位数据位。在多机通信中同样亦要传输这一位，并且它代表传输的地址还是数据，TB8=0为数据，TB8=1时为地址。 (5)RB8：接收数据位8。在方式2和方式3中，RB8存放接收到的第9位数据，用以识别接收到的数据特征。 (6)TI：发送中断标志位。可寻址标志位。方式0时，发送完第8位数据后，由硬件置位，其它方式下，在发送或停止位之前由硬件置位，因此，TI=1表示帧发送结束，TI可由软件清“0”。 (7)RI：接收中断标志位。可寻址标志位。接收完第8位数据后，该位由硬件置位，在其他工作方式下，该位由硬件置位，RI=1表示帧接收完成。 ##PCON电源管理寄存器##PCON主要是为CHMOS型单片机的电源控制而设置的专用寄存器，单元地址是87H在CHMOS型单片机中，除SMOD位外，其他位均为虚设的，SMOD是串行口波特率倍增位，当SMOD=1时，串行口波特率加倍。系统复位默认为SMOD=0。 #文章来源#单片机寄存器]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Hexo+github搭建个人博客（一）]]></title>
      <url>%2F2017%2F03%2F29%2Fhexo-github-one%2F</url>
      <content type="text"><![CDATA[简介Hexo 是一个快速、简洁且高效的静态站点生成框架，它基于 Node.js 。 它有以下特点： 超快速度：Node.js 所带来的超快生成速度，让上百个页面在几秒内瞬间完成渲染。 支持Markdown：Hexo 支持 GitHub Flavored Markdown 的所有功能，甚至可以整合 Octopress 的大多数插件。 一件部署：只需一条指令即可部署到Github Pages，或其他网站 丰富的插件：Hexo 拥有强大的插件系统，安装插件可以让 Hexo 支持 Jade,CoffeeScript。 安装准备工作安装 Hexo 相当简单。然而在安装前，您必须检查电脑中是否已安装下列应用程序: Node.jsGit 安装 Git Windows： git下载地址： 官网Download Now 安装：在Git Setup中选择Use Git from the windows Command Prompt,除此之外一路Next完成安装 安装 Node.js Windos:Node.js v0.12.5 x64 :下载地址： 百度云Download Now Node.js官网Download Now 安装：一路NExt即可，等待完成安装 ##软件验证运行窗口CMD,输入一下命令，会显示相应版本信息： git --version node -v npm -v申请GITHUB申请地址：Github方法简述： 申请账号（用户名+密码),并进行邮箱验证 创建repository，名字与用户名一致。例如我的用户名BlueSky-chamo,Repository name为BlueSky-chamo.github.io 在创建的repository中settings中的Github pages中选择theme,启用Github page## 安装 Hexohexo是基于node.js的静态博客，官网也是搭建在GitHub上安装方法： 新建文件夹blog,右键选择Git Bash 安装hexo为了避免出现被“墙”，使用淘宝NPM镜像npm install -g cnpm --registry=https://registry.npm.taobao.org 安装hexo:cnpm install -g hexo-clicnpm install hexo --save 验证：hexo -v 本地运行：初始化命令：hexo init安装生成器：cnpm install浏览器本地访问：hexo s,本地浏览器输入http://localhost:4000/即可本地访问 hexo基本管理目录结构12345678.├── _config.yml├── package.json├── scaffolds├── source| ├── _drafts| └── _posts└── _config.yml：站点配置文件，即博客基本设置source:资源文件，即自定义的页面与推送的博客文件 ###_config.yml文件关键配置： url: 博客地址，与github申请的repository一致 如：http://BlueSky-chamo.github.io theme: 博客主题。默认下为landscape deploy: 发布设置。两种方式如下，可自行选择repository: https://github.com/BlueSky-chamo/BlueSky-chamo.github.io.gitrepository: git@github.com:BlueSky-chamo/BlueSky-chamo.github.io.git source文件资源文件 新建文章hexo new &quot;hello&quot;2.新建页面hexo new page hello Github与hexo创建联系配置SSH KEY 生成SSH KEY：ssh-keygen -t rsa -C &quot;邮件地址@youremail.com&quot; 按提示输入密码后在C:\Documents and Settings\Administrator.ssh\id_rsa.pub文件的内容即为秘钥 登陆github系统，点击右上角的 Account Settings—&gt;SSH Public keys —&gt; add another public keys把你本地生成的密钥复制到里面（key文本框中） 设置git身份信息git config --global user.name &quot;你的用户名&quot;git config --global user.email &quot;你的邮箱&quot; 验证git信息SSH -T git@github.com 发布博客安装hexo git插件cnpm install hexo-deployer-git --save 发布更新博客hexo d -g ##参考零基础免费搭建个人博客]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[排序算法之选择排序]]></title>
      <url>%2F2017%2F03%2F29%2F%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E4%B9%8B%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8F%2F</url>
      <content type="text"><![CDATA[选择排序选择排序（从小到大）的基本思想是先选出最小的数，放在第一个位置；然后，选出第二小的数，放在第二个位置；以此类推，直到所有的数从小到大排序。 算法描述选择排序对大小为N的无序数组R[N]进行排序，进行N-1轮选择过程。第i轮选取第i小的数，并将其放在第i个位置上。当第N-1次完成时，第N小（也就是最大）的数自然在最后的位置上。 下面对 3 2 4 1 进行选择排序说明排序过程，使用min_index 记录当前最小的数所在的位置。 第1轮 排序过程 （寻找第1小的数所在的位置） 3 2 4 1（min_index=1） 3 2 4 1（3 &gt; 2， min_index=2） 3 2 4 1（2 &lt; 4， min_index=2） 3 2 4 1（2 &gt; 1， min_index=4） 1 2 4 3 （第1轮结果，将3和1交换，也就是位置1和位置4交换） 第2轮 排序过程 （寻找第2小的数所在的位置） 1 2 4 3（第1轮结果， min_index=2，只需要从位置2开始寻找） 1 2 4 3（4 &gt; 2， min_index=2） 1 2 4 3（3 &gt; 2， min_index=2） 1 2 4 3（第2轮结果，因为min_index位置刚好在第2个位置，无需交换） 第3轮 排序过程 （寻找第3小的数所在的位置） 1 2 4 3（第2轮结果， min_index=3，只需要从位置2开始寻找） 1 2 4 3（4 &gt; 3， min_index=4） 1 2 3 4（第3轮结果，将3和4交换，也就是位置4和位置3交换） 至此，排序完毕。 #代码实现# #include&lt;stdio.h&gt; #include&lt;stdlib.h&gt; #define N 8 void select_sort(int a[],int n); //选择排序实现,n为数组a的元素个数 void select_sort(int a[],int n) { int i=0; int j=0; //进行N-1轮选择 for(i=0; i&lt;n-1; i++) { int min_index = i; //找出第i小的数所在的位置 for(j=i+1; j&lt;n; j++) { if(a[j] &lt; a[min_index]) { min_index = j; } } //将第i小的数，放在第i个位置；如果刚好，就不用交换 if( i != min_index) { int temp = a[i]; a[i] = a[min_index]; a[min_index] = temp; } } } int main() { int i=0; int num[N] = {89, 38, 11, 78, 96, 44, 19, 25}; select_sort(num, N); for(i=0; i&lt;N; i++) printf(&quot;%d &quot;, num[i]); printf(&quot;\n&quot;); system(&quot;pause&quot;); return 0; } #性能分析#在比较次数上为n(n-1)/2时间复杂度为o(nn)在最好的情况下，数字初始有序则只需要比较即可，不存在交换操作。在最差情况下，数字初始逆序。同样时间复杂度为o(n*n)。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[排序算法之插入排序]]></title>
      <url>%2F2017%2F03%2F29%2F%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E4%B9%8B%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F%2F</url>
      <content type="text"><![CDATA[插入排序基本思想：通过构建有序序列，对于未排序数据，在已排序序列中从后向前扫描，找到相应的位置并插入。 插入排序有N-1趟排序组成，对于P=1趟到p=N-1趟排序，插入排序保证从位置0到位置P的元素为已排序状态。每次遍历的任务是：通过扫描前面已排序的子列表，将位置P处的元素定位到从0到P的子列表之内的正确的位置上。如下图所示，P=1时，位置1上的元素3与子列表4进行比较；P=2时，位置2上的元素1与子列表[3,4]比较；P=3时，位置3上的元素2与子列表[1,3,4]比较。 算法描述假定n是数组的长度，第一个元素被放置在正确的位置上，这样仅需从1-n-1范围内对剩余元素进行排序。对于每次遍历，从0-i-1范围内的元素已经被排好序， 每次遍历的任务是：通过扫描前面已排序的子列表，将位置i处的元素定位到从0到i的子列表之内的正确的位置上。 将arr[i]复制为一个名为key的临时元素。 采用向下扫描列表方式（从后向前方式），key依次与子列表arr[i-1]、arr[i-2]的大小比较 当key小于子列表的某一项时，a[j-1]&gt;key，该项向右移动一个位置，供key使用。a[j] = a[j-1]当key大于子列表某一项时，a[j-1]&lt;key,该项后一位即为key的位置。a[j] = key; 与选择排序不同的是，插入排序将数据向右滑动，并且不会执行交换。 代码实现#include&lt;stdio.h&gt; #define MAX 8 int main(void) { int a[MAX]={8,7,6,5,4,3,2,1}; void insert(int*a,int n);//函数声明 int i=0; insert(a,MAX); printf(&quot;after:\n&quot;); for(i=0;i&lt;8;i++) { printf(&quot;%d &quot;,a[i]); } printf(&quot;\n&quot;); return 0; } void insert(int *a,int n) { int i,j,key; for(i=1;i&lt;n;i++)//控制需要插入的元素 { key=a[i]; //key为要插入的元素 for(j=i;j&gt;0 &amp;&amp; a[j-1]&gt;key;j--) //查找要插入的位置,循环结束,则找到插入位置 { a[j] = a[j-1]; //移动元素的位置.供要插入元素使用 } a[j] = key; //插入需要插入的元素 } } 效率分析空间复杂度O(1)时间复杂度O(n2)：嵌套循环的每一个都花费N次迭代最差情况：反序，需要移动n*(n-1)/2个元素最好情况：正序，不需要移动元素 数组在已排序或者是“近似排序”时，插入排序效率的最好情况运行时间为O(n)（因为内层的for检测总是判定不成立的） 插入排序最坏情况运行时间和平均情况运行时间都为O(n2)。 在列表已被排序时，插入排序是线性算法O(n)。 在列表“近似排序”时，插入排序仍然是线性算法。 在列表的许多元素已位于正确的位置上时，就会出现“近似排序”的条件。 通过使用O(nlog2n)效率的算法（如快速排序）对数组进行部分排序， 然后再进行选择排序，某些高级的排序算法就是这样实现的。 实验验证环境：VC6.0 二分法插入排序插入排序中，总是先寻找插入位置，然后在实行挪动和插入过程；寻找插入位置采用顺序查找的方式（从前向后或者从后向前），既然需要插入的数组已经是有序的，那么可以采用二分查找方法来寻找插入位置，提高算法效率，但算法的时间复杂度仍为O(n2)。 二分法插入排序过程：1.首先，原数组是一个有序序列，iBegin=0 iEnd=count-1。2.将要插入的数与数组中间位置的元素进行比较，如果比中间元素大，则iBegin=mid+1作为下一次判断的数组开头。如果比中间元素小，则iEnd=mid-1作为下一次判断的数组结尾。3.直到iBegin&gt;iEnd结束，iBegin就是新元素插入的位置。4.将数组中从iBegin开始的元素全部向后移动一位，之后在iBegin位置插入新元素。 #include&lt;stdio.h&gt; #define MAX 8 //查找数值iData在长度为iLen的pDataArray数组中的插入位置 int FindInsertIndex(int *pDataArray, int iLen, int iData) { int iBegin = 0; int iEnd = iLen - 1; int index = -1; //记录插入位置 while (iBegin &lt;= iEnd) { index = (iBegin + iEnd) / 2; if (pDataArray[index] &gt; iData) iEnd = index - 1; else iBegin = index + 1; } if (pDataArray[index] &lt;= iData) index++; return index; } /*函数名称：BinaryInsertSort *参数说明：pDataArray 无序数组； * iDataNum为无序数据个数 *说明： 二分查找插入排序 *********************************************************/ void BinaryInsertSort(int* pDataArray, int iDataNum) { int i; for (i = 1; i &lt; iDataNum; i++) //从第2个数据开始插入 { int index = FindInsertIndex(pDataArray, i, pDataArray[i]); //二分寻找插入的位置 if (i != index) //插入位置不为i，才挪动、插入 { int j = i; int temp = pDataArray[i]; while (j &gt; index) //挪动位置 { pDataArray[j] = pDataArray[j-1]; j--; } pDataArray[j] = temp; //插入 } } } int main(void) { int a[MAX]={8,7,6,5,4,3,2,1}; int i=0; BinaryInsertSort(a,MAX); printf(&quot;after:\n&quot;); for(i=0;i&lt;8;i++) { printf(&quot;%d &quot;,a[i]); } printf(&quot;\n&quot;); return 0; }]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[排序算法之快速排序]]></title>
      <url>%2F2017%2F03%2F29%2F%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E4%B9%8B%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F%2F</url>
      <content type="text"><![CDATA[快速排序快速排序是对冒泡排序的改进，主要思想是分治与递归。分治即通过一次排序将序列分成两部分，左边的部分全部小于基准值，右边的部分大于基准值递归即对分治区间继续采取快速排序主要步骤： 1．先从数列中取出一个数作为基准数。 2．分区过程，将比这个数大的数全放到它的右边，小于或等于它的数全放到它的左边。 3．再对左右区间递归排序，直到各区间只有一个数。 算法描述假设要排序的数组是A[0]……A[N-1]，首先任意选取一个数据（通常选用第一个数据）作为关键数据(key)，然后将所有比它小的数都放到它前面，所有比它大的数都放到它后面，这个过程称为一趟快速排序。一趟快速排序的算法是：1）定义两个变量low和high，将low、high分别设置为要进行排序的序列的起始元素和最后一个元素的下标。第一次，low和high的取值分别为0和n-1，接下来的每次取值由划分得到的序列起始元素和最后一个元素的下标来决定。 2）定义一个变量key，接下来以key的取值为基准将数组A划分为左右两个部分，通 常，key值为要进行排序序列的第一个元素值。第一次的取值为A[0]，以后毎次取值由要划 分序列的起始元素决定。 3）从high所指向的数组元素开始向左扫描，扫描的同时将下标为high的数组元素依次与划分基准值key进行比较操作，直到high不大于low或找到第一个小于基准值key的数组元素，然后将该值赋值给low所指向的数组元素，同时将low右移一个位置。 4）如果low依然小于high，那么由low所指向的数组元素开始向右扫描，扫描的同时将下标为low的数组元素值依次与划分的基准值key进行比较操作，直到low不小于high或找到第一个大于基准值key的数组元素，然后将该值赋给high所指向的数组元素，同时将high左移一个位置。 5）重复步骤(3) (4)，直到low的植不小于high为止，这时成功划分后得到的左右两部分分别为A[low……pos-1]和A[pos+1……high]，其中，pos下标所对应的数组元素的值就是进行划分的基准值key，所以在划分结束时还要将下标为pos的数组元素赋值 为 key。 算法实现#include &lt;stdio.h&gt; #include &lt;stdlib.h&gt; #define N 6 int partition(int arr[], int low, int high){ int key; key = arr[low];//关键数据 //low==high停止 while(low&lt;high){ //从后向前查找比关键数据key小的数据，否则high减1继续查找 while(low &lt;high &amp;&amp; arr[high]&gt;= key ) high--; if(low&lt;high) //若找到第一个比关键数据key小的数据，进行交换，同时low+1开始从前向后查找比key大的数据 arr[low++] = arr[high]; //从前向后查找比关键数据key大的数据，否则low加1继续查找 while( low&lt;high &amp;&amp; arr[low]&lt;=key ) low++; if(low&lt;high) //若找到第一个比关键数据key大的数据，继续交换，同时high-1继续从后向前查找，直到循环结束 arr[high--] = arr[low]; } //low==high时循环结束，此时将关键数据放在此时位置，实现分治 arr[low] = key; return low; } void quick_sort(int arr[], int start, int end){ int pos; if (start&lt;end){ pos = partition(arr, start, end); quick_sort(arr,start,pos-1); quick_sort(arr,pos+1,end); } return; } int main(void){ int i; int arr[N]={32,12,7, 78, 23,45}; printf(&quot;排序前 \n&quot;); for(i=0;i&lt;N;i++) printf(&quot;%d\t&quot;,arr[i]); quick_sort(arr,0,N-1); printf(&quot;\n 排序后 \n&quot;); for(i=0; i&lt;N; i++) printf(&quot;%d\t&quot;, arr[i]); printf (&quot;\n&quot;); system(&quot;pause&quot;); return 0; } 算法实现2#include &lt;stdio.h&gt; #include &lt;time.h&gt; #include &lt;stdlib.h&gt; #define MAX 10 #define SWAP(x, y) {int t=x; x=y; y=t;} void quickSort(int *a, int left, int right); int main(void) { int a[MAX] = {0}; int i; printf(&quot;排序前:\n&quot;); for (i=0; i&lt;MAX; i++) { a[i] = rand()%100; printf(&quot;%d &quot;, a[i]); } quickSort(a, 0, MAX-1); printf(&quot;\n排序后:\n&quot;); for (i=0; i&lt;MAX; i++) { printf(&quot;%d &quot;, a[i]); } printf(&quot;\n&quot;); return 0; } void quickSort(int *a, int left, int right) { if (left &lt; right) { int i = left; int j = right+1; while (1) { //从前向后查找第一个比关键数据a[left]大的数据，否则i+1继续查找 while (i+1&lt;MAX &amp;&amp; a[++i]&lt;a[left]); //从后向前查找第一个比关键数据a[left]小的数据，否则j-1继续查找 while (j-1&gt;-1 &amp;&amp; a[--j]&gt;a[left]); //知道i==j跳出循环，第一次分治结束 if (i &gt;= j) { break; } //将两个数据进行交换，即小的数据到前面去，大数据到后面去 SWAP(a[i], a[j]); } //i==j时吗，将关键数据a[left]放在中间位置,实现分治 SWAP(a[left], a[j]); //分治区间递归排序 quickSort(a, left, j-1); quickSort(a, j+1, right); } } 算法优化将基准值设定为序列中间的数，从中间向两边寻找 #include &lt;stdio.h&gt; #include &lt;time.h&gt; #include &lt;stdlib.h&gt; #define MAX 10 #define SWAP(x, y) {int t=x; x=y; y=t;} void quickSort(int *a, int left, int right); int main(void) { int a[MAX] = {0}; int i; printf(&quot;排序前:\n&quot;); for (i=0; i&lt;MAX; i++) { a[i] = rand()%100; printf(&quot;%d &quot;, a[i]); } quickSort(a, 0, MAX-1); printf(&quot;\n排序后:\n&quot;); for (i=0; i&lt;MAX; i++) { printf(&quot;%d &quot;, a[i]); } printf(&quot;\n&quot;); return 0; } void quickSort(int *a, int left, int right) { if (left &lt; right) { //中间元素 int t = a[(left+right)/2]; int i = left - 1; int j = right + 1; while (1) { //从前向后查找比中间元素大的数据 while (a[++i] &lt; t); //从后向前查找比中间元素小的数据 while (a[--j] &gt; t); if (i &gt;= j) { break; } SWAP(a[i], a[j]); } quickSort(a, left, i-1); quickSort(a, j+1, right); } } 算法优化2有指针left和right，对于right，如果其所指的元素的值大于或者等于基准值，那么指针往左移一位，如果小于基准值，则和基准值交换；同理，对于left，如果left所指元素的值小于或者等于基准值，那么指针往右移一位，如果大于基准值，则和基准值交换。从right开始执行，重复这两步骤，直至left == right为止。 #include &lt;stdio.h&gt; #include &lt;time.h&gt; #include &lt;stdlib.h&gt; #define MAX 10 #define SWAP(x, y) {int t=x; x=y; y=t;} void quickSort(int *a, int left, int right); int Partition(int *a, int left, int right); int main(void) { int a[MAX] = {0}; int i; printf(&quot;排序前:\n&quot;); for (i=0; i&lt;MAX; i++) { a[i] = rand()%100; printf(&quot;%d &quot;, a[i]); } quickSort(a, 0, MAX-1); printf(&quot;\n排序后:\n&quot;); for (i=0; i&lt;MAX; i++) { printf(&quot;%d &quot;, a[i]); } printf(&quot;\n&quot;); return 0; } int Partition(int *a, int left, int right) { int pivot = a[left]; while (left &lt; right) { while (left &lt; right &amp;&amp; a[right] &gt;= pivot) { --right; } a[left] = a[right]; while (left &lt; right &amp;&amp; a[left] &lt;= pivot) { ++left; } a[right] = a[left]; } return left; } void quickSort(int *a, int left, int right) { int pivot; if (left &lt; right) { pivot = Partition(a, left, right); quickSort(a, left, pivot-1); quickSort(a, pivot+1, right); } } 性能分析平均时间复杂度：O(nlog2n) 空间复杂度：O(n) 稳定性：不稳定 实验验证环境：vc6.0 参考学习几种快速排序的实现c语言快速排序及代码]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[排序算法之希尔排序]]></title>
      <url>%2F2017%2F03%2F29%2F%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E4%B9%8B%E5%B8%8C%E5%B0%94%E6%8E%92%E5%BA%8F%2F</url>
      <content type="text"><![CDATA[希尔排序希尔(Shell)排序又称为缩小增量排序，是直接插入排序的加强版。希尔排序的基本思想：把记录按步长 gap 分组，对每组记录采用直接插入排序方法进行排序。随着步长逐渐减小，所分成的组包含的记录越来越多，当步长的值减小到 1 时，整个数据合成为一组，构成一组有序记录。初始时，有一个大小为 10 的无序序列。 在第一趟排序中，设 gap1 = N / 2 = 5，即相隔距离为 5 的元素组成一组，可以分为 5 组。按照直接插入排序的方法对每个组进行排序。 在第二趟排序中，gap2 = gap1 / 2 = 2 (取整数)。这样每相隔距离为 2 的元素组成一组，可以分为 2 组。按照直接插入排序的方法对每个组进行排序。 在第三趟排序中，gap3 = gap2 / 2 = 1。 这样相隔距离为 1 的元素组成一组，即只有一组。按照直接插入排序的方法对每个组进行排序。此时，排序已经结束。 图中有两个相等数值的元素 5 和 5 ，在排序过程中，两个元素位置交换了。表明希尔排序是不稳定的算法。 代码实现#include &lt;stdio.h&gt; #include &lt;stdlib.h&gt; void shellSort(int a[],int len) { int step; int i,j; int temp; for(step=len/2; step&gt;0;step/=2) //step用来控制步长,最后递减到1 { // i从第step开始排列，应为插入排序的第一个元素 // 可以先不动，从第二个开始排序 for(i=step;i&lt;len;i++) { temp = a[i]; for(j=i-step;(j&gt;=0 &amp;&amp; temp &lt; a[j]);j-=step) { a[j+step] = a[j]; } a[j+step] = temp; //将第一个位置填上 } } } void main() { int i; int j; int a[] = {5, 18, 151, 138, 160, 63, 174, 169, 79, 200}; int len = sizeof(a)/sizeof(int); printf(&quot;Begin sorting...\n&quot;); for (i=0;i&lt;len;i++) { printf(&quot;%d\t&quot;,a[i]); } shellSort(a,len); printf(&quot;After sorting...\n&quot;); for (j=0;j&lt;len;j++) { printf(&quot;%d\t&quot;,a[j]); } } 性能分析 实验验证环境：VC6.0]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[排序算法之冒泡排序]]></title>
      <url>%2F2017%2F03%2F29%2F%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E4%B9%8B%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F%2F</url>
      <content type="text"><![CDATA[冒泡排序冒泡排序：依次比较相邻的数据，将小数据放在前，大数据放在后；即第一趟先比较第1个和第2个数，大数在后，小数在前，再比较第2个数与第3个数，大数在后，小数在前，以此类推则将最大的数”滚动”到最后一个位置；第二趟则将次大的数滚动到倒数第二个位置……第n-1(n为无序数据的个数)趟即能完成排序。如下图中的第一趟比较过程，元素40被移动到最后位置，依次类推，第二趟比较过程将元素14移动到倒数第二位位置，需要N-1趟即可排序完成，实现元素从小到大排序。 算法描述设数组长度为N。 1．比较相邻的前后二个数据，如果前面数据大于后面的数据，就将二个数据交换。if (pDataArray[j] &gt; pDataArray[j + 1]) 2．这样对数组的第0个数据到N-1个数据进行一次遍历后，最大的一个数据就“沉”到数组第N-1个位置。 3．重复前面二步，直到N-1趟排序完成。for (j = 0; j &lt; iDataNum - i - 1; j++) 代码实现#include&lt;stdio.h&gt; #define MAX 8 //交换data1和data2所指向的整形 void DataSwap(int* data1, int* data2) { int temp = *data1; *data1 = *data2; *data2 = temp; } /******************************************************** *函数名称：BubbleSort *参数说明：pDataArray 无序数组； * iDataNum为无序数据个数 *说明： 冒泡排序 *********************************************************/ void BubbleSort(int* pDataArray, int iDataNum) { int i; int j; for (i = 0; i &lt; iDataNum - 1; i++) //走iDataNum-1趟 for (j = 0; j &lt; iDataNum - i - 1; j++) if (pDataArray[j] &gt; pDataArray[j + 1]) DataSwap(&amp;pDataArray[j], &amp;pDataArray[j + 1]);////前面的数大于后面的数则交换，即大数向后移动一位 } int main(void) { int a[MAX]={8,7,5,6,4,3,2,1}; int i=0; BubbleSort(a,MAX); printf(&quot;after:\n&quot;); for(i=0;i&lt;8;i++) { printf(&quot;%d &quot;,a[i]); } printf(&quot;\n&quot;); return 0; } 实验验证环境：VC6.0 算法优化1用一个标记来记录在一趟的比较过程中是否存在交换，如果不存在交换则整个数组已经有序退出排序过程，反之则继续进行下一趟的比较。 void BubbleSort(int* pDataArray, int iDataNum) { BOOL flag = FALSE; //记录是否存在交换 for (int i = 0; i &lt; iDataNum - 1; i++) //走iDataNum-1趟 { flag = FALSE; for (int j = 0; j &lt; iDataNum - i - 1; j++) if (pDataArray[j] &gt; pDataArray[j + 1]) { flag = TRUE; DataSwap(&amp;pDataArray[j], &amp;pDataArray[j + 1]); } if (!flag) //上一趟比较中不存在交换，则退出排序 break; } } 算法优化2如果有100个数的数组，仅前面10个无序，后面90个都已排好序且都大于前面10个数字，那么在第一趟遍历后，最后发生交换的位置必定小于10，且这个位置之后的数据必定已经有序了，记录下这位置，第二次只要从数组头部遍历到这个位置就可以了。 void BubbleSort(int* pDataArray, int iDataNum) { int i; int j; int flag ; //记录是否存在交换 int k; flag=iDataNum; for (i = 0; i &lt; iDataNum - 1; i++) //走iDataNum-1趟 { k=flag; flag=0; for (j = 0; j &lt; k-1; j++) if (pDataArray[j] &gt; pDataArray[j + 1]) { flag = j+1; DataSwap(&amp;pDataArray[j], &amp;pDataArray[j + 1]); } if (flag&lt;0) //上一趟比较中不存在交换，则退出排序 break; } }]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[嵌入式编程风格]]></title>
      <url>%2F2017%2F03%2F29%2F%E5%B5%8C%E5%85%A5%E5%BC%8Fc%E7%BC%96%E7%A8%8B%E9%A3%8E%E6%A0%BC%2F</url>
      <content type="text"><![CDATA[前言编程的总则: 编程首要是要考虑程序的可行性，然后是可读性、可移植性、健壮性以及可测试性。 原文为C语言进阶之道中的编程风格章节 排版（1）代码缩进空格数为4个。若是可能，尽量用空格来代替Tab键，因为有些编译器不支持Tab键 BOOL BufClr(UINT8 * dest,UINT32 size) { if(NULL ==dest || NULL==size) { return FALSE; } } （2）较长的语句要分2行来书写，并用‘\’符号隔开。 if((UINT8) uncrc != Packet.down_ser.mCrc[0] \ ||(UINT8)(uncrc&gt;&gt;8)!= Packet.down_ser.mCrc[1]) { BELL(ON); } （3）函数代码的参数过长，分多行来书写。 void UARTSendAndRecv(UINT8 *ucSendBuf, UINT8 ucSendLength, UINT8 *ucRecvBuf, UINT8 ucRecvLength) { … } （4）if、do、while、switch、for、case、default等关键字，必须加上大括号{}。 if(bSendEnd) { BELL(ON); } else { BELL(OFF); } switch(ucintStatus) { case USB_INT_EP2_OUT: { USBCiEP2Send(USBMainBuf,ucrecvLen); USBCiEP1Send(USBMainBuf,ucrecvLen); } break; case USB_INT_EP2_IN: { USBCiWriteSingleCmd (CMD_UNLOCK_USB); } break; … } 注释（1）边写代码边注释，修改代码同时修改相应的注释，以保证注释与代码的一致性。不再有用的注释要删除。 注释应当准确、易懂，防止注释有二义性。错误的注释不但无益反而有害。 尽量避免在注释中使用缩写，特别是不常用缩写。注释的位置应与被描述的代码相邻，可以放在代码的上方或右方，不可放在下方。 （2）说明性文件必选在文件头着重说明，例如.c、.h文件 （3）函数头应该进行注释，例如函数名称、输入参数、返回值、功能说明。 ******将所有参数写入AT24C64,共4字节********************* *说明:将表号和用户电量共四字节数据写入AT24C64中 *入口参数: * 1.数据间接寻址地址-buf * 2.写入到AT24C64的地址字-addh,addrl * 3.写入字节数-count *出口参数:1表示写成功,0表示写失败 ***************************************************************/ bit write_byte( unsigned charchar * buf, unsigned char addrh, unsigned char addrl, unsigned char count) { …… } （4）全局变量要注释其功能，若为关键的局部变量同样需要注释其功能。 volatile UINT8 __ucSysMsg=SYS_IDLE; void SYSSetMsgPriority(void) { SYSMSG Msgt;//临时存储消息 UINT8 i; } （5）复杂的宏定义同样要加上注释。 /* SYS_MSG_MAP 建立一个消息映射 宏参数NAME：消息映射表的名字 宏参数NUM_OF_MSG:消息映射的个数 */ #define SYS_MSG_MAP(NAME,NUM_OF_MSG) do/ { / DEFINE_MSG_NAME((NAME));/ UINT8 i;/ for(i=0;i&lt; NUM_OF_MSG;i++)/ {/ ININ_CUR_MSG(i)/ }/ }while(0) （6）复杂的结构体同样要加上注释。 奇偶校验结构体*/ typedef struct _ PKT_PARITY { UINT8 m_ucHead1; //首部1 UINT8 m_ucHead2; //首部2 UINT8 m_ucOptCode; //操作码 UINT8 m_ucDataLength; //数据长度 UINT8 m_szDataBuf[16];//数据 UINT8 m_ucParity; //奇偶校验值 }PKT_PARITY; （7）相对独立的语句组注释。对这一组语句做特别说明，写在语句组上侧，和此语句组之间不留空行，与当前语句组的缩进一致。注意，说明语句组的注释一定要写在语句组上面，不能写在语句组下面。 标识符（1）变量命名局部变量以小写字母命名；全局变量以首字母大写方式命名（骆驼式）；定义类型和宏定义常数以大写字母命名；变量的作用域越大，它的名字所带有的信息就应该越多。局部变量： int student_age;全局变量： int StudentAge;宏定义常数：#define STUDENT_NUM 10类型定义： typedef INT16S int; （2） 变量命名要注意缩写而且让人简单易懂，若是特别缩写要详细说明。经常用到的缩写如：Count 可缩写为CntMessage 可缩写为MsgPacket 可缩写为PktTemp 可缩写为Tmp平时不经常用到的缩写，要注释：SerialCommunication 可缩写为SrlComm //串口通信变量SerialCommunicationStatus 可缩写为SrlCommStat //串口通信状态变量 （3）全局变量和全局函数的命名一定要详细，不惜多用几个单词，例如函数UARTPrintfStringForLCD因为它们在整个项目的许多源文件中都会用到，必须让使用者明确这个变量或函数是干什么用的。局部变量和只在一个源文件中调用的内部函数的命名可以。简略一些，但不能太短，不要使用单个字母做变量名，只有一个例外：用i、j 、k 做循环变量是可以的。 （4）用于编译开关的文件头，必须加上当前文件名称，防止编译时产生冲突。例如在UARTInterface.h 头文件中，必须加上以下内容 #ifndef __UARTINTERFACE_H__ #define __UARTINTERFACE_H__ extern void UARTPrintfString(CONST INT8* str); extern void UARTSendNBytes(UINT8 *ucSendBytes,UINT8 ucLen); …… //其他外部声明的代码 #endif （5）禁止用汉语拼音作为标识符名称，可读性极差 （6）建议名称间的区别要显而易见。使用标识符名称要注意的一个相关问题是发生在名称之间只有一个字符或少数字符不同的情况，特别是名称比较长时，当名称间的区别很容易被误读时问题就比较显著，比如1（数字1）和l（L 的小写）、0 和O、2 和Z、5 和S，或者n 和h。 表达式（1）不要编写太复杂的复合表达式； i = a &gt;= b &amp;&amp; c &lt; d &amp;&amp; c + f &lt;= g + h; //复合表达式过于复杂 （2）不要有多用途的复合表达式 d = (a = b + c) + r ; //应拆分为两个语句： a = b + c; d = a + r; （3）如果代码行中的运算符比较多，用括号确定表达式的操作顺序，避免使用默认的优先级。 if(a | b &amp;&amp; a &amp; c) //不良的风格 if((a | b) &amp;&amp; (a &amp; c)) //良好的风格 基本语句if语句（1）布尔变量与零值比较不可将布尔变量直接与TRUE、FALSE 或者1、0 进行比较。根据布尔类型的语义，零值为“假”（记为FALSE），任何非零值都是“真”（记为TRUE）。TRUE的值究竟是什么并没有统一的标准。例如Visual C++ 将TRUE 定义为1，而Visual Basic 则将TRUE 定义为-1。例：假设布尔变量名字为flag，它与零值比较的标准if 语句如下： if (flag) // 表示flag为真时满足条件 if (!flag) // 表示flag为假时满足条件 其它的用法都属于不良风格，例如： if (flag == TRUE) if (flag == 1 ) if (flag == FALSE) if (flag == 0) （2）整型变量与零值比较应当将整型变量用“==”或“！=”直接与0比较。例：假设整型变量为value，它与零值比较的标准if 语句如下： if (value == 0) if (value != 0) 不可模仿布尔变量的风格而写成 if (value) // 会让人误解 value 是布尔变量 if (!value) （3）浮点变量与零值比较不可将浮点变量用“==”或“！=”与任何数字比较。千万要留意，无论float 还是double 类型变量，都有精度限制。所以一定要避免将浮点变量用“==”或“！=”与数字比较，应该设法转化成“&gt;=”或“&lt;=”形式。假设浮点变量的名字为x，应当将 if (x == 0.0) // 隐含错误的比较 转化为 if ((x&gt;=-EPSINON) &amp;&amp; (x&lt;=EPSINON)) //EPSINON 是精度 其他（1）一些常量(如圆周率PI)或者常需要在调试时修改的参数最好用#define定义，但要注意宏定义只是简单的替换，因此有些括号不可少。 （2）不要轻易调用某些库函数，因为有些库函数代码很长(我是反对使用printf之类的库函数的，但是是一家之言，并不勉强各位)。 （3）对各运算符的优先级有所了解，记不得没关系，加括号就是，千万不要自作聪明说自己记得很牢。 （4）不管有没有无效分支，switch函数一定要defaut这个分支。一来让阅读者知道程序员并没有遗忘default,并且防止程序运行过程中出现的意外(健壮性)。 （5）函数的参数和返回值没有的话最好使用void。 （6）一些常数和表格之类的应该放到code中去以节省RAM。 （7）程序编完编译看有多少code多少data，注意不要使堆栈为难。 （8）减少函数本身或函数间的递归调用 （9）编写可重入函数时，若使用全局变量，则应通过关中断、信号量（即P、V操作）等手段对其加以保护。 （10）在多重循环中，应将最忙的循环放在最内层 （11）避免循环体内含判断语句，应将循环语句置于判断语句的代码块之中。 （12）系统运行之初，要初始化有关变量及运行环境，防止未经初始化的变量被引用。 （13）编写代码时要注意随时保存，并定期备份，防止由于断电、硬盘损坏等原因造成代码丢失。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[数据结构之单链表]]></title>
      <url>%2F2017%2F03%2F29%2F%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B9%8B%E5%8D%95%E9%93%BE%E8%A1%A8%2F</url>
      <content type="text"><![CDATA[前言链表由多个结点离散分配，彼此通过指针相连，每个结点只有一个前驱结点和后继结点。首节点无前驱结点，尾结点无后继结点的一种存储结构 链表结构头结点：链表的第一个有效结点前面的结点，头结点并不存放有效数据，也就是数据域为空，加头结点的主要目的是为了方便链表的操作。首节点：链表的第一个有效结点，结点包含数据域和指针域。尾结点：尾结点的指针域为空。头指针：指向头结点的指针变量，它存放了头结点的地址(头指针存放的是头结点的地址)。 定义链表结点/* 定义单链表结点类型 */ typedef struct Node{ int element;//数据域 struct Node *next;//指针域 }Node; 单链表初始化无头结点链表/* 初始化线性表，即置单链表的表头指针为空 */ void initList(Node **pNode) { *pNode=(Node *)malloc( sizeof(Node)); *pNode = NULL; printf(&quot;initList函数执行，初始化成功\n&quot;); } 带头结点链表/* 初始化线性表，即置单链表的首节点指针为空 */ void initHeadList(Node **pNode) { *pNode=(Node *)malloc( sizeof(Node)); (*pNode)-&gt;next= NULL; printf(&quot;initHeadList函数执行，初始化成功\n&quot;); } 单链表创建无头结点链表Node *creatList(Node *pHead) { Node *new_node;//新建结点 Node *cur_node;//当前结点 int data; printf(&quot;输入节点：\n&quot;); scanf(&quot;%d&quot;,&amp;data); while(data &gt; 0) //输入的值大于0则继续，直到输入的值为负 { new_node=(Node *)malloc(sizeof(Node)); //申请新节点 if(NULL==new_node) { printf(&quot;新节点内存分配失败\n&quot;); exit(0); } memset(new_node,0,sizeof(Node)); new_node-&gt;element=data;//输入data存入结点的数据域 if (pHead==NULL) //首结点若为空，新节点为首结点 { pHead=new_node; } else //首结点不为空，已插入结点 { cur_node-&gt;next=new_node;//当前结点的指针指向新节点 } cur_node=new_node; //将当前结点移向新节点 scanf(&quot;%d&quot;,&amp;data); new_node-&gt;next = NULL; //新节点指针域为空 } printf(&quot;creatList函数执行，链表创建成功\n&quot;); return pHead; //返回链表的头指针 } 带头结点链表 /*头节点创建*/ Node *creatHeadList(Node *pHead) { Node *new_node; Node *cur_node; int data; printf(&quot;输入节点：\n&quot;); scanf(&quot;%d&quot;,&amp;data); while(data &gt; 0) //输入的值大于0则继续，直到输入的值为负 { new_node=(Node *)malloc(sizeof(Node)); //申请新节点 if(NULL==new_node) { printf(&quot;新节点内存分配失败\n&quot;); exit(0); } memset(new_node,0,sizeof(Node)); new_node-&gt;element=data; if (pHead-&gt;next==NULL) { pHead-&gt;next=new_node; } else { cur_node-&gt;next=new_node; } cur_node=new_node; scanf(&quot;%d&quot;,&amp;data); new_node-&gt;next = NULL; } printf(&quot;creatHeadList函数执行，链表创建成功\n&quot;); return pHead; //返回链表的头指针 } 打印链表无头结点链表/* 3.打印链表，链表的遍历*/ void printList(Node *pHead) { if(NULL == pHead) //链表为空 { printf(&quot;PrintList函数执行，链表为空\n&quot;); } else { while(NULL != pHead) { printf(&quot;%d &quot;,pHead-&gt;element); pHead = pHead-&gt;next; } printf(&quot;\n&quot;); } } 带头结点链表 /* 3.打印链表，链表的遍历*/ void printHeadList(Node *pHead) { if(NULL == pHead-&gt;next) //链表为空 { printf(&quot;PrintList函数执行，链表为空\n&quot;); } else { while(NULL != pHead-&gt;next) { printf(&quot;%d &quot;,pHead-&gt;next-&gt;element); pHead = pHead-&gt;next; } printf(&quot;\n&quot;); } 链表长度无头结点链表int lengthList(Node *pHead) { int length = 0; while(pHead != NULL) { length++; //遍历链表size大小比链表的实际长度小1 pHead = pHead-&gt;next; } printf(&quot;lengthList函数执行，链表长度 %d \n&quot;,length); return length; //链表的实际长度 } 带头结点链表 /* 返回单链表的长度 */ int lengthHeadList(Node *pHead) { int length = 0; while(NULL != pHead-&gt;next) { length++; //遍历链表size大小比链表的实际长度小1 pHead = pHead-&gt;next; } printf(&quot;lengthList函数执行，链表长度 %d \n&quot;,length); return length; //链表的实际长度 } 链表非空判断无头结点链表/* 检查单链表是否为空，若为空则返回0，否则返回1 */ int isEmptyList(Node *pHead) { int emptyFlag=0; if(pHead == NULL) //链表为空 { printf(&quot;isEmptyList函数执行，链表为空\n&quot;); emptyFlag=0; } else //链表非空 { printf(&quot;isEmptyList函数执行，链表非空\n&quot;); emptyFlag=1; } return emptyFlag; } 带头结点链表 /* 检查单链表是否为空，若为空则返回0，否则返回1 */ int isEmptyHeadList(Node *pHead) { int emptyFlag=0; if(pHead-&gt;next == NULL) { printf(&quot;isEmptyList函数执行，链表为空\n&quot;); emptyFlag=0; } else { printf(&quot;isEmptyList函数执行，链表非空\n&quot;); emptyFlag=1; } return emptyFlag; } 取出链表结点元素无头结点链表/* 返回单链表中第pos个结点中的元素，若pos超出范围，则停止程序运行 */ int getElement(Node *pHead, int pos) { int i=0; if(pos &lt; 1) { printf(&quot;getElement函数执行，pos值非法\n&quot;); return 0; } if(pHead == NULL) { printf(&quot;getElement函数执行，链表为空\n&quot;); return 0; //exit(1); } while(pHead !=NULL) { ++i; if(i == pos) //到达节点。退出 { break; } pHead = pHead-&gt;next; //头结点移到下一结点 } if(i &lt; pos) //链表长度不足则退出 { printf(&quot;getElement函数执行，pos值超出链表长度\n&quot;); return 0; } return pHead-&gt;element; } 带头结点链表 /* 返回单链表中第pos个结点中的元素，若pos超出范围，则停止程序运行 */ int getElementHeadList(Node *pHead, int pos) { int i=0; if(pos &lt; 1) { printf(&quot;getElement函数执行，pos值非法\n&quot;); return 0; } if(pHead-&gt;next == NULL) { printf(&quot;getElement函数执行，链表为空\n&quot;); return 0; //exit(1); } while(pHead-&gt;next !=NULL) { ++i; if(i == pos) //到达节点。退出 { break; } pHead = pHead-&gt;next; //头结点移到下一结点 } if(i &lt; pos) //链表长度不足则退出 { printf(&quot;getElement函数执行，pos值超出链表长度\n&quot;); return 0; } return pHead-&gt;next-&gt;element; } 查找链表元素无头结点链表/*从单链表中查找具有给定值x的第一个元素，若查找成功则返回该结点data域的存储地址，否则返回NULL */ int *getElemAddr(Node *pHead, int x) { if(NULL == pHead) { printf(&quot;getElemAddr函数执行，链表为空\n&quot;); return NULL; } if(x &lt; 0) { printf(&quot;getElemAddr函数执行，给定值X不合法\n&quot;); return NULL; } while((pHead-&gt;element != x) &amp;&amp; (NULL != pHead-&gt;next)) //判断是否到链表末尾，以及是否存在所要找的元素 { pHead = pHead-&gt;next; } if((pHead-&gt;element != x) &amp;&amp; (pHead != NULL)) { printf(&quot;getElemAddr函数执行，在链表中未找到x值\n&quot;); return NULL; } if(pHead-&gt;element == x) { printf(&quot;getElemAddr函数执行，元素 %d 的地址为 0x%x\n&quot;,x,&amp;(pHead-&gt;element)); } return &amp;(pHead-&gt;element);//返回元素的地址 } 带头结点链表/*从单链表中查找具有给定值x的第一个元素，若查找成功则返回该结点data域的存储地址，否则返回NULL */ int *getElemAddrHeadList(Node *pHead, int x) { if(NULL == pHead-&gt;next) { printf(&quot;getElemAddr函数执行，链表为空\n&quot;); return NULL; } if(x &lt; 0) { printf(&quot;getElemAddr函数执行，给定值X不合法\n&quot;); return NULL; } while((pHead-&gt;next-&gt;element != x) &amp;&amp; (NULL != pHead-&gt;next)) //判断是否到链表末尾，以及是否存在所要找的元素 { pHead = pHead-&gt;next; } if((pHead-&gt;next-&gt;element != x) &amp;&amp; (pHead-&gt;next != NULL)) { printf(&quot;getElemAddr函数执行，在链表中未找到x值\n&quot;); return NULL; } if(pHead-&gt;next-&gt;element == x) { printf(&quot;getElemAddr函数执行，元素 %d 的地址为 0x%x\n&quot;,x,&amp;(pHead-&gt;next-&gt;element)); } return &amp;(pHead-&gt;next-&gt;element);//返回元素的地址 } 修改链表元素无头结点链表/* 9.把单链表中第pos个结点的值修改为x的值，若修改成功返回１，否则返回０ */ int modifyElem(Node *pNode,int pos,int x) { int i=0; Node *pHead; pHead = pNode; if(NULL == pHead) { printf(&quot;modifyElem函数执行，链表为空\n&quot;); } if(pos &lt; 1) { printf(&quot;modifyElem函数执行，pos值非法\n&quot;); return 0; } while(pHead !=NULL) { ++i; if(i == pos) { break; } pHead = pHead-&gt;next; //移到下一结点 } if(i &lt; pos) //链表长度不足则退出 { printf(&quot;modifyElem函数执行，pos值超出链表长度\n&quot;); return 0; } pNode = pHead;//要修改结点 pNode-&gt;element = x; //修改为要修改值 printf(&quot;modifyElem函数执行\n&quot;); return 1; } 带头结点链表 /* 把单链表中第pos个结点的值修改为x的值，若修改成功返回１，否则返回０ */ int modifyElemHeadList(Node *pNode,int pos,int x) { int i=0; Node *pHead; pHead = pNode; if(NULL == pHead-&gt;next) { printf(&quot;modifyElemHeadList函数执行，链表为空\n&quot;); } if(pos &lt; 1) { printf(&quot;modifyElemHeadList函数执行，pos值非法\n&quot;); return 0; } while(pHead-&gt;next !=NULL) { ++i; if(i == pos) { break; } pHead = pHead-&gt;next; //移到下一结点 } if(i &lt; pos) //链表长度不足则退出 { printf(&quot;modifyElemHeadList函数执行，pos值超出链表长度\n&quot;); return 0; } pNode = pHead; pNode-&gt;next-&gt;element = x; printf(&quot;modifyElemHeadList函数执行\n&quot;); return 1; } 链表插入表头插入元素无头节点链表/* 10.向单链表的表头插入一个元素 */ int insertHeadList(Node **pNode,int insertElem) { Node *pInsert; pInsert = (Node *)malloc(sizeof(Node)); memset(pInsert,0,sizeof(Node)); pInsert-&gt;element = insertElem; pInsert-&gt;next = *pNode; *pNode = pInsert; printf(&quot;insertHeadList函数执行，向表头插入元素成功\n&quot;); return 1; } 带头结点链表/* 向单链表的表头插入一个元素 */ Node *inserFirsttHeadList(Node *pHead,int insertElem) { Node *pInsert; pInsert = (Node *)malloc(sizeof(Node)); memset(pInsert,0,sizeof(Node)); pInsert-&gt;element = insertElem; pInsert-&gt;next = pHead-&gt;next; pHead-&gt;next = pInsert; printf(&quot;inserFirsttHeadList函数执行，向表头插入元素成功\n&quot;); return pHead; } 表尾插入元素无头节点链表int insertLastList(Node **pNode,elemType insertElem) { Node *pInsert; Node *pHead; Node *pTmp; //定义一个临时链表用来存放第一个节点 pHead = *pNode; pTmp = pHead; pInsert = (Node *)malloc(sizeof(Node)); //申请一个新节点 memset(pInsert,0,sizeof(Node)); pInsert-&gt;element = insertElem; while(pHead-&gt;next != NULL) { pHead = pHead-&gt;next; } pHead-&gt;next = pInsert; //将链表末尾节点的下一结点指向新添加的节点 *pNode = pTmp; printf(&quot;insertLastList函数执行，向表尾插入元素成功\n&quot;); return 1; } 带头结点链表 /* 向单链表的末尾添加一个元素 */ int insertLasHeadtList(Node *pNode,int insertElem) { Node *pInsert; Node *pHead; Node *pTmp; //定义一个临时链表用来存放第一个节点 pHead = pNode; pTmp = pHead; pInsert = (Node *)malloc(sizeof(Node)); //申请一个新节点 memset(pInsert,0,sizeof(Node)); pInsert-&gt;element = insertElem; while(pHead-&gt;next != NULL) { pHead = pHead-&gt;next; } pHead-&gt;next = pInsert; //将链表末尾节点的下一结点指向新添加的节点 pNode = pTmp; printf(&quot;insertLastList函数执行，向表尾插入元素成功\n&quot;); return 1; } 链表删除删除链表指定数据无头节点链表 /* 删除单链表单个元素 */ Node *delElementList(Node *pHead,int delElem) { Node *pre_node;//要删除节点的前一节点 Node *del_node;//删除节点 Node *Head; if(NULL == pHead) { printf(&quot;delElementList函数执行，链表为空\n&quot;); return pHead; } if(delElem &lt; 0) { printf(&quot;delElementList函数执行，给定值X不合法\n&quot;); return pHead; } del_node=pHead; //删除节点从头结点开始 while((del_node-&gt;element != delElem) &amp;&amp; (NULL != del_node-&gt;next)) //判断是否到链表末尾，以及是否存在所要找的元素 { pre_node=del_node; //该节点不是要找节点，设置为前一节点 del_node = del_node-&gt;next;//节点下移 } //到链表尾依然没有要找元素 if((del_node-&gt;element != delElem) &amp;&amp; (del_node != NULL)) { printf(&quot;getElemAddr函数执行，在链表中未找到x值\n&quot;); return NULL; } //找到要删除元素 if(del_node-&gt;element == delElem) { if (del_node==pHead) //若为头结点 { pHead=del_node-&gt;next; } else //不是头结点 { pre_node-&gt;next=del_node-&gt;next; //前一节点的指针指向要删除节点的指针域，即后一节点 } free(del_node); //释放删除节点 printf(&quot;delElementList函数执行，删除元素为 %d \n&quot;,delElem); } Head=pHead; return Head; } 带头结点链表 /* 删除单链表单个元素 */ Node *delElementHeadList(Node *pHead,int delElem) { Node *pre_node;//要删除节点的前一节点 Node *del_node;//删除节点 Node *Head; if(NULL == pHead-&gt;next) { printf(&quot;delElementHeadList函数执行，链表为空\n&quot;); return pHead; } if(delElem &lt; 0) { printf(&quot;delElementHeadList函数执行，给定值X不合法\n&quot;); return pHead; } del_node=pHead-&gt;next; //删除节点从第一个节点开始 while((del_node-&gt;element != delElem) &amp;&amp; (NULL != del_node-&gt;next)) //判断是否到链表末尾，以及是否存在所要找的元素 { pre_node=del_node; //该节点不是要找节点，设置为前一节点 del_node = del_node-&gt;next;//节点下移 } //到链表尾依然没有要找元素 if((del_node-&gt;element != delElem) &amp;&amp; (del_node!= NULL)) { printf(&quot;delElementHeadList函数执行，在链表中未找到x值\n&quot;); return NULL; } //找到要删除元素 if(del_node-&gt;element == delElem) { if (del_node==pHead-&gt;next) //若为第一个结点 { pHead-&gt;next=del_node-&gt;next; } else //不是第一个结点 { pre_node-&gt;next=del_node-&gt;next; //前一节点的指针指向要删除节点的指针域，即后一节点 } free(del_node); //释放删除节点 printf(&quot;delElementList函数执行，删除元素为 %d \n&quot;,delElem); } Head=pHead; return Head; } 删除链表指定结点无头节点链表/* 删除单链表指定节点 */ Node *delPosList(Node *pHead,int pos) { int i=0; Node *pre_node;//要删除节点的前一节点 Node *del_node;//删除节点 if(NULL == pHead) { printf(&quot;delPosLis函数执行，链表为空\n&quot;); return pHead; } if(pos &lt; 0) { printf(&quot;delPosLis函数执行，给定位置pos不合法\n&quot;); return pHead; } del_node=pHead; //删除节点从头结点开始匹配 while(del_node !=NULL) { ++i; if(i == pos) { if (pos==1) //若删除的是头结点 { pHead=del_node-&gt;next; } else //若删除的不是头结点 { pre_node-&gt;next=del_node-&gt;next; } printf(&quot;delPosList函数执行，删除第 %d个元素\n&quot;,pos); break; } pre_node=del_node; //设置前一节点 del_node= del_node-&gt;next; //移到下一结点 } free(del_node); //释放删除节点 return pHead; } 带头结点链表/* 删除单链表指定节点 */ Node *delPosHeadList(Node *pHead,int pos) { int i=0; Node *pre_node;//要删除节点的前一节点 Node *del_node;//删除节点 Node *Head; if(NULL == pHead-&gt;next) { printf(&quot;delPosLis函数执行，链表为空\n&quot;); return pHead; } if(pos &lt; 0) { printf(&quot;delPosLis函数执行，给定位置pos不合法\n&quot;); return pHead; } del_node=pHead-&gt;next; //删除节点从第一个结点开始匹配 while(del_node !=NULL) { ++i; if(i == pos) { if (pos==1) //若删除的是头结点 { pHead-&gt;next=del_node-&gt;next; } else //若删除的不是头结点 { pre_node-&gt;next=del_node-&gt;next; } printf(&quot;delPosList函数执行，删除第 %d个元素\n&quot;,pos); break; } pre_node=del_node; //设置前一节点 del_node= del_node-&gt;next; //移到下一结点 } free(del_node); //释放删除节点 Head=pHead; return Head; } 清除链表无头节点链表 /* 释放单链表L中所有的结点，使之成为一个空表 */ void clearList(Node *pHead) { Node *pNext; //定义一个与pHead相邻节点 if(pHead == NULL) { printf(&quot;clearList函数执行，链表为空\n&quot;); return; } while(pHead-&gt;next != NULL) { pNext = pHead-&gt;next;//保存下一结点的指针 free(pHead); pHead = pNext; //表头下移 } printf(&quot;clearList函数执行，链表已经清除\n&quot;); } 带头节点链表 /* 4.清除线性表L中的所有元素，即释放单链表L中所有的结点，使之成为一个空表 */ void clearHeadList(Node *pHead) { Node *pNext; //定义一个与pHead相邻节点 if(pHead-&gt;next== NULL) { printf(&quot;clearList函数执行，链表为空\n&quot;); return; } while(pHead-&gt;next != NULL) { pNext = pHead-&gt;next;//保存下一结点的指针 free(pHead); pHead = pNext; //表头下移 } printf(&quot;clearList函数执行，链表已经清除\n&quot;); } 主函数无头节点链表int main() { Node *pList=NULL; Node *newHead=NULL; Node *new2Head=NULL; Node *new3Head=NULL; int length = 0; int emptyFlag=0; int posElement=0; initList(&amp;pList); pList=creatList(pList); printList(pList); length=lengthList(pList); emptyFlag=isEmptyList(pList); //判断链表是否为空链表 posElement=getElement(pList,3); printf(&quot;getElement函数执行，位置 3 中的元素为 %d\n&quot;,posElement); getElemAddr(pList,5); //获得元素5的地址 modifyElem(pList,4,1); //将链表中位置4上的元素修改为1 printList(pList); newHead=insertHeadList(pList,5); //表头插入元素5 printList(newHead); insertLastList(newHead,10); //表尾插入元素10 printList(newHead); new2Head=delElementList(newHead,5); //删除第一个元素5 printList(new2Head); new3Head=delPosList(new2Head,2); printList(new3Head); clearList(new3Head); //清空链表 //printList(new3Head); } 带头节点链表 int main() { Node *pList=NULL; Node *newHead=NULL; Node *new2Head=NULL; Node *new3Head=NULL; int length = 0; int emptyFlag=0; int posElement=0; initHeadList(&amp;pList); pList=creatHeadList(pList); printHeadList(pList); length=lengthHeadList(pList); emptyFlag=isEmptyHeadList(pList); //判断链表是否为空链表 posElement=getElementHeadList(pList,3); printf(&quot;getElement函数执行，位置 3 中的元素为 %d\n&quot;,posElement); getElemAddrHeadList(pList,3); //获得元素3的地址 modifyElemHeadList(pList,3,1); //将链表中位置4上的元素修改为1 printHeadList(pList); newHead=inserFirsttHeadList(pList,5); //表头插入元素5 printHeadList(newHead); insertLasHeadtList(newHead,10); //表尾插入元素10 printHeadList(newHead); new2Head=delElementHeadList(newHead,5); //删除第一个元素5 printHeadList(new2Head); new3Head=delPosHeadList(new2Head,2); printHeadList(new3Head); clearHeadList(new3Head); //清空链表 } 实验验证环境：VC6.0 无头节点链表 带头节点链表]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[函数指针总结]]></title>
      <url>%2F2017%2F03%2F29%2F%E5%87%BD%E6%95%B0%E6%8C%87%E9%92%88%E6%80%BB%E7%BB%93%2F</url>
      <content type="text"><![CDATA[#函数指针定义#函数指针是指向函数的指针变量，即本质是一个指针变量。 ##一般函数指针定义## int (funcPtr)(char , int);(funcPtr)表明funcPtr是一个指针，(char , int)表明funcPtr是一个函数，函数参数为char *和int，返回值为in int *(*funcPtr)(char *, int); funcPtr是函数指针，不同的是前面的int *，表明该函数的返回值为int指针。 ##函数指针数组## int (funcPtr[])(char , int);[]的优先级较高，所以funcPtr是数组，里面的元素为函数指针，所指向的函数原型为int funcPtr(char *, int)。 #函数指针传参#函数指针作为一种类型同样可以作为函数的输入与输出。 //作为输入参数 void func(int x, int (*funcPtr)(char *, int)); //作为返回值 void (*func(int x, int y))(int); 这里括号的优先级最高，func(int x, int y)表面func是一个函数，前面的*表明返回值为一个指针，(int)说明该指针为一个参数为int的函数，void表示该函数指针的返回值为void。 上面定义了一个返回值为函数指针的函数，那怎么定义一个函数指针指向该函数呢，看下面： //一步一步来写，首先他是一个函数指针 (*funcPtr)() //指向的函数的参数为int x, int y (*funcPtr)(int x, int y) //指向的函数的返回值为一个指针 (*(*funcPtr)(int x, int y)) //指向的函数的返回值为一个指针，该指针是参数为int的函数指针 (*(*funcPtr)(int x, int y))(int) //指向的函数的返回值为一个指针，该指针是返回值为void的函数指针 void (*(*funcPtr)(int x, int y))(int) 函数指针和函数原型就差一个(*)，如果知道函数原型的话将函数名改成指针就行了。 void (*func(int x, int y))(int); void (*(*funcPtr)(int x, int y))(int); ##typedef定义##另一种简单的方法是使用typedef，将函数指针定义成一种类型后，可以方便的在函数中使用。 typedef void (*funcPtr1)(int);//定义返回值的函数指针 funcPtr1 (*funcPtr)(int x, int y); #函数指针应用# ##普通函数指针应用##一个函数总是占用一段连续的内存区，而函数名就是该函数所占内存区的首地址（入口地址），所以函数名跟数组名很类似，都是指针常量。函数指针就是指向这个入口地址的指针变量，注意函数指针是一个变量。 void f(int); int main() { //定义函数指针pf并给pf赋值使其指向函数f的入口地址 //pf先跟*结合，说明pf是一个指针，然后与括号结合，说明这个指针指向函数 void (*pf)(int)=f; //等价于void (*pf)(int)=&amp;f; pf(1); (*pf)(2);//把函数指针转换成函数名，这个转换并不需要 f(3); return 0; } void f(int a) { printf(&quot;%d\n&quot;,a); } void (*pf)(int)=&f;函数名被使用时总是由编译器把它转换为函数指针，&amp;操作符只是显示地说明了编译器将隐式执行的任务 。 ##函数指针数组应用## void Touch(); void DuanJiong(); void MeiKai(); void YinJun(); void JiangHaiLong(); void main() { int i; scanf(&quot;%d&quot;,&amp;i); switch(i){ case 0: Touch(); break; case 1: DuanJiong(); break; case 2: MeiKai(); break; case 3: YinJun(); break; case 4: JiangHaiLong(); break; } } void Touch() { puts(&quot;我是Touch&quot;); } void DuanJiong() { puts(&quot;我是段炯&quot;); } void MeiKai() { puts(&quot;我是梅凯&quot;); } void YinJun() { puts(&quot;我是殷俊&quot;); } void JiangHaiLong() { puts(&quot;我是木子&quot;); } 这里只列出了5种情况，如果总共有很多种情况呢，那么就要写一大堆的case语句。而且每次都是从case 1 开始判断。那么是否可以简化代码并且能让程序不做这么多判断呢？这就引出了函数指针数组，顾名思义，就是存放函数指针的数组。现主函数修改如下所示： void main() { int i; void (*p[])()={Touch,DuanJiong,MeiKai,YinJun,JiangHaiLong}; scanf(&quot;%d&quot;,&amp;i); p[i](); } void (*p[])()={Touch,DuanJiong,MeiKai,YinJun,JiangHaiLong};声明了一个函数指针数组并赋值。把每个函数的入口地址存入这个数组，这样就不需要用switch语句了，根据下标i直接找到函数入口，省去了判断的时间。 ##回调函数##回调函数就是一个通过函数指针调用的函数。如果你把函数的指针(地址)作为参数传递给另一个函数，当这个指针被用为调用它所指向的函数时，我们就说这是回调函数。这里函数指针是作为参数传递给另一个函数。冒泡排序，其代码如下： void bubbleSort(int *a,int n) { int i,j; for(i=1;i&lt;n;i++) for(j=1;j&lt;n-i+1;j++){ if(a[j+1]&lt;a[j]){ a[j]=a[j]+a[j+1]; a[j+1]=a[j]-a[j+1]; a[j]=a[j]-a[j+1]; } } } 这个冒泡排序只能对int型数组进行排序。如果我们想写这样一个函数，能同时对int型、float型、double型、char型、结构体类型…数组进行排序，该怎么写呢？也许你会想到函数重载，但是C语言没有这个概念。这里可以用函数指针来实现，其代码比重载更简洁，更高效这也是函数指针的最大用处，参考代码： //回调函数对多种数据类型数组进行冒泡排序 //a表示待排序数组 //n表示数组长度 //size表示数组元素大小(即每个数组元素占用的字节数) //int (*compare)(void *,void *) 声明了一个函数指针，在此作为参数 //void *类型的指针表示指向未知类型的指针,编译器并不会给void类型的指针分配空间,但我们可以把它进行强制类型转换 void bubbleSort(void *a,int n,int size,int (*compare)(void *,void *)) { int i,j,k; char *p,*q; char temp;//交换时暂存一个字节的数据 for(i=0;i&lt;n;i++) for(j=0;j&lt;n-i-1;j++){ //注意p,q都是字符类型的指针，加一都只移动一个字节 p=(char*)a+j*size; q=(char*)a+(j+1)*size; if(compare(p,q)&gt;0) { //一个一个字节的交换,从而实现了一个数据类型数据的交换 for(k=0;k&lt;size;k++){ temp=*p; *p=*q; *q=temp; p++; q++; } } } } （1）void类型的指针未分配空间的，我们可以把它进行强制类型转换成char。（2）对数组元素进行交换时，并不是一次就把两个数交换了，因为我们并不知道数据的确切类型。但知道数组元素的大小，这样就可以逐个字节进行交换。比如对int类型（占用四个字节）的值a、b进行交换，先交换a、b的第一个字节，然后第二个字节…理解了这个代码，该怎么用呢？参数要传入一个函数指针，于是必须要写一个比较两个数大小的函数，且函数原型必须与int (compare)(void ,void *)相匹配。下面是测试各种类型数组排序的代码： #include&lt;stdio.h&gt; typedef struct{ int data; }Node; //函数声明 int charCompare(void *a,void *b); int intCompare(void *a,void *b); int floatCompare(void *a,void *b); int doubleCompare(void *a,void *b); int nodeCompare(void *a,void *b); void bubbleSort(void *a,int n,int size,int (*compare)(void *,void *)); //比较两个char类型的数据的大小，a&gt;b返回1，a&lt;b返回-1，a==b返回0 int charCompare(void *a,void *b) { if(*(char*)a==*(char*)b) return 0; return *(char*)a&gt;*(char*)b?1:-1; } //比较两个int类型的数据的大小 int intCompare(void *a,void *b) { if(*(int*)a==*(int*)b) return 0; return *(int*)a&gt;*(int*)b?1:-1; } //比较两个float类型的数据的大小 int floatCompare(void *a,void *b) { if(*(float*)a==*(float*)b) return 0; return *(float*)a&gt;*(float*)b?1:-1; } //比较两个double类型的数据的大小 int doubleCompare(void *a,void *b) { if(*(double*)a==*(double*)b) return 0; return *(double*)a&gt;*(double*)b?1:-1; } //比较两个结构体类型（Node）的数据的大小 int nodeCompare(void *a,void *b) { if(((Node*)a)-&gt;data == ((Node*)b)-&gt;data) return 0; return ((Node*)a)-&gt;data &gt; ((Node*)b)-&gt;data ? 1 : -1; } void main() { int i=0; //用于测试的各种类型数组 char c[]={&apos;d&apos;,&apos;a&apos;,&apos;c&apos;,&apos;e&apos;,&apos;b&apos;}; int a[]={3,2,4,0,1}; float f[]={4.4,5.5,3.3,0,1}; double b[]={4.4,5.5,3.3,0,1}; Node n[]={{2},{0},{1},{4},{3}}; //对各种数组进行排序 puts(&quot;对char类型数组进行排序：&quot;); bubbleSort(c,5,sizeof(char),charCompare); for(i=0;i&lt;5;i++) printf(&quot;%c &quot;,c[i]); puts(&quot;&quot;); puts(&quot;对int类型数组进行排序：&quot;); bubbleSort(a,5,sizeof(int),intCompare); for(i=0;i&lt;5;i++) printf(&quot;%d &quot;,a[i]); puts(&quot;&quot;); puts(&quot;对float类型数组进行排序：&quot;); bubbleSort(f,5,sizeof(float),floatCompare); for(i=0;i&lt;5;i++) printf(&quot;%.2f &quot;,f[i]); puts(&quot;&quot;); puts(&quot;对double类型数组进行排序：&quot;); bubbleSort(b,5,sizeof(double),doubleCompare); for(i=0;i&lt;5;i++) printf(&quot;%.2lf &quot;,b[i]); puts(&quot;&quot;); puts(&quot;对结构体（Node）类型数组进行排序：&quot;); bubbleSort(n,5,sizeof(Node),nodeCompare); for(i=0;i&lt;5;i++) printf(&quot;%d &quot;,n[i].data); puts(&quot;&quot;); } //回调函数对多种数据类型数组进行冒泡排序 //a表示待排序数组 //n表示数组长度 //size表示数组元素大小(即每个数组元素占用的字节数) //int (*compare)(void *,void *) 声明了一个函数指针，在此作为参数 //void *类型的指针表示指向未知类型的指针,编译器并不会给void类型的指针分配空间,但我们可以把它进行强制类型转换 void bubbleSort(void *a,int n,int size,int (*compare)(void *,void *)) { int i,j,k; char *p,*q; char temp;//交换时暂存一个字节的数据 for(i=0;i&lt;n;i++) for(j=0;j&lt;n-i-1;j++){ //注意p,q都是字符类型的指针，加一都只移动一个字节 p=(char*)a+j*size; q=(char*)a+(j+1)*size; if(compare(p,q)&gt;0){ //一个一个字节的交换,从而实现了一个数据类型数据的交换 for(k=0;k&lt;size;k++){ temp=*p; *p=*q; *q=temp; p++; q++; } } } } #指针函数#指针函数是指带指针的函数，即本质是一个函数。函数返回类型是某一类型的指针 int f(int a, int b);此函数有返回值，返回值为int ，即返回值是指针类型的。上面的函数声明又可以写成如下形式：int f(int a, int b);让指针标志 与int紧贴在一起，而与函数名f间隔开，这样看起来就明了些了，f是函数名，返回值类型是一个int类型的指针。 #指针函数应用#返回指针的函数，确切的说是返回指针类型的函数 #include&lt;stdio.h&gt; //创建长度为n的动态数组 //这是一个指针函数 int* array(int n) { int *a=(int*)malloc(sizeof(int)*n); return a; } void main() { int i,n=3; int *a=array(n); for(i=0;i&lt;n;i++) a[i]=i; free(a);//注意a不用时要free掉，否则内存泄露 } 参考文章函数指针总结http://blog.csdn.net/touch_2011/article/details/6984029]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[C常见关键字]]></title>
      <url>%2F2017%2F03%2F29%2Fstatic%E5%85%B3%E9%94%AE%E5%AD%97%2F</url>
      <content type="text"><![CDATA[前言原文为C语言进阶之道中的关键字章节标准C程序一直由下列部分组成：1）正文段——CPU执行的机器指令部分，也就程序。一个程序只有一个副本；只读，这是为了防止程序由于意外事故而修改自身指令；2）初始化数据段（数据段）——在程序中所有赋了初值的全局变量，存放在这里。3）非初始化数据段（bss段）——在程序中没有初始化的全局变量；内核将此段初始化为0。注意：只有全局变量被分配到数据段中。4）栈——增长方向：自顶向下增长；自动变量以及每次函数调用时所需要保存的信息（返回地址；环境信息）。5）堆——动态存储分配。 static关键字作用1在函数体，一个被声明为静态的变量在这一函数被调用过程中维持其值不变。这样定义的变量称为局部静态变量：在局部变量之前加上关键字static，局部变量就被定义成为一个局部静态变量。也就是上面的作用一中提到的在函数体内定义的变量。除了类型符外，若不加其它关键字修饰，默认都是局部变量。比如以下代码： void test1（void） { unsigned char a； static unsigned char b； … a++； b++； } 变量a是局部变量，变量b为局部静态变量。在函数体，一个被声明为静态的变量（也就是局部静态变量）在这一函数被调用过程中维持其值不变。若是连续两次调用上面的函数test1(),读取a和b的值，a=1，b=2。每次调用test1函数，局部变量a都会重新初始化为0x00；然后执行a++；而局部静态变量在调用过程中却能维持其值不变。 局部静态变量的详细特性，注意它的作用域。1）内存中的位置：静态存储区2）初始化：未经初始化的全局静态变量会被程序自动初始化为0（自动对象的值是任意的，除非他被显示初始化）3）作用域：作用域仍为局部作用域，当定义它的函数或者语句块结束的时候，作用域随之结束。注：当static用来修饰局部变量的时候，它就改变了局部变量的存储位置，从原来的栈中存放改为静态存储区。但是局部静态变量在离开作用域之后，并没有被销毁，而是仍然驻留在内存当中，直到程序结束，只不过我们不能再对他进行访问。 作用2在模块内（但在函数体外），一个被声明为静态的变量可以被模块内所用函数访问，但不能被模块外其它函数访问。它是一个本地的全局变量。这样定义的变量也称为全局静态变量：在全局变量之前加上关键字static，全局变量就被定义成为一个全局静态变量。也就是模块内（但在函数体外）声明的静态变量。例如在源文件中，定义全局静态变量n，该变量只能用与该源文件中的函数。 static int n; void test(); void main() { test(); } 定义全局静态变量的好处： 不会被其他文件所访问，修改，是一个本地的局部变量。 其他文件中可以使用相同名字的变量，不会发生冲突。 全局变量的详细特性，注意作用域，可以和局部静态变量相比较：1）内存中的位置：静态存储区（静态存储区在整个程序运行期间都存在）2）初始化：未经初始化的全局静态变量会被程序自动初始化为0（自动对象的值是任意的，除非他被显示初始化）3）作用域：全局静态变量在声明他的文件之外是不可见的。准确地讲从定义之处开始到文件结尾。 当static用来修饰全局变量的时候，它就改变了全局变量的作用域（在声明他的文件之外是不可见的），但是没有改变它的存放位置，还是在静态存储区中。 作用3在模块内，一个被声明为静态的函数只可被这一模块内的其它函数调用。这个函数被限制在声明它的模块的本地范围内使用。这样定义的变量也称为全局静态变量：在全局变量之前加上关键字static，全局变量就被定义成为一个全局静态变量。也就是上述作用二中提到的在模块内（但在函数体外）声明的静态变量。 定义全局静态变量的好处： 不会被其他文件所访问，修改，是一个本地的局部变量。 其他文件中可以使用相同名字的变量，不会发生冲突。 全局变量的详细特性，注意作用域，可以和局部静态变量相比较：1）内存中的位置：静态存储区（静态存储区在整个程序运行期间都存在）2）初始化：未经初始化的全局静态变量会被程序自动初始化为0（自动对象的值是任意的，除非他被显示初始化）3）作用域：全局静态变量在声明他的文件之外是不可见的。准确地讲从定义之处开始到文件结尾。 当static用来修饰全局变量的时候，它就改变了全局变量的作用域（在声明他的文件之外是不可见的），但是没有改变它的存放位置，还是在静态存储区中。 const关键字（1）const关键字修饰的变量可以认为有只读属性，但它绝不与常量划等号。 const int i=5; int j=0; i=j; //非法，导致编译错误，因为只能被读 j=i; //合法 （2）const关键字修饰的变量在声明时必须进行初始化。 const int i=5; //合法 const int j; //非法，导致编译错误 （3）用const声明的变量虽然增加了分配空间，但是可以保证类型安全。const最初是从C++变化得来的，它可以替代define来定义常量。在旧版本(标准前)的c中，如果想建立一个常量，必须使用预处理器： #define PI 3.14159 此后无论在何处使用PI，都会被预处理器以3.14159替代。编译器不对PI进行类型检查，如果使用不慎，很可能由预处理引入错误。而且，我们也不能得到PI的地址（即不能向PI传递指针和引用）。const的出现，比较好的解决了上述问题。 （4）C标准中，const定义的常量是全局的。 （5）指针定义，若是想定义一个只读属性的指针，那么关键字const要放到‘* ’后面。 char *const cp; //指针不可改变，但指向的内容可以改变 char const *pc1; //指针可以改变，但指向的内容不能改变 const char *pc2; //同上（后两个声明是等同的） （6）将函数传入参数声明为const，以指明使用这种参数仅仅是为了效率的原因，而不是想让调用函数能够修改对象的值。参数const通常用于参数为指针或引用的情况，且只能修饰输入参数;若输入参数采用“值传递”方式，由于函数将自动产生临时变量用于复制该参数，该参数本就不需要保护，所以不用const修饰。 void fun0(const int * a ); void fun1(const int &amp; a); 调用函数的时候，用相应的变量初始化const常量，则在函数体中，按照const所修饰的部分进行常量化，如形参为const int * a，则不能对传递进来的指针所指向的内容进行改变，保护了原指针所指向的内容；如形参为const int &amp; a，则不能对传递进来的引用对象进行改变，保护了原对象的属性。 （7）修饰函数返回值，可以阻止用户修改返回值。（在嵌入式C中一般不用，主要用于C++） （8）const消除了预处理器的值替代的不良影响，并且提供了良好的类型检查形式和安全性 两个常用的标准C库函数声明，它们都是使用const的典范：1.字符串拷贝函数： char *strcpy（char *strDest，const char *strSrc）； 2.返回字符串长度函数： int strlen（const char *str）； volatile关键定义为volatile 的变量是说这变量可能会被意想不到地改变，这样，编译器就不会去假设这个变量的值了。精确地说就是，优化器在用到这个变量时必须每次都小心地重新读取这个变量的值，而不是使用保存在寄存器里的备份。 由于访问寄存器的速度要快过RAM，所以编译器一般都会作减少存取外部RAM的优化。比如： static int i=0; int main(void) { ... while (1) { if (i) dosomething(); } } /* Interrupt service routine. */ void ISR_2(void) { i=1; } 程序的本意是ISR_2中断产生时，在main当中调用dosomething函数，但是，由于编译器判断在main函数里面没有修改过i，因此可能只执行一次对从i到某寄存器的读操作，然后每次if判断都只使用这个寄存器里面的“i副本”，导致dosomething永远也不会被调用。如果将变量加上volatile修饰，则编译器保证对此变量的读写操作都不会被优化（肯定执行）。此例中i也应该如此说明。 volatile用在如下的几个地方： 1、中断服务程序中修改的供其它程序检测的变量需要加volatile； 2、多任务环境下各任务间共享的标志应该加volatile； 3、存储器映射的硬件寄存器通常也要加volatile说明，因为每次对它的读写都可能有不同意义； 举例分析： 代码一: int a,b,c; //读取I/O空间0x100端口的内容 a= inword(0x100); b=a; a=inword(0x100) c=a; 代码二: volatile int a; int a,b,c; //读取I/O空间0x100端口的内容 a= inword(0x100); b=a; a=inword(0x100) c=a; 在上述例子中,代码一会被绝大多数编译器优化为如下代码: a=inword(0x100) b=a; c=a;这显然与编写者的目的不相符,会出现I/O空间0x100端口漏读现象,若是增加volatile,像代码二所示的那样,优化器将不会优化掉任何代码 struct与typedef关键字在网络协议、通信控制、嵌入式系统的C/C++编程中，经常要传送的不是简单的字节流（char型数组），而是多种数据组合起来的一个整体，其表现形式是一个结构体 struct关键字的作用是它可以实现对数据的封装,有一点点类似与C++的对象,可以将一些分散的特性对象化,这在编写某些复杂程序时提供很大的方便性.用法:在C中定义一个结构体类型要用typedef: typedef struct Student { int a; }Stu; 声明变量 Stu stu1; 如果没有typedef声明变量 struct Student stu1; 这里的Stu实际上就是struct Student的别名，另外这里也可以不写Student typedef struct { int a; }Stu; 比如编写一个菜单程序,你要知道本级菜单的菜单索引号、焦点在屏上是第几项、显示第一项对应的菜单条目索引、菜单文本内容、子菜单索引、当前菜单执行的功能操作。若是对上述条目单独操作，那么程序的复杂程度将会大到不可想象，这时候结构体struct就开始显现它的威力了： //结构体定义 typedef struct { unsigned char CurrentPanel;//本级菜单的菜单索引号 unsigned char ItemStartDisplay; //显示第一项对应的菜单条目索引 unsigned char FocusLine; //焦点在屏上是第几项 }Menu_Statestruct; typedef struct { unsigned char *MenuTxt; //菜单文本内容 unsigned char MenuChildID;//子菜单索引 void (*CurrentOperate)();//当前菜单执行的功能操作 }MenuItemStruct; typedef struct { MenuItemStruct *MenuPanelItem; unsigned char MenuItemCount; }MenuPanelStruct;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[嵌入式位域]]></title>
      <url>%2F2017%2F03%2F29%2FC%E8%AF%AD%E8%A8%80%E4%BD%8D%E5%9F%9F%2F</url>
      <content type="text"><![CDATA[前言有些信息在存储时，并不需要占用一个完整的字节， 而只需占几个或一个二进制位。例如在存放一个开关量时，只有0和1 两种状态，用一位二进位即可。为了节省存储空间，并使处理简便，Ｃ语言提供了一种数据结构，称为“位域”或“位段”。所谓“位域”是把一个字节中的二进位划分为几个不同的区域，并说明每个区域的位数。每个域有一个域名，允许在程序中按域名进行操作。 这样就可以把几个不同的对象用一个字节的二进制位域来表示。 位域的定义和位域变量的说明位域定义与结构定义相仿，其形式为：struct 位域结构名{ 位域列表 };其中位域列表的形式为： 类型说明符 位域名：位域长度例如： struct bs { int a:8; int b:2; int c:6; }; 位域变量的说明与结构变量说明的方式相同。 可采用先定义后说明，同时定义说明或者直接说明这三种方式。例如： struct bs { int a:8; int b:2; int c:6; }data; 说明data为bs变量，共占两个字节。其中位域a占8位，位域b占2位，位域c占6位。备注： 一个位域必须存储在同一个字节中，不能跨两个字节。如一个字节所剩空间不够存放另一位域时，应从下一单元起存放该位域。也可以有意使某位域从下一单元开始。例如：struct bs{ unsigned a:4; unsigned :0; unsigned b:4; unsigned c:4;}在这个位域定义中，a占第一字节的4位，后4位填0表示不使用，b从第二字节开始，占用4位，c占用4位。 由于位域不允许跨两个字节，因此位域的长度不能大于一个字节的长度，也就是说不能超过8位二进位。位域可以无位域名，这时它只用来作填充或调整位置。无名的位域是不能使用的。例如： struct k { int a:1; int :2; int b:3; int c:2; }; 位域的使用位域的使用和结构成员的使用相同，其一般形式为：位域变量名·位域名位域允许用各种格式输出。 main(){ struct bs { unsigned a:1; unsigned b:3; unsigned c:4; } bit,*pbit; bit.a=1; bit.b=7; bit.c=15; printf(&quot;%d,%d,%d\n&quot;,bit.a,bit.b,bit.c); pbit=&amp;bit; pbit-&gt;a=0; pbit-&gt;b&amp;=3; pbit-&gt;c|=1; printf(&quot;%d,%d,%d\n&quot;,pbit-&gt;a,pbit-&gt;b,pbit-&gt;c); } 上例程序中定义了位域结构bs，三个位域为a,b,c。说明了bs类型的变量bit和指向bs类型的指针变量pbit。这表示位域也是可以使用指针的。程序的9、10、11三行分别给三个位域赋值。( 赋值不能超过该位域的允许范围)程序第12行以整型量格式输出三个域的内容。第13行把位域变量bit的地址送给指针变量pbit。第14行用指针方式给位域a重新赋值，赋为0。第15行使用了复合的位运算符”&amp;=”，该行相当于：pbit-&gt;b=pbit-&gt;b&amp;3位域b中原有值为7，与3作按位与运算的结果为3(111&amp;011=011,十进制值为3)。同样，程序第16行中使用了复合位运算”|=” 位域规则C99规定int、unsigned int和bool可以作为位域类型，但编译器几乎都对此作了扩展，允许其它类型类型的存在。使用位域的主要目的是压缩存储，其大致规则为：1) 如果相邻位域字段的类型相同，且其位宽之和小于类型的sizeof大小，则后面的字段将紧邻前一个字段存储，直到不能容纳为止；2) 如果相邻位域字段的类型相同，但其位宽之和大于类型的sizeof大小，则后面的字段将从新的存储单元开始，其偏移量为其类型大小的整数倍；3) 如果相邻的位域字段的类型不同，则各编译器的具体实现有差异，VC6采取不压缩方式，Dev-C++采取压缩方式；4) 如果位域字段之间穿插着非位域字段，则不进行压缩；5) 整个结构体的总大小为最宽基本类型成员大小的整数倍。 位域实例typedef struct AA { unsigned char b1:5; unsigned char b2:5; unsigned char b3:5; unsigned char b4:5; unsigned char b5:5; }AA; sizeof(AA) = 5; 但实际上只用了25位，即4个字节 （1）typedef struct AA { unsigned int b1:5; unsigned int b2:5; unsigned int b3:5; unsigned int b4:5; unsigned int b5:5; }AA; （2）typedef struct AA { unsigned int b1:5; unsigned int b2:5; unsigned int b3:5; unsigned int b4:5; unsigned int b5:5; unsigned int b6:5; unsigned int b7:5; }AA; （1）是5个成员,按第一条规则,共占25位,按第五条规则,即sizeof(AA)=4现把成员加到7个，参考（2）,按第一条规则,共占35位,按第五条规则,即sizeof(AA)=8, struct test1 { char a:1; char :2; long b:3; char c:2; }; int len = sizeof(test1);对于上述例子，len的值应该是12. 首先以最长的类型位宽做为偏移量，最长的是long型，占4位，所以不同类型之间应该是4个字节的偏移，即test1应该是4字节的整数倍。 char a：1； //用一个字节去存储char ：2； //空域。因为与前面的a的类型相同，而两个位域的位宽相加仍然少于8位，所以依然用1个字节表示long b：3； //long类型的位宽是4个字节，与前面的char类型不同，所以b与a之间偏移4个字节，它们之间自动补充3个字节 char c：2； //因为c与b又不同型，以test1中的最长的long类型的位宽进行偏移，所以虽然char只用1个字节就够了//但依然要占4个字节。总共是12字节。 struct s1 { int i: 8; int j: 4; int a: 3; double b; }; struct s2 { int i: 8; int j: 4; double b; int a:3; }; printf(&quot;sizeof(s1)= %d\n&quot;, sizeof(s1)); printf(&quot;sizeof(s2)= %d\n&quot;, sizeof(s2)); result: 16, 24 第一个struct s1 { int i: 8; int j: 4; int a: 3; double b; }; 理论上是这样的，首先是i在相对0的位置，占8位一个字节，然后，j就在相对一个字节的位置，由于一个位置的字节数是4位的倍数，因此不用对齐，就放 在那里了，然后是a，要在3位的倍数关系的位置上，因此要移一位，在15位的位置上放下，目前总共是18位，折算过来是2字节2位的样子，由于 double是8 字节的，因此要在相对0要是8个字节的位置上放下，因此从18位开始到8个字节之间的位置被忽略，直接放在8字节的位置了，因此，总共是16字节。 位域应用但是当我们编写网络程序的时候，要注意网络字节序和位序都是大端序的，而主机很多都是小端序。所以在网络中的第一个位字段通常放在一个字节的末尾，而在网络中的最后一个字节的位字段，则放在一个字节的前面。 struct{ uint8_t type: 4; uint8_t flag: 1; //1: control, 0:data uint8_t extension: 1; uint8_t R: 2; } __attribute__((__packed__)) MacCtlHdr_t; 这个是小端序主机上的定义，对应于下图中的帧格式 struct{ uint8_t RN_M4: 4; uint8_t cause: 3; uint8_t type: 1; uint8_t RN_M8: 8; uint8_t RN_L8: 8; uint8_t R: 4; uint8_t bsr: 4; }__attribute__((__packed__)) RA_HEADER; 对应于这样的帧格式：本地存储的是小端序，但是机器发送的时候是大端序。对已从每个字节的高位先行发送。所以顺序是第一字节的type，cause，RN4，之后是第二字节RNM8和第三字节RNL8，之后是第三字节的bsr和R。 #参考C语言位域精解C语言位域，字节序，帧格式]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Hexo+Github搭建个人博客（二）]]></title>
      <url>%2F2017%2F03%2F29%2Fhexo-github-two%2F</url>
      <content type="text"><![CDATA[安装NEXT主题下载主题Hexo 安装主题的方式非常简单，只需要将主题文件拷贝至站点目录的 themes 目录下， 然后修改下配置文件即可。 cd bloggit clone https://github.com/iissnan/hexo-theme-next themes/next 启用next主题在站点配置文件_config.yml中： theme: next 验证主题 hexo shttp://localhost:4000 NEXT主题设置Hexo 中有两份主要的配置文件，其名称都是 _config.yml 。其中，一份位于站点根目录下，主要包含 Hexo 本身的配置；另一份位于主题目录下，主要用于配置主题相关的选项。前者称为 站点配置文件，后者称为 主题配置文件 基本设置关于NEXT主题的基本设置可参考NEXT在线文档，包含NEXT主题的详细使用介绍。 其他设置添加High一下打开博客根目录 \themes\next\layout\_partials\header.swig ，在&lt;ul&gt; ... /ul&gt; 标签之间加入以下代码：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137&lt;li&gt; &lt;a title="把这个链接拖到你的Chrome收藏夹工具栏中" href='javascript:(function() &#123; function c() &#123; var e = document.createElement("link"); e.setAttribute("type", "text/css"); e.setAttribute("rel", "stylesheet"); e.setAttribute("href", f); e.setAttribute("class", l); document.body.appendChild(e) &#125; function h() &#123; var e = document.getElementsByClassName(l); for (var t = 0; t &lt; e.length; t++) &#123; document.body.removeChild(e[t]) &#125; &#125; function p() &#123; var e = document.createElement("div"); e.setAttribute("class", a); document.body.appendChild(e); setTimeout(function() &#123; document.body.removeChild(e) &#125;, 100) &#125; function d(e) &#123; return &#123; height : e.offsetHeight, width : e.offsetWidth &#125; &#125; function v(i) &#123; var s = d(i); return s.height &gt; e &amp;&amp; s.height &lt; n &amp;&amp; s.width &gt; t &amp;&amp; s.width &lt; r &#125; function m(e) &#123; var t = e; var n = 0; while (!!t) &#123; n += t.offsetTop; t = t.offsetParent &#125; return n &#125; function g() &#123; var e = document.documentElement; if (!!window.innerWidth) &#123; return window.innerHeight &#125; else if (e &amp;&amp; !isNaN(e.clientHeight)) &#123; return e.clientHeight &#125; return 0 &#125; function y() &#123; if (window.pageYOffset) &#123; return window.pageYOffset &#125; return Math.max(document.documentElement.scrollTop, document.body.scrollTop) &#125; function E(e) &#123; var t = m(e); return t &gt;= w &amp;&amp; t &lt;= b + w &#125; function S() &#123; var e = document.createElement("audio"); e.setAttribute("class", l); e.src = i; e.loop = false; e.addEventListener("canplay", function() &#123; setTimeout(function() &#123; x(k) &#125;, 500); setTimeout(function() &#123; N(); p(); for (var e = 0; e &lt; O.length; e++) &#123; T(O[e]) &#125; &#125;, 15500) &#125;, true); e.addEventListener("ended", function() &#123; N(); h() &#125;, true); e.innerHTML = " &lt;p&gt;If you are reading this, it is because your browser does not support the audio element. We recommend that you get a new browser.&lt;/p&gt; &lt;p&gt;"; document.body.appendChild(e); e.play() &#125; function x(e) &#123; e.className += " " + s + " " + o &#125; function T(e) &#123; e.className += " " + s + " " + u[Math.floor(Math.random() * u.length)] &#125; function N() &#123; var e = document.getElementsByClassName(s); var t = new RegExp("\\b" + s + "\\b"); for (var n = 0; n &lt; e.length; ) &#123; e[n].className = e[n].className.replace(t, "") &#125; &#125; var e = 30; var t = 30; var n = 350; var r = 350; var i = "//7xuupy.com1.z0.glb.clouddn.com/tongxingSibel%20-%20Im%20Sorry.mp3"; var s = "mw-harlem_shake_me"; var o = "im_first"; var u = ["im_drunk", "im_baked", "im_trippin", "im_blown"]; var a = "mw-strobe_light"; var f = "//s3.amazonaws.com/moovweb-marketing/playground/harlem-shake-style.css"; var l = "mw_added_css"; var b = g(); var w = y(); var C = document.getElementsByTagName("*"); var k = null; for (var L = 0; L &lt; C.length; L++) &#123; var A = C[L]; if (v(A)) &#123; if (E(A)) &#123; k = A; break &#125; &#125; &#125; if (A === null) &#123; console.warn("Could not find a node of the right size. Please try a different page."); return &#125; c(); S(); var O = []; for (var L = 0; L &lt; C.length; L++) &#123; var A = C[L]; if (v(A)) &#123; O.push(A) &#125; &#125; &#125;)() '&gt;High一下&lt;/a&gt; &lt;/li&gt; 添加最近访客 在主题配置文件中menu项添加guestbook菜单 在Hexo的source文件夹下，利用hexo new page guestbook创建guestbook页面,对应的index文件中添加如下代码：12最近访客 &lt;div class=&quot;ds-recent-visitors&quot; data-num-items=&quot;39&quot; data-avatar-size=&quot;40&quot; id=&quot;ds-recent-visitors&quot;&gt;&lt;/div&gt; 修改文章内链接文本样式将链接文本设置为蓝色，鼠标划过时文字颜色加深，并显示下划线。找到文件 themes\next\source\css\_custom\custom.styl ，添加如下 css 样式：12345678.post-body p a &#123; color: #0593d3; border-bottom: none; &amp;:hover &#123; color: #0477ab; text-decoration: underline; &#125;&#125; 给 Github 添加 README默认情况下，Github中每一个项目，我们希望有一份 README.md 的文件来作为项目的说明，但是我们在项目根目录下的 blog\source 目录下创建一份 README.md 文件，写好说明介绍，部署的时候，这个 README.md 会被 hexo 解析掉，而不会被解析到 Github 中去的。正确的解决方法其实很简单： 把 README.md 文件的后缀名改成 “MDOWN” 然后扔到blog/source文件夹下即可，这样 hexo 不会解析，Github 也会将其作为 MD 文件解析。 插入网易云音乐如果只加入单曲，只需要搜索歌曲，点开歌曲名，点击生成外链播放器，复制html代码将html代码无需任何修改放入markdown文章里就OK了。 如果想要加入歌单，就需要自己创建歌单，然后分享歌单，找到自己的分享动态，点进去可以看到有“生成外链播放器”这些字眼，其余操作就和上面一样了。 参考Never_yu’s Blog]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[keil兼容51与ARM]]></title>
      <url>%2F2017%2F03%2F29%2Fkeil%E5%85%BC%E5%AE%B9C51%E4%B8%8EARM%2F</url>
      <content type="text"><![CDATA[前言设置keil4使其兼容C51与ARM，避免装多个版本keil。环境：keil4 for ARM 方法第一步在keil4的安装文件中找到TOOLS.ini，在[ARM]前面添加C51项 [C51] PATH=&quot;E:\keil\C51\&quot; SN=K1DZP-5IUSH-A01UE VERSION=V9.01 BOOK0=HLP\RELEASE_NOTES.HTM(&quot;Release Notes&quot;,GEN) BOOK1=HLP\GS51.PDF(&quot;uVision2 Getting Started&quot;,GEN) BOOK2=HLP\C51.PDF(&quot;C51 User&apos;s Guide&quot;,GEN) BOOK3=HLP\C51LIB.CHM(&quot;C51 Library Functions&quot;,C) BOOK4=HLP\A51.PDF(&quot;Assembler/Utilities&quot;,GEN) BOOK5=HLP\TR51.CHM(&quot;RTX51 Tiny User&apos;s Guide&quot;,GEN) BOOK6=HLP\DBG51.CHM(&quot;uVision2 Debug Commands&quot;,GEN) BOOK7=HLP\ISD51.CHM(&quot;ISD51 In System Debugger&quot;,GEN) BOOK8=HLP\FlashMon51.CHM(&quot;Flash Monitor&quot;,GEN) BOOK9=MON390\MON390.HTM(&quot;MON390: Dallas Contiguous Mode Monitor&quot;,GEN) TDRV0=BIN\MON51.DLL (&quot;Keil Monitor-51 Driver&quot;) TDRV1=BIN\ISD51.DLL (&quot;Keil ISD51 In-System Debugger&quot;) TDRV2=BIN\MON390.DLL (&quot;MON390: Dallas Contiguous Mode&quot;) TDRV3=BIN\LPC2EMP.DLL (&quot;LPC900 EPM Emulator/Programmer&quot;) TDRV4=BIN\UL2UPSD.DLL (&quot;ST-uPSD ULINK Driver&quot;) RTOS1=RTXTINY.DLL (&quot;RTX-51 Tiny&quot;) RTOS2=RTX51.DLL (&quot;RTX-51 Full&quot;) TOOLS修改后如下图所示： 第二步按照安装ARM时注册一样，注册C51 第三步在keil4安装文件下添加C51编译器，可有从他人装好了的c51下复制过来。这里我采用的是keil2下的c51编译器 资源keil4c51编译器)]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[ubuntu常见问题]]></title>
      <url>%2F2017%2F03%2F29%2FUbuntu%E8%AF%86%E5%88%AB%E9%A9%B1%E5%8A%A8%E9%97%AE%E9%A2%98%2F</url>
      <content type="text"><![CDATA[前言在Ubuntu下经常碰到这样那样的问题，将这些问题总结起来方便解决 USB无法识别情况：Host USb device connections disabled 解决：在Windows中的运行下输入services.MSC,进入系统服务列表项，启动USB服务。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Notepad使用教程]]></title>
      <url>%2F2017%2F03%2F29%2FNotepad%2B%2B%E4%BD%BF%E7%94%A8%E6%95%99%E7%A8%8B%2F</url>
      <content type="text"><![CDATA[#Notepad++简介#Notepad++是Windows平台上一款强大的文本编辑器，轻量化，可定制性强，加上功能强大的插件，可以胜任绝大部分工作。 常用功能书签功能书签是一种特殊的行标记，显示在编辑器的书签栏处。使用书签，可以很容易转到指定行处，进行一些相关的操作。在任意行点击左边栏或者按Ctrl+F2会出现蓝色小点，点击蓝色小点或按Ctrl+F2可以取消该行书签。F2光标移动到上一个书签，Shift+F2光标移动到下一个书签。 多视图功能可以在 Notepad++ 中打开第二个编辑窗口，这同时查看两个文档了（也可以是同一个文档）。如果它们是同一个文档的话，你就可以快速比较这两个文档，或者同时编辑文档的两个地方，而不需要滚动或通过书签来做到这点。对于同一文件，在文件标签项上右键-复制到另一视图对于不同文件，在文件标签项上右键-移动到另一视图 折叠功能根据文档语言可以隐藏文档中的多行文本，文本块分成多个层次，可以折叠父层的文本块，折叠后只会显示文本块的第一行内容。取消折叠文本块（展开或取消折叠）将会再次显示折叠的文本块。折叠所有层次： Alt+0展开所有层次： Alt+shift+0折叠当前层次： Ctrl+Alt+f展开当前层次： Ctrl+Alt+Shift+f 行定位功能用于快速跳至某一行。Ctrl+g会弹出一个对话框，可以选择输入绝对行号跳转或者相对于当前行做偏移量跳转。 向后回滚和向前回滚向后回滚即撤销： Ctrl+z，向前回滚即回到前一步骤： Ctrl+y。 快匹配功能选择一个括号，按Ctrl+b会跳转到与它对应的另外一半括号处。此处括号包括”(“和”{“。 颜色标记功能给内容用不同的颜色做标记，选择要标记的文本然后点击右键-&gt;Style token，选择一个标记即可。也可以通过点击右键选择删除颜色标记Remove style。 tab键转换成空格在设置-首选项-&gt;语言页面可以选择“以空格代替Tab”，同时可以配置一个Tab键替换成几个空格。可以很方便的按Tab键进行缩进，按Shift+Tab进行反向缩进。 显示符号功能在视图选项卡中能找到显示符号功能，可以显示空格、制表键、换行等 可以方便编辑，尤其可以防止无意中加入好多不需要的空格。 快捷键大全文件菜单快捷键 动作Ctrl-O 打开文件Ctrl-N 新建文件Ctrl-S 保存文件Ctrl-Alt-S 另存为Ctrl-Shift-S 保存所有Ctrl-P 打印Alt-F4 退出Ctrl-Tab 下一个文档 (显示所有打开的文件列表)。可以禁止此快捷键 - 参见 设置/首选项/全局.Ctrl-Shift-Tab 上一个文档 (显示所有打开的文件列表). 可以禁止此快捷键 - 同上.Ctrl-W 关闭当前文档 编辑菜单快捷键 动作Ctrl-C 拷贝Ctrl-Insert 拷贝Ctrl-Shift-T 拷贝当前行Ctrl-X 剪切Shift-Delete 剪切Ctrl-V 粘贴Shift-Insert 粘贴Ctrl-Z 撤销Alt-Backspace 撤销Ctrl-Y 重做Ctrl-A 选择全部Alt-Shift-方向键, 或者 Alt + 鼠标左键 列模式选择Ctrl + 鼠标左键 开始新的选择区域。仅在多块区域有效ALT-C 列编辑Ctrl-D 复制当前行Ctrl-T 当前行和前一行交换Ctrl-Shift-Up 当前行或当前单个选中文本块上移Ctrl-Shift-Down 当前行或当前单个选择文本块下移Ctrl-L 删除当前行Ctrl-I 分割当前行Ctrl-J 连结行Ctrl-G 打开转到对话框Ctrl-Q 行注释/取消行注释Ctrl-Shift-Q 块注释Tab (一行或多行被选中) 插入制表符或空格 (缩进)Shift-Tab (一行或多行被选中) 删除行首制表符或空格(取消缩进)Ctrl-BackSpace 删除到单词开头Ctrl-Delete 删除到单词末尾Ctrl-Shift-BackSpace 删除到行首Ctrl-Shift-Delete 删除到行尾Ctrl-U 转换为小写Ctrl-Shift-U 转换为大写Ctrl-B 转到匹配括号处Ctrl-Space 显示函数参数提示列表Ctrl-Shift-Space 显示函数提示列表Ctrl-Enter 显示单词提示列表Ctrl-Alt-R 文本方向从右到走Ctrl-Alt-L 文本方向从左到右Enter 回车插入新行或分割文本到新行Shift-Enter 插入新行或分割文本到新行 搜索菜单快捷键 操作Ctrl-F 打开查找对话框Ctrl-H 打开 查找 / 替换 对话框F3 查找下一个Shift-F3 查找上一个Ctrl-Shift-F 在文件中查找F7 切换到搜索结果窗口（即版本5.2之前的激活子视图）Ctrl-Alt-F3 查找 (快速) 下一个Ctrl-Alt-Shift-F3 查找 (快速) 上一个Ctrl-F3 选择并查找下一个（即版本5.6.5之前中的查找（快速）下一个）Ctrl-Shift-F3 选择并查找下一个(即版本5.6.5之前的查找 (快速) 上一个)F4 转到下一个结果Shift-F4 转到上一个结果Ctrl-Shift-I 增量搜索Ctrl-n 向下跳转（到下一个样式n标记的文本。 n 从1到5, 对于默认查找样式为0Ctrl-Shift-n 向上跳转 (到上一个样式n标记的文本。n 从1到5，对于默认查找样式为0Ctrl-F2 标记/取消标记书签F2 转到下一个书签Shift-F2 转到上一个书签 视图菜单快捷键 动作Ctrl-(Keypad-/Keypad+) 或者 Ctrl + 鼠标滚轮按钮 (如果你的鼠标有这个键的话) 放大 (+ 或者 向上键) 和 缩小 (- 或者 向下键)Ctrl-Keypad/ 恢复视图到原始大小F11 转到/退出全屏视图F12 转到/退出切换快捷视图Ctrl-Alt-F 折叠当前大纲级别Ctrl-Alt-Shift-F 展开当前大纲级别Alt-0 折叠所有Alt-(1~8) 折叠大纲级别 (1~8)Alt-Shift-0 展开所有Alt-Shift-(1~8) 展开大纲级别 (1~8) 运行菜单快捷键 操作F5 打开运行对话框Alt-F1 获取PHP帮助Alt-F2 Google 搜索Alt-F3 Wikipedia 搜索Alt-F5 打开文件(当前光标处的文件名)Alt-F6 在新的实例中打开文件 (当前光标处的文件名)Ctrl-Alt-Shift-R 在 Chrome 中打开Ctrl-Alt-Shift-X 在 Firefox 中打开Ctrl-Alt-Shift-I 在 IE 中打开Ctrl-Alt-Shift-F 在 Safari 中打开Ctrl-Alt-Shift-O 通过 Outlook 发送 参考文章Notepad++使用教程]]></content>
    </entry>

    
  
  
</search>
